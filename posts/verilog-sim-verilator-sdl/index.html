<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"  lang="en-gb">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1"/>

<title>Verilog Simulation with Verilator and SDL | Project F - FPGA Development</title>

<meta property='og:title' content='Verilog Simulation with Verilator and SDL - Project F - FPGA Development'>
<meta property='og:description' content='It can be challenging to test your FPGA or ASIC graphics designs. You can perform low-level behavioural simulations and examine waveforms, but you also need to verify how the video output will appear on the screen.
By combining Verilator and SDL, you can build Verilog simulations that let you see your design on your computer. The thought of creating a graphical simulation can be intimidating, but it&rsquo;s surprisingly simple: you can get a simulation running in under an hour.'>
<meta property='og:url' content='https://projectf.io/posts/verilog-sim-verilator-sdl/'>
<meta property='og:site_name' content='Project F - FPGA Development'>
<meta property='og:type' content='article'><meta property='og:image' content='https://projectf.io/img/posts/verilog-sim-verilator-sdl/social-card.png'><meta property='article:published_time' content='2021-06-11T00:00:00Z'/><meta property='article:modified_time' content='2021-06-11T00:00:00Z'/><meta name='twitter:card' content='summary_large_image'><meta name='twitter:site' content='@WillFlux'><meta name='twitter:creator' content='@WillFlux'>


<link href="https://projectf.io/index.xml" rel="alternate" type="application/rss+xml" title="Project F - FPGA Development" />

<link rel="stylesheet" href="/css/style.css"/><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
<link rel="canonical" href="https://projectf.io/posts/verilog-sim-verilator-sdl/">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff">
<meta name="referrer" content="no-referrer, same-origin">
</head>
<body>
<section class="section">
  <div class="container">
    <nav id="nav-main" class="nav">
      <div id="nav-name" class="nav-left">
        <a id="nav-anchor" class="nav-item" href="https://projectf.io">
          <h1 id="nav-heading" class="title is-4">Project F - FPGA Development</h1>
        </a>
      </div>
      <div class="nav-right">
        <nav id="nav-items" class="nav-item level is-mobile"><a class="level-item" aria-label="github" href='https://github.com/projf'
            target='_blank' rel='noopener'>
            <span class="icon">
              <i class><svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
    
    <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"/>
    
  </svg></i>
            </span>
          </a><a class="level-item" aria-label="twitter" href='https://twitter.com/WillFlux'
            target='_blank' rel='noopener'>
            <span class="icon">
              <i class><svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
    
    <path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"/>
    
  </svg></i>
            </span>
          </a><a class="level-item" aria-label="youtube" href='https://youtube.com/channel/UCaT0lvfWo1GStbp0neg8weg'
            target='_blank' rel='noopener'>
            <span class="icon">
              <i class><svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
    
    <path d="M22.54 6.42a2.78 2.78 0 0 0-1.94-2C18.88 4 12 4 12 4s-6.88 0-8.6.46a2.78 2.78 0 0 0-1.94 2A29 29 0 0 0 1 11.75a29 29 0 0 0 .46 5.33A2.78 2.78 0 0 0 3.4 19c1.72.46 8.6.46 8.6.46s6.88 0 8.6-.46a2.78 2.78 0 0 0 1.94-2 29 29 0 0 0 .46-5.25 29 29 0 0 0-.46-5.33z"/>
    <polygon points="9.75 15.02 15.5 11.75 9.75 8.48 9.75 15.02"/>
    
  </svg></i>
            </span>
          </a><a class="level-item" aria-label="rss" href='/index.xml'
            target='_blank' rel='noopener'>
            <span class="icon">
              <i class><svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
    
    <path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle>
    
  </svg></i>
            </span>
          </a></nav>
      </div>
    </nav>

    <nav class="nav">
      
      <div class="nav-left"><a class="nav-item" href="/about">
          <h2 class="title is-5">About</h2>
        </a><a class="nav-item" href="/sitemap">
          <h2 class="title is-5">Sitemap</h2>
        </a><a class="nav-item" href="/tags/cookbook">
          <h2 class="title is-5">Cookbook</h2>
        </a><a class="nav-item" href="/tags/explore">
          <h2 class="title is-5">Explore</h2>
        </a><a class="nav-item" href="/tags/tools">
          <h2 class="title is-5">Tools</h2>
        </a></div>
      

      
    </nav>

  </div>
  <script src="/js/navicon-shift.js"></script>
</section>
<section class="section">
  <div class="container">
    <div class="subtitle tags is-6 is-pulled-right">
      
      
<a class="subtitle is-6" href="/tags/testing/">#testing</a>



  
  | <a class="subtitle is-6" href="/tags/tools/">#tools</a>
  
  | <a class="subtitle is-6" href="/tags/verilator/">#verilator</a>
  


      
    </div>
    <h2 class="subtitle is-6">11 June 2021</h2>
    <h1 class="title">Verilog Simulation with Verilator and SDL</h1>
    
    <div class="content">
      <p>It can be challenging to test your FPGA or ASIC graphics designs. You can perform low-level behavioural simulations and examine waveforms, but you also need to verify how the video output will appear on the screen.</p>
<p>By combining <strong>Verilator</strong> and <strong>SDL</strong>, you can build Verilog simulations that let you see your design on your computer. The thought of creating a graphical simulation can be intimidating, but it&rsquo;s surprisingly simple: you can get a simulation running in under an hour.</p>
<p><em>Updated 2021-06-21. Feedback appreciated: get in touch with <a href="https://twitter.com/WillFlux">@WillFlux</a> or open an <a href="https://github.com/projf/projf-explore/issues">issue on GitHub</a>.</em></p>
<h3 id="design-sources">Design Sources</h3>
<p>The C++ and Verilog designs featured in this post are available from the <a href="https://github.com/projf/projf-explore/tree/master/graphics/fpga-graphics/verilator">projf-explore</a> git repo under the open-source MIT licence: build on them to your heart&rsquo;s content. The rest of the blog content is subject to standard copyright restrictions: don&rsquo;t republish it without permission.</p>
<blockquote>
<p><strong>SystemVerilog</strong><br>
We&rsquo;ll use a few choice features from SystemVerilog to make Verilog a little more pleasant. If you&rsquo;re familiar with Verilog, you&rsquo;ll have no trouble. All the SystemVerilog features used are compatible with recent versions of Verilator, Yosys, and Xilinx Vivado.</p>
</blockquote>
<h3 id="contents">Contents</h3>
<ul>
<li><a href="#verilator--sdl">Verilator &amp; SDL</a></li>
<li><a href="#installing-dependencies">Installing Dependencies</a></li>
<li><a href="#working-with-verilator">Working with Verilator</a></li>
<li><a href="#building-and-running">Building &amp; Running</a></li>
<li><a href="#animation">Animation</a></li>
<li><a href="#what-next">What Next?</a></li>
</ul>
<p><em>The following screenshot shows a simulation of the <a href="/posts/fpga-graphics/#bounce">bounce</a> design from the <a href="/posts/fpga-graphics/">FPGA Graphics</a> tutorial.</em></p>
<p><img src="/img/posts/verilog-sim-verilator-sdl/top-bounce-verilator-sdl.png" alt="Simulating top bounce" title="Look mum, no FPGA!"></p>
<h2 id="verilator--sdl">Verilator &amp; SDL</h2>
<p><a href="https://www.veripool.org/verilator/">Verilator</a> is a fast simulator that generates C++ models of Verilog designs.
<a href="https://www.libsdl.org">SDL</a> (LibSDL) is a cross-platform library that provides low-level access to graphics hardware.
Together, Verilator can generate a model of your graphics hardware that SDL draws to a window on your PC.</p>
<p>Verilator supports multi-threaded designs, but I&rsquo;ve stuck to single-threaded designs for graphics testing.
Provided your graphics hardware isn&rsquo;t too complex, a single-threaded Verilator sim manages around one frame per second on a modern PC.</p>
<p>The process is straightforward, even if you&rsquo;ve never written a line of C++ in your life. Cut and paste will get you most of the way there, and I&rsquo;ll take you through the C++ step-by-step.</p>
<h2 id="installing-dependencies">Installing Dependencies</h2>
<p>To build the simulations, you need:</p>
<ol>
<li>C++ Toolchain</li>
<li>Verilator</li>
<li>SDL</li>
</ol>
<p>The simulations should work on any modern platform, but I&rsquo;ve confined my instructions to Linux and macOS. Windows installation depends on your choice of compiler, but the sims should work fine there too. For advice on SDL development on Windows, see <a href="https://lazyfoo.net/tutorials/SDL/01_hello_SDL/windows/index.php">Lazy Foo' - Setting up SDL on Windows</a>.</p>
<h3 id="linux">Linux</h3>
<p>For Debian and Ubuntu-based distros, you can use the following. Other distros will be similar.</p>
<p>Install a C++ toolchain via &lsquo;build-essential&rsquo;:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">apt update
apt install build-essential
</code></pre></div><p>Install packages for Verilator and the dev version of SDL:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">apt update
apt install verilator libsdl2-dev
</code></pre></div><p>That&rsquo;s it!</p>
<p><em>If you want to build the latest version of Verilator yourself, see <a href="/posts/building-ice40-fpga-toolchain/#verilator">Building Verilator for Linux</a>.</em></p>
<h3 id="macos">macOS</h3>
<p>Install <a href="https://developer.apple.com/xcode/">Xcode</a> to get a C++ toolchain.</p>
<p>Install the <a href="https://brew.sh/">Homebrew</a> package manager.</p>
<p>With Homebrew installed, you can run:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">brew install verilator sdl2
</code></pre></div><p>And you&rsquo;re ready to go.</p>
<h2 id="working-with-verilator">Working with Verilator</h2>
<p>Verilator compiles your Verilog into a C++ model you can control using a simple interface. We&rsquo;ll use the first design from the <a href="/posts/fpga-graphics/">FPGA Graphics</a> tutorial series as a demo. If you&rsquo;re new to graphics on FPGA or ASIC, I strongly recommend reading the first part of the tutorial before continuing.</p>
<p>To create a simulation, you need a suitable Verilog top module and a C++ main function.</p>
<p>The square design from <em>FPGA Graphics</em>:</p>
<p><img src="/img/posts/verilog-sim-verilator-sdl/top-square.png" alt="A Square" title="Keeping it simple."></p>
<h3 id="verilator-top">Verilator Top</h3>
<p>Our Verilog design is very similar to that for FPGA dev boards: <a href="/posts/fpga-graphics/#icebreaker-dvi">iceBreaker top_square</a> and <a href="/posts/fpga-graphics/#arty-vga">Arty top_square</a>. The main difference is we skip PLL clock generation and output the screen position and data enable as well as the colours.</p>
<p>Our Verilator <strong>[<a href="https://github.com/projf/projf-explore/blob/master/graphics/fpga-graphics/verilator/top_square.sv">top_square.sv</a>]</strong> looks like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-verilog" data-lang="verilog"><span style="color:#66d9ef">module</span> top_square #(<span style="color:#66d9ef">parameter</span> CORDW<span style="color:#f92672">=</span><span style="color:#ae81ff">10</span>) (  <span style="color:#75715e">// coordinate width
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">input</span>  <span style="color:#66d9ef">wire</span> <span style="color:#66d9ef">logic</span> clk_pix,         <span style="color:#75715e">// pixel clock
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">input</span>  <span style="color:#66d9ef">wire</span> <span style="color:#66d9ef">logic</span> rst,             <span style="color:#75715e">// reset
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">output</span>      <span style="color:#66d9ef">logic</span> [CORDW<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] sx,  <span style="color:#75715e">// horizontal screen position
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">output</span>      <span style="color:#66d9ef">logic</span> [CORDW<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] sy,  <span style="color:#75715e">// vertical screen position
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">output</span>      <span style="color:#66d9ef">logic</span> de,              <span style="color:#75715e">// data enable (low in blanking interval)
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">output</span>      <span style="color:#66d9ef">logic</span> [<span style="color:#ae81ff">7</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] sdl_r,     <span style="color:#75715e">// 8-bit red
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">output</span>      <span style="color:#66d9ef">logic</span> [<span style="color:#ae81ff">7</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] sdl_g,     <span style="color:#75715e">// 8-bit green
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">output</span>      <span style="color:#66d9ef">logic</span> [<span style="color:#ae81ff">7</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] sdl_b      <span style="color:#75715e">// 8-bit blue
</span><span style="color:#75715e"></span>    );

    <span style="color:#75715e">// display timings
</span><span style="color:#75715e"></span>    simple_display_timings_480p display_timings_inst (
        .clk_pix,
        .rst,
        .sx,
        .sy,
        .hsync(),
        .vsync(),
        .de
    );

    <span style="color:#75715e">// 32 x 32 pixel square
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">logic</span> q_draw;
    <span style="color:#66d9ef">always_comb</span> q_draw <span style="color:#f92672">=</span> (sx <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">32</span> <span style="color:#f92672">&amp;&amp;</span> sy <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">32</span>) <span style="color:#f92672">?</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">:</span> <span style="color:#ae81ff">0</span>;

    <span style="color:#75715e">// SDL output
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">always_ff</span> @(<span style="color:#66d9ef">posedge</span> clk_pix) <span style="color:#66d9ef">begin</span>
        sdl_r <span style="color:#f92672">&lt;=</span> <span style="color:#f92672">!</span>de <span style="color:#f92672">?</span> <span style="color:#ae81ff">8&#39;h00</span> <span style="color:#f92672">:</span> (q_draw <span style="color:#f92672">?</span> <span style="color:#ae81ff">8&#39;hFF</span> <span style="color:#f92672">:</span> <span style="color:#ae81ff">8&#39;h00</span>);
        sdl_g <span style="color:#f92672">&lt;=</span> <span style="color:#f92672">!</span>de <span style="color:#f92672">?</span> <span style="color:#ae81ff">8&#39;h00</span> <span style="color:#f92672">:</span> (q_draw <span style="color:#f92672">?</span> <span style="color:#ae81ff">8&#39;h88</span> <span style="color:#f92672">:</span> <span style="color:#ae81ff">8&#39;h88</span>);
        sdl_b <span style="color:#f92672">&lt;=</span> <span style="color:#f92672">!</span>de <span style="color:#f92672">?</span> <span style="color:#ae81ff">8&#39;h00</span> <span style="color:#f92672">:</span> (q_draw <span style="color:#f92672">?</span> <span style="color:#ae81ff">8&#39;h00</span> <span style="color:#f92672">:</span> <span style="color:#ae81ff">8&#39;hFF</span>);
    <span style="color:#66d9ef">end</span>
<span style="color:#66d9ef">endmodule</span>
</code></pre></div><p>Our top module depends on one other module: <strong>[<a href="https://github.com/projf/projf-explore/blob/master/graphics/fpga-graphics/simple_display_timings_480p.sv">simple_display_timings_480p.sv</a>]</strong>; it&rsquo;s identical to that used with FPGAs. On real hardware, these timings produce a simple 640x480 output with a 60 Hz refresh rate. To understand how and why this works, read the first part of <a href="/posts/fpga-graphics/#space-and-time">FPGA Graphics</a>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-verilog" data-lang="verilog"><span style="color:#66d9ef">module</span> simple_display_timings_480p (
    <span style="color:#66d9ef">input</span>  <span style="color:#66d9ef">wire</span> <span style="color:#66d9ef">logic</span> clk_pix,   <span style="color:#75715e">// pixel clock
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">input</span>  <span style="color:#66d9ef">wire</span> <span style="color:#66d9ef">logic</span> rst,       <span style="color:#75715e">// reset
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">output</span>      <span style="color:#66d9ef">logic</span> [<span style="color:#ae81ff">9</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] sx,  <span style="color:#75715e">// horizontal screen position
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">output</span>      <span style="color:#66d9ef">logic</span> [<span style="color:#ae81ff">9</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] sy,  <span style="color:#75715e">// vertical screen position
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">output</span>      <span style="color:#66d9ef">logic</span> hsync,     <span style="color:#75715e">// horizontal sync
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">output</span>      <span style="color:#66d9ef">logic</span> vsync,     <span style="color:#75715e">// vertical sync
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">output</span>      <span style="color:#66d9ef">logic</span> de         <span style="color:#75715e">// data enable (low in blanking interval)
</span><span style="color:#75715e"></span>    );

    <span style="color:#75715e">// horizontal timings
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">parameter</span> HA_END <span style="color:#f92672">=</span> <span style="color:#ae81ff">639</span>;           <span style="color:#75715e">// end of active pixels
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">parameter</span> HS_STA <span style="color:#f92672">=</span> HA_END <span style="color:#f92672">+</span> <span style="color:#ae81ff">16</span>;   <span style="color:#75715e">// sync starts after front porch
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">parameter</span> HS_END <span style="color:#f92672">=</span> HS_STA <span style="color:#f92672">+</span> <span style="color:#ae81ff">96</span>;   <span style="color:#75715e">// sync ends
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">parameter</span> LINE   <span style="color:#f92672">=</span> <span style="color:#ae81ff">799</span>;           <span style="color:#75715e">// last pixel on line (after back porch)
</span><span style="color:#75715e"></span>
    <span style="color:#75715e">// vertical timings
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">parameter</span> VA_END <span style="color:#f92672">=</span> <span style="color:#ae81ff">479</span>;           <span style="color:#75715e">// end of active pixels
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">parameter</span> VS_STA <span style="color:#f92672">=</span> VA_END <span style="color:#f92672">+</span> <span style="color:#ae81ff">10</span>;   <span style="color:#75715e">// sync starts after front porch
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">parameter</span> VS_END <span style="color:#f92672">=</span> VS_STA <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>;    <span style="color:#75715e">// sync ends
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">parameter</span> SCREEN <span style="color:#f92672">=</span> <span style="color:#ae81ff">524</span>;           <span style="color:#75715e">// last line on screen (after back porch)
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">always_comb</span> <span style="color:#66d9ef">begin</span>
        hsync <span style="color:#f92672">=</span> <span style="color:#f92672">~</span>(sx <span style="color:#f92672">&gt;=</span> HS_STA <span style="color:#f92672">&amp;&amp;</span> sx <span style="color:#f92672">&lt;</span> HS_END);  <span style="color:#75715e">// invert: negative polarity
</span><span style="color:#75715e"></span>        vsync <span style="color:#f92672">=</span> <span style="color:#f92672">~</span>(sy <span style="color:#f92672">&gt;=</span> VS_STA <span style="color:#f92672">&amp;&amp;</span> sy <span style="color:#f92672">&lt;</span> VS_END);  <span style="color:#75715e">// invert: negative polarity
</span><span style="color:#75715e"></span>        de <span style="color:#f92672">=</span> (sx <span style="color:#f92672">&lt;=</span> HA_END <span style="color:#f92672">&amp;&amp;</span> sy <span style="color:#f92672">&lt;=</span> VA_END);
    <span style="color:#66d9ef">end</span>

    <span style="color:#75715e">// calculate horizontal and vertical screen position
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">always_ff</span> @(<span style="color:#66d9ef">posedge</span> clk_pix) <span style="color:#66d9ef">begin</span>
        <span style="color:#66d9ef">if</span> (sx <span style="color:#f92672">==</span> LINE) <span style="color:#66d9ef">begin</span>  <span style="color:#75715e">// last pixel on line?
</span><span style="color:#75715e"></span>            sx <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>;
            sy <span style="color:#f92672">&lt;=</span> (sy <span style="color:#f92672">==</span> SCREEN) <span style="color:#f92672">?</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">:</span> sy <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;  <span style="color:#75715e">// last line on screen?
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">end</span> <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">begin</span>
            sx <span style="color:#f92672">&lt;=</span> sx <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">end</span>
        <span style="color:#66d9ef">if</span> (rst) <span style="color:#66d9ef">begin</span>
            sx <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>;
            sy <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">end</span>
    <span style="color:#66d9ef">end</span>
<span style="color:#66d9ef">endmodule</span>
</code></pre></div><h3 id="c-interface--sdl">C++ Interface &amp; SDL</h3>
<p>To drive our simulation, we need a C++ main function. SDL has many ways to draw on the screen. I&rsquo;ve chosen a straightforward approach that should work for any graphics design. We write the Verilog video &ldquo;beam&rdquo; to an array of pixels. Once per frame, we convert the pixel array to an SDL texture and update our window.</p>
<p>I&rsquo;ll show the source file below, then discuss how it works. I&rsquo;m not a professional C++ developer, so don&rsquo;t be too horrified by my code. :)</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;SDL2/SDL.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;verilated.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;Vtop_square.h&#34;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// screen dimensions
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> H_RES <span style="color:#f92672">=</span> <span style="color:#ae81ff">640</span>;
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> V_RES <span style="color:#f92672">=</span> <span style="color:#ae81ff">480</span>;

<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Pixel</span> {  <span style="color:#75715e">// for SDL texture
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">uint8_t</span> a;  <span style="color:#75715e">// transparency
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">uint8_t</span> b;  <span style="color:#75715e">// blue
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">uint8_t</span> g;  <span style="color:#75715e">// green
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">uint8_t</span> r;  <span style="color:#75715e">// red
</span><span style="color:#75715e"></span>} Pixel;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> argv[]) {
    Verilated<span style="color:#f92672">::</span>commandArgs(argc, argv);

    <span style="color:#66d9ef">if</span>(SDL_Init(SDL_INIT_VIDEO) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
        printf(<span style="color:#e6db74">&#34;SDL init failed.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
    }

    Pixel screenbuffer[H_RES<span style="color:#f92672">*</span>V_RES];

    SDL_Window<span style="color:#f92672">*</span>   sdl_window   <span style="color:#f92672">=</span> NULL;
    SDL_Renderer<span style="color:#f92672">*</span> sdl_renderer <span style="color:#f92672">=</span> NULL;
    SDL_Texture<span style="color:#f92672">*</span>  sdl_texture  <span style="color:#f92672">=</span> NULL;

    sdl_window <span style="color:#f92672">=</span> SDL_CreateWindow(<span style="color:#e6db74">&#34;Top Square&#34;</span>, SDL_WINDOWPOS_CENTERED,
        SDL_WINDOWPOS_CENTERED, H_RES, V_RES, SDL_WINDOW_SHOWN);
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>sdl_window) {
        printf(<span style="color:#e6db74">&#34;Window creation failed: %s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, SDL_GetError());
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
    }

    sdl_renderer <span style="color:#f92672">=</span> SDL_CreateRenderer(sdl_window, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, SDL_RENDERER_ACCELERATED);
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>sdl_renderer) {
        printf(<span style="color:#e6db74">&#34;Renderer creation failed: %s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, SDL_GetError());
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
    }

    sdl_texture <span style="color:#f92672">=</span> SDL_CreateTexture(sdl_renderer, SDL_PIXELFORMAT_RGBA8888,
        SDL_TEXTUREACCESS_TARGET, H_RES, V_RES);
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>sdl_texture) {
        printf(<span style="color:#e6db74">&#34;Texture creation failed: %s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, SDL_GetError());
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
    }

    <span style="color:#75715e">// initialize Verilog module
</span><span style="color:#75715e"></span>    Vtop_square<span style="color:#f92672">*</span> top <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Vtop_square;

    top<span style="color:#f92672">-&gt;</span>rst <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    top<span style="color:#f92672">-&gt;</span>clk_pix <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    top<span style="color:#f92672">-&gt;</span>eval();
    top<span style="color:#f92672">-&gt;</span>rst <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    top<span style="color:#f92672">-&gt;</span>eval();

    <span style="color:#66d9ef">while</span> (<span style="color:#ae81ff">1</span>) {
        <span style="color:#75715e">// check for quit event
</span><span style="color:#75715e"></span>        SDL_Event e;
        <span style="color:#66d9ef">if</span> (SDL_PollEvent(<span style="color:#f92672">&amp;</span>e)) {
            <span style="color:#66d9ef">if</span> (e.type <span style="color:#f92672">==</span> SDL_QUIT) {
                <span style="color:#66d9ef">break</span>;
            }
        }

        <span style="color:#75715e">// cycle the clock
</span><span style="color:#75715e"></span>        top<span style="color:#f92672">-&gt;</span>clk_pix <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
        top<span style="color:#f92672">-&gt;</span>eval();
        top<span style="color:#f92672">-&gt;</span>clk_pix <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        top<span style="color:#f92672">-&gt;</span>eval();

        <span style="color:#75715e">// update pixel if not in blanking interval
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (top<span style="color:#f92672">-&gt;</span>de) {
            Pixel<span style="color:#f92672">*</span> p <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>screenbuffer[top<span style="color:#f92672">-&gt;</span>sy<span style="color:#f92672">*</span>H_RES <span style="color:#f92672">+</span> top<span style="color:#f92672">-&gt;</span>sx];
            p<span style="color:#f92672">-&gt;</span>a <span style="color:#f92672">=</span> <span style="color:#ae81ff">0xFF</span>;  <span style="color:#75715e">// transparency
</span><span style="color:#75715e"></span>            p<span style="color:#f92672">-&gt;</span>b <span style="color:#f92672">=</span> top<span style="color:#f92672">-&gt;</span>sdl_b;
            p<span style="color:#f92672">-&gt;</span>g <span style="color:#f92672">=</span> top<span style="color:#f92672">-&gt;</span>sdl_g;
            p<span style="color:#f92672">-&gt;</span>r <span style="color:#f92672">=</span> top<span style="color:#f92672">-&gt;</span>sdl_r;
        }

        <span style="color:#75715e">// update texture once per frame at start of blanking
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (top<span style="color:#f92672">-&gt;</span>sy <span style="color:#f92672">==</span> V_RES <span style="color:#f92672">&amp;&amp;</span> top<span style="color:#f92672">-&gt;</span>sx <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
            SDL_UpdateTexture(sdl_texture, NULL, screenbuffer, H_RES<span style="color:#f92672">*</span><span style="color:#66d9ef">sizeof</span>(Pixel));
            SDL_RenderClear(sdl_renderer);
            SDL_RenderCopy(sdl_renderer, sdl_texture, NULL, NULL);
            SDL_RenderPresent(sdl_renderer);
        }
    }

    top<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">final</span>();  <span style="color:#75715e">// simulation done
</span><span style="color:#75715e"></span>
    SDL_DestroyTexture(sdl_texture);
    SDL_DestroyRenderer(sdl_renderer);
    SDL_DestroyWindow(sdl_window);
    SDL_Quit();
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>I&rsquo;ll now go through the code step-by-step, explaining how it works. Remember, you can find all the source files in the <a href="https://github.com/projf/projf-explore/tree/master/graphics/fpga-graphics/verilator">projf-explore</a> repo. If you&rsquo;re eager to get it running right away, you can skip on to <a href="#building-and-running">Building &amp; Running</a>.</p>
<p>You might also like to read the official Verilator doc: <a href="https://verilator.org/guide/latest/connecting.html">Connecting to Verilated Models</a>.</p>
<h3 id="c-includes">C++ Includes</h3>
<p>There are four includes:</p>
<ol>
<li><code>#include &lt;stdio.h&gt;</code> - for <code>printf</code>; you can use <code>iostream</code> and <code>cout</code> if you prefer</li>
<li><code>#include &lt;SDL2/SDL.h&gt;</code> - SDL header</li>
<li><code>#include &lt;verilated.h&gt;</code> - common Verilator routines</li>
<li><code>#include &quot;Vtop_square.h&quot;</code> - generated by Verilator to match our Verilog top module</li>
</ol>
<p><em>NB. The name of the final include depends on the name of your top module.</em></p>
<h3 id="screen-size">Screen Size</h3>
<p>We need to define our screen size to match the display timings we&rsquo;ve used:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">// screen dimensions
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> H_RES <span style="color:#f92672">=</span> <span style="color:#ae81ff">640</span>;
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> V_RES <span style="color:#f92672">=</span> <span style="color:#ae81ff">480</span>;
</code></pre></div><h3 id="pixel-type">Pixel Type</h3>
<p>We write our colour values into a C++ array of pixels. We define a 32-bit Pixel type for convenience, with <code>a</code> representing transparency:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Pixel</span> {  <span style="color:#75715e">// for SDL texture
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">uint8_t</span> a;  <span style="color:#75715e">// transparency
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">uint8_t</span> b;  <span style="color:#75715e">// blue
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">uint8_t</span> g;  <span style="color:#75715e">// green
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">uint8_t</span> r;  <span style="color:#75715e">// red
</span><span style="color:#75715e"></span>} Pixel;
</code></pre></div><h3 id="sdl-initialization">SDL Initialization</h3>
<p>The next chunk of code creates the pixel array and three SDL objects: window, renderer, and texture.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">Pixel screenbuffer[H_RES<span style="color:#f92672">*</span>V_RES];

SDL_Window<span style="color:#f92672">*</span>   sdl_window   <span style="color:#f92672">=</span> NULL;
SDL_Renderer<span style="color:#f92672">*</span> sdl_renderer <span style="color:#f92672">=</span> NULL;
SDL_Texture<span style="color:#f92672">*</span>  sdl_texture  <span style="color:#f92672">=</span> NULL;
</code></pre></div><p>I&rsquo;ve not explain the SDL create call options in this post; read more about them on the SDL wiki:</p>
<ul>
<li><a href="https://wiki.libsdl.org/SDL_CreateWindow">SDL_CreateWindow</a></li>
<li><a href="https://wiki.libsdl.org/SDL_CreateRenderer">SDL_CreateRenderer</a></li>
<li><a href="https://wiki.libsdl.org/SDL_CreateTexture">SDL_CreateTexture</a></li>
</ul>
<h3 id="verilog-initialization">Verilog Initialization</h3>
<p>We create an instance of our Verilog module, then reset it:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">// initialize Verilog module
</span><span style="color:#75715e"></span>Vtop_square<span style="color:#f92672">*</span> top <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Vtop_square;

top<span style="color:#f92672">-&gt;</span>rst <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
top<span style="color:#f92672">-&gt;</span>clk_pix <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
top<span style="color:#f92672">-&gt;</span>eval();
top<span style="color:#f92672">-&gt;</span>rst <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
top<span style="color:#f92672">-&gt;</span>eval();
</code></pre></div><p>The model is run (evaluated) when you call <code>top-&gt;eval()</code>.</p>
<h3 id="main-loop">Main Loop</h3>
<p>Our simulation runs in the main loop, which has four parts.
First, we poll for a quit event, such as the user closing the window.
Then, we exit the while loop with <code>break</code> when a quit occurs.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">while</span> (<span style="color:#ae81ff">1</span>) {
    <span style="color:#75715e">// check for quit event
</span><span style="color:#75715e"></span>    SDL_Event e;
    <span style="color:#66d9ef">if</span> (SDL_PollEvent(<span style="color:#f92672">&amp;</span>e)) {
        <span style="color:#66d9ef">if</span> (e.type <span style="color:#f92672">==</span> SDL_QUIT) {
            <span style="color:#66d9ef">break</span>;
        }
    }
</code></pre></div><p>The pixel clock drives our hardware; we flip it to 1 and back to 0, evaluating our model each time:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">    <span style="color:#75715e">// cycle the clock
</span><span style="color:#75715e"></span>    top<span style="color:#f92672">-&gt;</span>clk_pix <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    top<span style="color:#f92672">-&gt;</span>eval();
    top<span style="color:#f92672">-&gt;</span>clk_pix <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    top<span style="color:#f92672">-&gt;</span>eval();
</code></pre></div><p>If we&rsquo;re in the active drawing part of the screen (i.e. not the blanking interval), we get a pointer to the current pixel then update its colour:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">    <span style="color:#75715e">// update pixel if not in blanking interval
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (top<span style="color:#f92672">-&gt;</span>de) {
        Pixel<span style="color:#f92672">*</span> p <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>screenbuffer[top<span style="color:#f92672">-&gt;</span>sy<span style="color:#f92672">*</span>H_RES <span style="color:#f92672">+</span> top<span style="color:#f92672">-&gt;</span>sx];
        p<span style="color:#f92672">-&gt;</span>a <span style="color:#f92672">=</span> <span style="color:#ae81ff">0xFF</span>;  <span style="color:#75715e">// transparency
</span><span style="color:#75715e"></span>        p<span style="color:#f92672">-&gt;</span>b <span style="color:#f92672">=</span> top<span style="color:#f92672">-&gt;</span>sdl_b;
        p<span style="color:#f92672">-&gt;</span>g <span style="color:#f92672">=</span> top<span style="color:#f92672">-&gt;</span>sdl_g;
        p<span style="color:#f92672">-&gt;</span>r <span style="color:#f92672">=</span> top<span style="color:#f92672">-&gt;</span>sdl_r;
    }
</code></pre></div><p>Once per frame, we convert the pixel array into an SDL texture and display it in the window:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">    <span style="color:#75715e">// update texture once per frame at start of blanking
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (top<span style="color:#f92672">-&gt;</span>sy <span style="color:#f92672">==</span> V_RES <span style="color:#f92672">&amp;&amp;</span> top<span style="color:#f92672">-&gt;</span>sx <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
        SDL_UpdateTexture(sdl_texture, NULL, screenbuffer, H_RES<span style="color:#f92672">*</span><span style="color:#66d9ef">sizeof</span>(Pixel));
        SDL_RenderClear(sdl_renderer);
        SDL_RenderCopy(sdl_renderer, sdl_texture, NULL, NULL);
        SDL_RenderPresent(sdl_renderer);
    }
}
</code></pre></div><p>The call to <a href="https://wiki.libsdl.org/SDL_UpdateTexture">SDL_UpdateTexture</a> is expensive, so we limit it to once per frame. Of course, you can update the texture after every pixel, but your simulation will run approximately 1000x slower!</p>
<h3 id="clean-up">Clean Up</h3>
<p>After breaking out of the <code>while</code> loop, we perform some clean up before quitting:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">    top<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">final</span>();  <span style="color:#75715e">// simulation done
</span><span style="color:#75715e"></span>
    SDL_DestroyTexture(sdl_texture);
    SDL_DestroyRenderer(sdl_renderer);
    SDL_DestroyWindow(sdl_window);
    SDL_Quit();
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h2 id="building-and-running">Building and Running</h2>
<p>Building and running Verilator simulations is pleasantly simple. We use <code>sdl2-config</code> to set the correct linker options for us.</p>
<p>To build and run the square simulation from the Project F repo:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">cd projf-explore/graphics/fpga-graphics/verilator
verilator -I../ -cc top_square.sv --exe main_square.cpp -LDFLAGS <span style="color:#e6db74">&#34;`sdl2-config --libs`&#34;</span>
make -C ./obj_dir -f Vtop_square.mk
./obj_dir/Vtop_square
</code></pre></div><p>When building your own designs, you may need to adjust the <code>-I</code> option that tells Verilator where to find included Verilog modules.</p>
<p>The simulation window looks like this on Linux (Pop!_OS 20.04):</p>
<p><img src="/img/posts/verilog-sim-verilator-sdl/top-square-verilator-sdl.png" alt="Simulating top square" title="Hip to be square!"></p>
<p>And the shell output looks like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ verilator -I../ -cc top_square.sv --exe main_square.cpp -LDFLAGS <span style="color:#e6db74">&#34;`sdl2-config --libs`&#34;</span>

$ make -C ./obj_dir -f Vtop_square.mk
make: Entering directory <span style="color:#e6db74">&#39;/home/flux/src/projf-explore/graphics/fpga-graphics/verilator/obj_dir&#39;</span>
ccache g++  -I.  -MMD -I/usr/local/share/verilator/include -I/usr/local/share/verilator/include/vltstd -DVM_COVERAGE<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span> -DVM_SC<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span> -DVM_TRACE<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span> -DVM_TRACE_FST<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span> -faligned-new -fcf-protection<span style="color:#f92672">=</span>none -Wno-bool-operation -Wno-sign-compare -Wno-uninitialized -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable -Wno-shadow      -std<span style="color:#f92672">=</span>gnu++14 -Os -c -o main_square.o ../main_square.cpp
ccache g++  -I.  -MMD -I/usr/local/share/verilator/include -I/usr/local/share/verilator/include/vltstd -DVM_COVERAGE<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span> -DVM_SC<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span> -DVM_TRACE<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span> -DVM_TRACE_FST<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span> -faligned-new -fcf-protection<span style="color:#f92672">=</span>none -Wno-bool-operation -Wno-sign-compare -Wno-uninitialized -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable -Wno-shadow      -std<span style="color:#f92672">=</span>gnu++14 -Os -c -o verilated.o /usr/local/share/verilator/include/verilated.cpp
/usr/bin/perl /usr/local/share/verilator/bin/verilator_includer -DVL_INCLUDE_OPT<span style="color:#f92672">=</span>include Vtop_square.cpp Vtop_square__Slow.cpp Vtop_square__Syms.cpp &gt; Vtop_square__ALL.cpp
ccache g++  -I.  -MMD -I/usr/local/share/verilator/include -I/usr/local/share/verilator/include/vltstd -DVM_COVERAGE<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span> -DVM_SC<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span> -DVM_TRACE<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span> -DVM_TRACE_FST<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span> -faligned-new -fcf-protection<span style="color:#f92672">=</span>none -Wno-bool-operation -Wno-sign-compare -Wno-uninitialized -Wno-unused-but-set-variable -Wno-unused-parameter -Wno-unused-variable -Wno-shadow      -std<span style="color:#f92672">=</span>gnu++14 -Os -c -o Vtop_square__ALL.o Vtop_square__ALL.cpp
Archive ar -rcs Vtop_square__ALL.a Vtop_square__ALL.o
g++    main_square.o verilated.o Vtop_square__ALL.a   -lSDL2    -o Vtop_square
make: Leaving directory <span style="color:#e6db74">&#39;/home/flux/src/projf-explore/graphics/fpga-graphics/verilator/obj_dir&#39;</span>

$ ./obj_dir/Vtop_square
</code></pre></div><h2 id="animation">Animation</h2>
<p>A static square is all very well, but what about animation? You&rsquo;ll be delighted to know the same C++ works; we tweak a couple of things to match the Verilog module name. To simulate the bouncing demo from <a href="/posts/fpga-graphics/#bounce">FPGA Graphics</a>, grab the Verilog and C++:</p>
<ul>
<li><a href="https://github.com/projf/projf-explore/blob/master/graphics/fpga-graphics/verilator/top_bounce.sv">top_bounce.sv</a></li>
<li><a href="https://github.com/projf/projf-explore/blob/master/graphics/fpga-graphics/verilator/main_bounce.cpp">main_bounce.cpp</a></li>
</ul>
<p>Then build and run it:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">cd projf-explore/graphics/fpga-graphics/verilator
verilator -I../ -cc top_bounce.sv --exe main_bounce.cpp -LDFLAGS <span style="color:#e6db74">&#34;`sdl2-config --libs`&#34;</span>
make -C ./obj_dir -f Vtop_bounce.mk
./obj_dir/Vtop_bounce
</code></pre></div><p>I&rsquo;ll be continuing to add additional Verilator simulations, including sprites and framebuffers, to the <a href="https://github.com/projf/projf-explore">Project F repo</a> over the summer.</p>
<h2 id="what-next">What Next?</h2>
<p>To learn more about Verilator, read the <a href="https://verilator.org/guide/latest/verilating.html">Verilating User Guide</a> and check out my guide to <a href="/posts/verilog-lint-with-verilator/">Verilog Lint with Verilator</a>. To learn more about SDL, consult the <a href="https://wiki.libsdl.org/FrontPage">SDL Wiki</a> and <a href="https://lazyfoo.net/tutorials/SDL/index.php">Lazy Foo' Productions</a>.</p>
<p>Find inspiration from these projects simulating graphics:</p>
<ul>
<li><a href="https://github.com/mattvenn/vga-clock">VGA Clock</a> by Matthew Venn - show the time on a 640x480 VGA display</li>
<li><a href="https://github.com/fredrequin/fpga_1943">FPGA 1943: The Battle of Midway</a> by Frederic Requin - re-implements the <a href="https://en.wikipedia.org/wiki/1943:_The_Battle_of_Midway">CAPCOM classic</a></li>
<li><a href="https://github.com/sylefeb/Silice/tree/draft/frameworks/verilator">Silice Simulation Framework</a> by Sylvain Lefebvre (on draft git branch at present)</li>
<li><a href="https://tomverbeure.github.io/2020/08/08/CXXRTL-the-New-Yosys-Simulation-Backend.html">CXXRTL, a Yosys Simulation Backend</a> by Tom Verbeure - an alternative to Verilator
<ul>
<li>Using CXXRTL for graphic simulation by <a href="https://twitter.com/kbeckmann/status/1271541477999607810?s=20">Konrad Beckmann</a> (Twitter)</li>
</ul>
</li>
</ul>
<p><em>Constructive feedback is always welcome. Get in touch with <a href="https://twitter.com/WillFlux">@WillFlux</a> or open an <a href="https://github.com/projf/projf-explore/issues">issue on GitHub</a>.</em></p>

      
      <div class="related">

<h3>Similar articles:</h3>
<ul>
	
	<li><a href="/posts/verilog-lint-with-verilator/">Verilog Lint with Verilator</a></li>
	
	<li><a href="/posts/building-ice40-fpga-toolchain/">Building iCE40 FPGA Toolchain on Linux</a></li>
	
	<li><a href="/posts/fpga-dev-ubuntu-20.04/">FPGA Tooling on Ubuntu 20.04</a></li>
	
</ul>
</div>
      
    </div>
    
  </div>
</section>

    <script src="/js/copycode.js"></script>



<section class="section">
  <div class="container has-text-centered">
    <p>2021 Will Green, Project F</p>
    
  </div>
</section>


<script src="https://narwhal.projectf.io/script.js" site="EVCGKVDN" defer></script>
</body>
</html>

