<!doctype html><html class="not-ready lg:text-base" style=--bg:#fff lang=en-gb><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>RISC-V Assembler: Jump and Function - Project F</title>
<meta name=theme-color><meta name=description content="This RISC-V assembler post begins by examining the RISC-V jump instructions: jal and jalr. Jump instructions are the basis of functions, so we&rsquo;ll then dig into function calls, the RISC-V ABI, calling convention, and how to use the stack."><meta name=author content="Will Green"><link rel="preload stylesheet" as=style href=https://projectf.io/main.min.css><link rel=preload as=image href=https://projectf.io/theme.png><link rel=preload as=image href=https://projectf.io/rss.svg><script defer src=https://projectf.io/highlight.min.js onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://projectf.io/favicon.ico><link rel=apple-touch-icon href=https://projectf.io/apple-touch-icon.png><meta name=generator content="Hugo 0.128.2"><script src=https://cdn-eu.usefathom.com/script.js data-site=EVCGKVDN defer></script><meta itemprop=name content="RISC-V Assembler: Jump and Function"><meta itemprop=description content="This RISC-V assembler post begins by examining the RISC-V jump instructions: jal and jalr. Jump instructions are the basis of functions, so we’ll then dig into function calls, the RISC-V ABI, calling convention, and how to use the stack."><meta itemprop=datePublished content="2024-04-30T00:00:00+00:00"><meta itemprop=dateModified content="2024-10-04T00:00:00+00:00"><meta itemprop=wordCount content="2438"><meta itemprop=image content="https://projectf.io/posts/riscv-jump-function/img/social/riscv-jump-function.jpeg"><meta itemprop=keywords content="Asm,Riscv"><meta property="og:url" content="https://projectf.io/posts/riscv-jump-function/"><meta property="og:site_name" content="Project F"><meta property="og:title" content="RISC-V Assembler: Jump and Function"><meta property="og:description" content="This RISC-V assembler post begins by examining the RISC-V jump instructions: jal and jalr. Jump instructions are the basis of functions, so we’ll then dig into function calls, the RISC-V ABI, calling convention, and how to use the stack."><meta property="og:locale" content="en_gb"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-04-30T00:00:00+00:00"><meta property="article:modified_time" content="2024-10-04T00:00:00+00:00"><meta property="article:tag" content="Asm"><meta property="article:tag" content="Riscv"><meta property="og:image" content="https://projectf.io/posts/riscv-jump-function/img/social/riscv-jump-function.jpeg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://projectf.io/posts/riscv-jump-function/img/social/riscv-jump-function.jpeg"><meta name=twitter:title content="RISC-V Assembler: Jump and Function"><meta name=twitter:description content="This RISC-V assembler post begins by examining the RISC-V jump instructions: jal and jalr. Jump instructions are the basis of functions, so we’ll then dig into function calls, the RISC-V ABI, calling convention, and how to use the stack."><link rel=canonical href=https://projectf.io/posts/riscv-jump-function/></head><body class="text-black duration-200 ease-out dark:text-white"><header class="mx-auto flex h-[4.5rem] max-w-4xl px-8 lg:justify-center"><div class="relative z-50 mr-auto flex items-center"><a class="-translate-x-[1px] -translate-y-[1px] text-2xl font-semibold" href=https://projectf.io/>Project F</a><div class="btn-dark text-[0] ml-4 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.png)_left_center/_auto_theme('spacing.6')_no-repeat] [transition:_background-position_0.4s_steps(5)] dark:[background-position:right]" role=button aria-label=Dark></div></div><div class="btn-menu relative z-50 -mr-8 flex h-[4.5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden" role=button aria-label=Menu></div><script>const htmlClass=document.documentElement.classList;setTimeout(()=>{htmlClass.remove("not-ready")},10);const btnMenu=document.querySelector(".btn-menu");btnMenu.addEventListener("click",()=>{htmlClass.toggle("open")});const metaTheme=document.querySelector('meta[name="theme-color"]'),lightBg="#fff".replace(/"/g,""),setDark=e=>{metaTheme.setAttribute("content",e?"#000":lightBg),htmlClass[e?"add":"remove"]("dark"),localStorage.setItem("dark",e)},darkScheme=window.matchMedia("(prefers-color-scheme: dark)");if(htmlClass.contains("dark"))setDark(!0);else{const e=localStorage.getItem("dark");setDark(e?e==="true":darkScheme.matches)}darkScheme.addEventListener("change",e=>{setDark(e.matches)});const btnDark=document.querySelector(".btn-dark");btnDark.addEventListener("click",()=>{setDark(localStorage.getItem("dark")!=="true")})</script><div class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full select-none flex-col justify-center pb-16 duration-200 dark:bg-black lg:static lg:h-auto lg:flex-row lg:!bg-transparent lg:pb-0 lg:transition-none"><nav class="lg:ml-12 lg:flex lg:flex-row lg:items-center lg:space-x-6"><a class="block text-center text-2xl leading-[5rem] lg:text-base lg:font-normal" href=/about/>About</a>
<a class="block text-center text-2xl leading-[5rem] lg:text-base lg:font-normal" href=/demos/>Demos</a>
<a class="block text-center text-2xl leading-[5rem] lg:text-base lg:font-normal" href=/verilog-lib/>Lib</a>
<a class="block text-center text-2xl leading-[5rem] lg:text-base lg:font-normal" href=/tools/>Tools</a>
<a class="block text-center text-2xl leading-[5rem] lg:text-base lg:font-normal" href=/tutorials/>Tutorials</a></nav><nav class="mt-12 flex justify-center space-x-10 dark:invert lg:ml-12 lg:mt-0 lg:items-center lg:space-x-6"><a class="h-8 w-8 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./rss.svg) href=https://projectf.io/index.xml target=_blank rel=alternate>rss</a></nav></div></header><main class="prose prose-neutral relative mx-auto min-h-[calc(100%-9rem)] max-w-4xl px-8 pb-4 pt-4 dark:prose-invert"><article><header class=mb-4><h1 class="!my-0 pb-2.5">RISC-V Assembler: Jump and Function</h1><div class="text-sm antialiased opacity-60">Published
<time>30 Apr 2024</time>
<span class=mx-1>&#183;</span>
<span>Updated
<time>04 Oct 2024</time></span></div></header><section><p>This RISC-V assembler post begins by examining the RISC-V jump instructions: <strong>jal</strong> and <strong>jalr</strong>. Jump instructions are the basis of functions, so we&rsquo;ll then dig into function calls, the RISC-V ABI, calling convention, and how to use the stack. Jump instructions are included in RV32I, the base integer instruction set.</p><p>In the last few years, we&rsquo;ve seen an explosion of RISC-V CPU designs on FPGA and ASIC, including the RP2350 found on the Raspberry Pi Pico 2. Thankfully, RISC-V is ideal for assembly programming with its compact, easy-to-learn instruction set. This series will help you learn and understand 32-bit RISC-V instructions and programming.</p><p><strong>RISC-V Assembler</strong>: <a href=/posts/riscv-arithmetic/>Arithmetic</a> | <a href=/posts/riscv-logical/>Logical</a> | <a href=/posts/riscv-shift/>Shift</a> | <a href=/posts/riscv-load-store/>Load and Store</a> | <a href=/posts/riscv-branch-set/>Branch and Set</a> | <a href=/posts/riscv-jump-function/>Jump and Function</a> | <a href=/posts/riscv-multiply-divide/>Multiply and Divide</a> | <a href=/posts/riscv-compiler-explorer/>Compiler Explorer</a> | <a href=/posts/riscv-cheat-sheet/>Assembler Cheat Sheet</a></p><h2 id=jump>Jump</h2><p>The main operation of the jump instructions is to update the program counter (<strong>PC</strong>).</p><p>The <strong>PC</strong> keeps track of the CPU&rsquo;s location in the code. Usually, the CPU adds 4 to the PC when executing an instruction, as each instruction is 4 bytes long. However, with a jump instruction, the CPU updates the <strong>PC</strong> to point at the jump target instead.</p><p>The jump instructions are <strong>unconditional</strong>. For conditional jumps, see my post on <a href=/posts/riscv-branch-set/>branching</a>.</p><h2 id=just-the-two-of-us>Just the Two of Us</h2><p>At one level, this post is about two instructions: <strong>jal</strong> (jump and link) and <strong>jalr</strong> (jump and link register). But these two instructions are exciting because they enable functions (also known as subroutines or procedure calls).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>jal</span>  <span style=color:#66d9ef>rd</span>, <span style=color:#66d9ef>imm</span>       <span style=color:#75715e># rd = pc+4; pc += imm
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>jalr</span> <span style=color:#66d9ef>rd</span>, <span style=color:#66d9ef>rs1</span>, <span style=color:#66d9ef>imm</span>  <span style=color:#75715e># rd = pc+4; pc = rs1+imm
</span></span></span></code></pre></div><p>Before updating the <strong>PC</strong>, a jump instruction writes the address of the following instruction into a register. By saving this <strong>return address</strong>, we can return to it and continue execution where we left off.</p><p><strong>jal</strong> uses a 20-bit signed immediate for the jump destination, while <strong>jalr</strong> uses a register plus 12-bit signed offset in a similar way to the <a href=/posts/riscv-load-store/>load and store</a> instructions.</p><p><strong>jal</strong> range is <code>±1MiB</code> in units of two bytes for greater range with compressed instruction support.</p><p><strong>jalr</strong> range is <code>±2KiB</code>, but you can combine <strong>jalr</strong> with <a href=/posts/riscv-arithmetic/#load-upper-immediate>lui</a> or <a href=/posts/riscv-branch-set/#auipc>auipc</a> to reach any 32-bit address.</p><h2 id=jump-1>Jump!</h2><p>Before we tackle functions (subroutines), let&rsquo;s consider a plain old jump:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>j</span> <span style=color:#66d9ef>imm</span>  <span style=color:#75715e># pc += imm
</span></span></span></code></pre></div><p>For example, use <strong>j</strong> in an infinite loop:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span>.L_forever:
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>la</span>  <span style=color:#66d9ef>a0</span>, <span style=color:#66d9ef>message</span>  <span style=color:#75715e># load address of message
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>call</span> <span style=color:#66d9ef>printstr</span>    <span style=color:#75715e># call a function (discussed below)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>j</span> <span style=color:#66d9ef>.L_forever</span>     <span style=color:#75715e># jump to .L_forever label
</span></span></span></code></pre></div><p>You could also use the <strong>j</strong> instruction in case/switch code.</p><p>The assembler translates <strong>j</strong> into <strong>jal</strong> with the return address register set to <strong>zero</strong> (<strong>x0</strong>).</p><p>Use <strong>j</strong> for your unconditional jumps in preference to branches. Jumps make your intent clear, have greater range, and avoid branch prediction.</p><h2 id=functions>Functions</h2><p>To call a function, we must jump to a new address while remembering where we came from. The <strong>jal</strong> instruction can do this. We need to choose where to save the return address. By convention, this is the <strong>x1</strong> register, known in the ABI as the return address register or <strong>ra</strong>.</p><p>The use of <strong>ra</strong> for the return address is part of the standard <strong>RISC-V ABI</strong> (application binary interface). The ABI ensures programs written by different programmers and with different tools can interoperate. For example, the ABI allows a program written in C to call a function written in assembler.</p><p>How do we get back once we&rsquo;ve finished executing our function? We have the return address in <strong>ra</strong>, so <strong>jalr</strong> (jump and link <em>register</em>) can take us back.</p><p>Let&rsquo;s take a look at a trivial example, calling a function that adds two integers:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>li</span>  <span style=color:#66d9ef>a0</span>, <span style=color:#ae81ff>7</span>  <span style=color:#75715e># 1st argument in a0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>li</span>  <span style=color:#66d9ef>a1</span>, <span style=color:#ae81ff>8</span>  <span style=color:#75715e># 2nd argument in a1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>jal</span> <span style=color:#66d9ef>ra</span>, <span style=color:#66d9ef>add_int</span>  <span style=color:#75715e># save address in register ra (x1) and jump to label add_int
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ebreak</span>  <span style=color:#75715e># stop execution
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>add_int:
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>add</span>  <span style=color:#66d9ef>a0</span>, <span style=color:#66d9ef>a0</span>, <span style=color:#66d9ef>a1</span>   <span style=color:#75715e># a0 = a0 + a1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>jalr</span> <span style=color:#66d9ef>zero</span>, <span style=color:#ae81ff>0</span>(<span style=color:#66d9ef>ra</span>)  <span style=color:#75715e># jump to address in register ra with 0 offset
</span></span></span></code></pre></div><p>Does this seem unnecessarily fiddly? If we always use the <strong>ra</strong> register for the return address, why do we need to provide it? Plus, it&rsquo;s not immediately obvious what the purpose of these jump instructions is.</p><p>Pseudoinstructions <strong>call</strong> and <strong>ret</strong> to the rescue!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>call</span> <span style=color:#66d9ef>label</span>  <span style=color:#75715e># call function at &#39;label&#39;, saving return address in ra
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>ret</span>         <span style=color:#75715e># return from function using address in ra
</span></span></span></code></pre></div><p>This makes for simpler and clearer code:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>li</span> <span style=color:#66d9ef>a0</span>, <span style=color:#ae81ff>7</span>  <span style=color:#75715e># 1st argument in a0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>li</span> <span style=color:#66d9ef>a1</span>, <span style=color:#ae81ff>8</span>  <span style=color:#75715e># 2nd argument in a1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>call</span> <span style=color:#66d9ef>add_int</span>  <span style=color:#75715e># call function
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ebreak</span>  <span style=color:#75715e># stop execution
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>add_int:
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>add</span>  <span style=color:#66d9ef>a0</span>, <span style=color:#66d9ef>a0</span>, <span style=color:#66d9ef>a1</span>  <span style=color:#75715e># a0 = a0 + a1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>ret</span>  <span style=color:#75715e># return from function
</span></span></span></code></pre></div><h3 id=far-calls>Far Calls</h3><p>In the above example we used <strong>jal</strong> to call our function, but it&rsquo;s limited to <code>±1MiB</code> relative to the PC. For far calls we can combine <strong>jalr</strong> with <a href=/posts/riscv-branch-set#auipc>auipc</a> to reach anywhere in 32-bit memory space. Use the <strong>call</strong> pseudoinstruction and the assembler will choose the correct instruction(s) for you.</p><h2 id=in-and-out>In and Out</h2><p>Most functions take arguments and return something: this is where the <strong>a0-a7</strong> registers come in.</p><p>Before calling a function, you put the first argument in <strong>a0</strong>, the 2nd argument in <strong>a1</strong>, etc. When it comes time to return our result, we put it in <strong>a0</strong>. Just like the convention of using <strong>ra</strong> for the return address, this ensures different code can easily work together.</p><p>We have already seen an example of arguments and return values with <code>add_int</code> (above).</p><h2 id=functions-calling-functions>Functions Calling Functions</h2><p>Functions that don&rsquo;t call other functions are known as <strong>leaf functions</strong>. After a leaf function executes it uses the return address in <strong>ra</strong> to return.</p><p>However, functions can easily call other functions and it&rsquo;s here things get interesting. When we call a function, the <strong>call</strong> instruction writes the return address into <strong>ra</strong>, overwriting the previous return address!</p><p>A function that calls a function <strong>must</strong> save its own return address before making the function call. We save the existing value of <strong>ra</strong> on the <strong>stack</strong>.</p><h2 id=stack>Stack</h2><p>The stack is an area of memory set aside for use by functions and local variables (not discussed here).</p><p>The <strong>stack pointer (sp)</strong> points to the bottom of the stack, which grows <strong>downwards</strong> to lower addresses. When the CPU is reset, the stack pointer is typically set to the very top of memory.</p><p>We allocate memory on the stack by decrementing the stack pointer <strong>sp</strong>. We can then save registers onto the stack using the <strong>sw</strong> (store word) instruction. See <a href=/posts/riscv-load-store/>Load Store</a> for coverage of RISC-V memory instructions.</p><p>For example, function <code>fun_one</code> calls function <code>fun_two</code>, so it must save its return address on the stack:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span>fun_one:
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>addi</span> <span style=color:#66d9ef>sp</span>, <span style=color:#66d9ef>sp</span>, -<span style=color:#ae81ff>16</span>  <span style=color:#75715e># allocate 16 bytes on stack
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>sw</span>   <span style=color:#66d9ef>ra</span>, <span style=color:#ae81ff>12</span>(<span style=color:#66d9ef>sp</span>)   <span style=color:#75715e># store return address on stack
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># do some fun stuff
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>call</span> <span style=color:#66d9ef>fun_two</span>  <span style=color:#75715e># call another function
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># do some more fun stuff
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>lw</span>   <span style=color:#66d9ef>ra</span>, <span style=color:#ae81ff>12</span>(<span style=color:#66d9ef>sp</span>)  <span style=color:#75715e># load return address from stack
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>addi</span> <span style=color:#66d9ef>sp</span>, <span style=color:#66d9ef>sp</span>, <span style=color:#ae81ff>16</span>  <span style=color:#75715e># restore stack pointer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ret</span>  <span style=color:#75715e># return from fun_one
</span></span></span></code></pre></div><p>Note how we store and then later load the return address from the same offset (<code>12</code>) to the stack pointer.</p><h3 id=stack-alignment>Stack Alignment</h3><p>Why did we allocate 16 bytes on the stack when our return address is only 4 bytes long?</p><p>The RISC-V calling convention says:</p><blockquote><p>The stack grows downwards (towards lower addresses) and the stack pointer shall be aligned to a 128-bit boundary upon procedure entry.</p></blockquote><p>This is another example of the ABI ensuring interoperability. We ensure all data types are correctly aligned by aligning the stack pointer to 16 bytes.</p><h2 id=ignorance-is-bliss>Ignorance is Bliss</h2><p>A function doesn&rsquo;t know what happened before it was called or what will happen after it returns. A function caller doesn&rsquo;t know what happens inside a function, just what it passes in and gets returned. A well-written function is an example of a <a href=https://en.wikipedia.org/wiki/Black_box>black box</a>.</p><p>RISC-V gives us 32 general-purpose registers, but if every function used them indiscriminately, they&rsquo;d overwrite each other&rsquo;s data. We can solve this problem by pushing existing registers onto the stack before calling the function and popping them off the stack after the function returns. However, pushing registers onto the stack makes functions slower. A simple function could spend more CPU cycles pushing and popping register from the stack than doing useful work.</p><p>The RISC-V ABI lets us have fast functions while preserving <em>some</em> register values.</p><p>There are three main categories of general-purpose registers:</p><ul><li><strong>saved registers: s0-s11</strong> - keep their value across function calls (<strong>preserved</strong>)</li><li><strong>argument registers: a0-a7</strong> - for passing arguments and the return value (<strong>not preserved</strong>)</li><li><strong>temporary registers: t0-t6</strong> - for internal function use (<strong>not preserved</strong>)</li></ul><p>Understanding how to handle preserved and non-preserved registers is critical to writing RISC-V assembler. I&rsquo;d go so far as to say its the most important skill beyond a basic knowledge of the instructions. Getting it right results in fast, elegant code. Getting it wrong leads to subtle bugs and much frustration. A good start is to always use ABI names for registers, otherwise it&rsquo;s really difficult to remember which registers you need to save!</p><ul><li>A function using a <strong>preserved register</strong> must restore its original value before returning.</li><li>A function using a <strong>non-preserved register</strong> must assume it&rsquo;s changed by a function call.</li></ul><p>Let&rsquo;s look at both cases in a little more detail.</p><h3 id=preserved-registers>Preserved Registers</h3><p>Preserved registers <strong>must</strong> be restored to their original value before returning from a function call. If your function uses preserved registers, such as <strong>s0-s11</strong>, save them on the stack before using them.</p><p>For example, <code>fun_foo</code> uses <strong>s1-s4</strong>, it saves them on the stack like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span>fun_foo:
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>addi</span> <span style=color:#66d9ef>sp</span>, <span style=color:#66d9ef>sp</span>, -<span style=color:#ae81ff>16</span>  <span style=color:#75715e># allocate space on stack
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>sw</span>   <span style=color:#66d9ef>s1</span>, <span style=color:#ae81ff>12</span>(<span style=color:#66d9ef>sp</span>)   <span style=color:#75715e># store saved registers on stack
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>sw</span>   <span style=color:#66d9ef>s2</span>,  <span style=color:#ae81ff>8</span>(<span style=color:#66d9ef>sp</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>sw</span>   <span style=color:#66d9ef>s3</span>,  <span style=color:#ae81ff>4</span>(<span style=color:#66d9ef>sp</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>sw</span>   <span style=color:#66d9ef>s4</span>,  <span style=color:#ae81ff>0</span>(<span style=color:#66d9ef>sp</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># we&#39;re now free to use s1-s4
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e># implement incredible algorithm here
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>lw</span>   <span style=color:#66d9ef>s1</span>, <span style=color:#ae81ff>12</span>(<span style=color:#66d9ef>sp</span>)  <span style=color:#75715e># restore saved registers from stack
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>lw</span>   <span style=color:#66d9ef>s2</span>,  <span style=color:#ae81ff>8</span>(<span style=color:#66d9ef>sp</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>lw</span>   <span style=color:#66d9ef>s3</span>,  <span style=color:#ae81ff>4</span>(<span style=color:#66d9ef>sp</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>lw</span>   <span style=color:#66d9ef>s4</span>,  <span style=color:#ae81ff>0</span>(<span style=color:#66d9ef>sp</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>addi</span> <span style=color:#66d9ef>sp</span>, <span style=color:#66d9ef>sp</span>, <span style=color:#ae81ff>16</span>  <span style=color:#75715e># restore stack pointer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>ret</span>
</span></span></code></pre></div><h3 id=other-registers>Other Registers</h3><p>With non-preserved registers, you can do what you want, but so can other functions. After you call another function, you must assume the values of the <strong>a</strong> and <strong>t</strong> registers have changed.</p><p>For example, I&rsquo;ve written a function to initialize my graphics display. The background colour is passed to <code>gfx_setup</code> in <strong>a0</strong>. However, before I set the background colour I need to call <code>frame_wait</code>.</p><p>The <code>frame_wait</code> function could overwrite <strong>a0</strong>, so I preserve it on the stack. Of course, I also need to save <strong>ra</strong> on the stack before calling another function, leading to this design:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span>gfx_setup:
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>addi</span> <span style=color:#66d9ef>sp</span>, <span style=color:#66d9ef>sp</span>, -<span style=color:#ae81ff>16</span>  <span style=color:#75715e># allocate space on stack
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>sw</span>   <span style=color:#66d9ef>ra</span>, <span style=color:#ae81ff>12</span>(<span style=color:#66d9ef>sp</span>)   <span style=color:#75715e># save return address onto stack
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>sw</span>   <span style=color:#66d9ef>a0</span>,  <span style=color:#ae81ff>8</span>(<span style=color:#66d9ef>sp</span>)   <span style=color:#75715e># save a0 (background colour)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>call</span> <span style=color:#66d9ef>frame_wait</span>  <span style=color:#75715e># wait for blanking before graphics setup
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>li</span> <span style=color:#66d9ef>t6</span>, <span style=color:#66d9ef>GFX_HWREG</span>  <span style=color:#75715e># graphics engine address
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># background colour
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>lw</span> <span style=color:#66d9ef>a0</span>, <span style=color:#ae81ff>8</span>(<span style=color:#66d9ef>sp</span>)  <span style=color:#75715e># load background colour (a0) from stack
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>sw</span> <span style=color:#66d9ef>a0</span>, <span style=color:#66d9ef>DISP_BGRD</span>(<span style=color:#66d9ef>t6</span>)  <span style=color:#75715e># set background colour
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># other graphics setup here...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>lw</span>   <span style=color:#66d9ef>ra</span>, <span style=color:#ae81ff>12</span>(<span style=color:#66d9ef>sp</span>)  <span style=color:#75715e># load return address from stack
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>addi</span> <span style=color:#66d9ef>sp</span>, <span style=color:#66d9ef>sp</span>, <span style=color:#ae81ff>16</span>  <span style=color:#75715e># restore stack pointer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>ret</span>
</span></span></code></pre></div><p>Functions that don&rsquo;t call other functions (leaf functions), don&rsquo;t have to worry about non-preserved registers changing. When writing leaf functions, stick to <strong>t</strong> and <strong>a</strong> registers, then you don&rsquo;t have to save anything to the stack: simple and fast.</p><h2 id=many-arguments>Many Arguments</h2><p>In the rare event your function needs more than eight arguments, you can pass them on the stack.</p><p>The RISC-V calling convention says:</p><blockquote><p>The first argument passed on the stack is located at offset zero of the stack pointer on function entry; following arguments are stored at correspondingly higher addresses.</p></blockquote><p>For example, a function with 10 arguments receives the first eight arguments in <strong>a0-a7</strong> and could handle the remaining arguments like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span>fun_ten:
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>lw</span> <span style=color:#66d9ef>t0</span>, <span style=color:#ae81ff>0</span>(<span style=color:#66d9ef>sp</span>)  <span style=color:#75715e># load 9th argument off stack into t0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>lw</span> <span style=color:#66d9ef>t1</span>, <span style=color:#ae81ff>4</span>(<span style=color:#66d9ef>sp</span>)  <span style=color:#75715e># load 10th argument off stack into t1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># the first 8 arguments are in a0-a7
</span></span></span></code></pre></div><p><em>NB. We use an offset of 4 for the 10th argument because we&rsquo;re loading a word (four bytes).</em></p><h2 id=64-bit-variables>64-bit Variables</h2><p>RV32 is a 32-bit architecture, but sometimes you need to work with 64-bit values, such as file offsets or UNIX time. In this case, you can combine pairs of registers, such as <strong>a0</strong> and <strong>a1</strong>.</p><p>The following function performs 64-bit subtraction, including handling the carry bit:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#75715e># 64-bit integer subtraction
</span></span></span><span style=display:flex><span><span style=color:#75715e>#   arguments:
</span></span></span><span style=display:flex><span><span style=color:#75715e>#       a0: x lower 32 bits
</span></span></span><span style=display:flex><span><span style=color:#75715e>#       a1: x upper 32 bits
</span></span></span><span style=display:flex><span><span style=color:#75715e>#       a2: y lower 32 bits
</span></span></span><span style=display:flex><span><span style=color:#75715e>#       a3: y upper 32 bits
</span></span></span><span style=display:flex><span><span style=color:#75715e>#   return:
</span></span></span><span style=display:flex><span><span style=color:#75715e>#       a0: x-y lower 32 bits
</span></span></span><span style=display:flex><span><span style=color:#75715e>#       a1: x-y upper 32 bits
</span></span></span><span style=display:flex><span><span style=color:#75715e>#
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>sub64:
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>sltu</span>    <span style=color:#66d9ef>t0</span>, <span style=color:#66d9ef>a0</span>, <span style=color:#66d9ef>a2</span>  <span style=color:#75715e># if a0 &lt; a2 then set t1=1 (carry bit)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>sub</span>     <span style=color:#66d9ef>a1</span>, <span style=color:#66d9ef>a1</span>, <span style=color:#66d9ef>a3</span>  <span style=color:#75715e># sub upper 32 bits
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>sub</span>     <span style=color:#66d9ef>a1</span>, <span style=color:#66d9ef>a1</span>, <span style=color:#66d9ef>t0</span>  <span style=color:#75715e># sub carry bit from upper 32 bits of answer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>sub</span>     <span style=color:#66d9ef>a0</span>, <span style=color:#66d9ef>a0</span>, <span style=color:#66d9ef>a2</span>  <span style=color:#75715e># sub lower 32 bits
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>ret</span>
</span></span></code></pre></div><p>Learn more about <a href=/posts/riscv-branch-set/#multi-word-addition>multi-word addition</a> with set instructions.</p><h2 id=rv32-abi-registers>RV32 ABI Registers</h2><p>Let&rsquo;s finish by taking a look at all 32 ABI registers.</p><table><thead><tr><th>ABI Name</th><th>Register</th><th>Description</th><th>Preserved</th></tr></thead><tbody><tr><td><strong>zero</strong></td><td>x0</td><td>always 0 (zero)</td><td>n/a</td></tr><tr><td><strong>ra</strong></td><td>x1</td><td>return address</td><td>no</td></tr><tr><td><strong>sp</strong></td><td>x2</td><td>stack pointer</td><td>yes</td></tr><tr><td><strong>gp</strong></td><td>x3</td><td>global pointer*</td><td>n/a</td></tr><tr><td><strong>tp</strong></td><td>x4</td><td>thread pointer*</td><td>n/a</td></tr><tr><td><strong>t0</strong></td><td>x5</td><td>temporary</td><td>no</td></tr><tr><td><strong>t1</strong></td><td>x6</td><td>temporary</td><td>no</td></tr><tr><td><strong>t2</strong></td><td>x7</td><td>temporary</td><td>no</td></tr><tr><td><strong>fp (s0)</strong></td><td>x8</td><td>frame pointer†</td><td>yes</td></tr><tr><td><strong>s1</strong></td><td>x9</td><td>saved register</td><td>yes</td></tr><tr><td><strong>a0</strong></td><td>x10</td><td>function argument‡</td><td>no</td></tr><tr><td><strong>a1</strong></td><td>x11</td><td>function argument‡</td><td>no</td></tr><tr><td><strong>a2</strong></td><td>x12</td><td>function argument</td><td>no</td></tr><tr><td><strong>a3</strong></td><td>x13</td><td>function argument</td><td>no</td></tr><tr><td><strong>a4</strong></td><td>x14</td><td>function argument</td><td>no</td></tr><tr><td><strong>a5</strong></td><td>x15</td><td>function argument</td><td>no</td></tr><tr><td><strong>a6</strong></td><td>x16</td><td>function argument</td><td>no</td></tr><tr><td><strong>a7</strong></td><td>x17</td><td>function argument</td><td>no</td></tr><tr><td><strong>s2</strong></td><td>x18</td><td>saved register</td><td>yes</td></tr><tr><td><strong>s3</strong></td><td>x19</td><td>saved register</td><td>yes</td></tr><tr><td><strong>s4</strong></td><td>x20</td><td>saved register</td><td>yes</td></tr><tr><td><strong>s5</strong></td><td>x21</td><td>saved register</td><td>yes</td></tr><tr><td><strong>s6</strong></td><td>x22</td><td>saved register</td><td>yes</td></tr><tr><td><strong>s7</strong></td><td>x23</td><td>saved register</td><td>yes</td></tr><tr><td><strong>s8</strong></td><td>x24</td><td>saved register</td><td>yes</td></tr><tr><td><strong>s9</strong></td><td>x25</td><td>saved register</td><td>yes</td></tr><tr><td><strong>s10</strong></td><td>x26</td><td>saved register</td><td>yes</td></tr><tr><td><strong>s11</strong></td><td>x27</td><td>saved register</td><td>yes</td></tr><tr><td><strong>t3</strong></td><td>x28</td><td>temporary</td><td>no</td></tr><tr><td><strong>t4</strong></td><td>x29</td><td>temporary</td><td>no</td></tr><tr><td><strong>t5</strong></td><td>x30</td><td>temporary</td><td>no</td></tr><tr><td><strong>t6</strong></td><td>x31</td><td>temporary</td><td>no</td></tr></tbody></table><p>*Let the compiler/linker use the global <strong>gp</strong> and thread <strong>tp</strong> pointers; ignore them in your own code.<br>†The frame pointer <strong>fp</strong> supports local variables but can be used as a regular saved register.<br>‡Argument registers <strong>a0</strong> and <strong>a1</strong> also handle the function return value.</p><h2 id=whats-next>What&rsquo;s Next?</h2><p>The next post looks at RISC-V <strong><a href=/posts/riscv-multiply-divide/>Multiply and Divide Instructions</a></strong> and RISC-V extensions.</p><p>Check out the <a href=/posts/riscv-cheat-sheet/>RISC-V Assembler Cheat Sheet</a> and my <a href=/tutorials/>FPGA & RISC-V Tutorials</a>.</p><p>Share your thoughts with me on <a href=https://mastodon.social/@WillFlux>Mastodon</a> or <a href=https://x.com/WillFlux>X</a>. If you enjoy my work, please <a href=https://github.com/sponsors/WillGreen>sponsor me</a>. Sponsors help me create new projects for everyone, <em>and</em> they get early access to blog posts and source code. 🙏</p><h3 id=references>References</h3><ul><li><a href=https://wiki.riscv.org/display/HOME/RISC-V+Technical+Specifications>RISC-V Technical Specifications</a> (riscv.org)</li></ul></section><footer class="mt-12 flex flex-wrap"><a class="mb-1.5 mr-1.5 rounded-lg bg-black/[3%] px-5 py-1.5 no-underline dark:bg-white/[8%]" href=https://projectf.io/tags/asm>asm</a>
<a class="mb-1.5 mr-1.5 rounded-lg bg-black/[3%] px-5 py-1.5 no-underline dark:bg-white/[8%]" href=https://projectf.io/tags/riscv>riscv</a></footer></article></main><footer class="opaco mx-auto flex h-[4.5rem] max-w-4xl items-center px-8 text-[0.9em] opacity-60"><div class=mr-auto><a class=link href=https://projectf.io/>Project F</a>: FPGA and RISC-V. Only hardware makes it possible!
&copy; 2024 Will Green.</div></footer></body></html>