<!doctype html><html class="not-ready lg:text-base" style=--bg:#fff lang=en-gb><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>RISC-V Assembler: Jump and Function - Project F</title>
<meta name=theme-color><meta name=description content="Part six of RISC-V assembler begins by examining the RISC-V jump instructions: jal and jalr. Jump instructions are the basis of functions, so we&rsquo;ll then dig into function calls, the RISC-V ABI, calling convention, and how to use the stack."><meta name=author content="Will Green"><link rel="preload stylesheet" as=style href=https://projectf.io/main.min.css><link rel=preload as=image href=https://projectf.io/theme.png><link rel=preload as=image href=https://projectf.io/twitter.svg><link rel=preload as=image href=https://projectf.io/github.svg><link rel=preload as=image href=https://projectf.io/mastodon.svg><link rel=preload as=image href=https://projectf.io/rss.svg><script defer src=https://projectf.io/highlight.min.js onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://projectf.io/favicon.ico><link rel=apple-touch-icon href=https://projectf.io/apple-touch-icon.png><meta name=generator content="Hugo 0.125.3"><script src=https://cdn-eu.usefathom.com/script.js data-site=EVCGKVDN defer></script><meta itemprop=name content="RISC-V Assembler: Jump and Function"><meta itemprop=description content="Part six of RISC-V assembler begins by examining the RISC-V jump instructions: jal and jalr. Jump instructions are the basis of functions, so we&rsquo;ll then dig into function calls, the RISC-V ABI, calling convention, and how to use the stack."><meta itemprop=datePublished content="2024-04-30T00:00:00+00:00"><meta itemprop=dateModified content="2024-05-08T00:00:00+00:00"><meta itemprop=wordCount content="2391"><meta itemprop=image content="https://projectf.io/posts/riscv-jump-function/img/social/riscv-jump-function.jpeg"><meta itemprop=keywords content="Asm,Riscv"><meta property="og:url" content="https://projectf.io/posts/riscv-jump-function/"><meta property="og:site_name" content="Project F"><meta property="og:title" content="RISC-V Assembler: Jump and Function"><meta property="og:description" content="Part six of RISC-V assembler begins by examining the RISC-V jump instructions: jal and jalr. Jump instructions are the basis of functions, so we&amp;rsquo;ll then dig into function calls, the RISC-V ABI, calling convention, and how to use the stack."><meta property="og:locale" content="en-gb"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-04-30T00:00:00+00:00"><meta property="article:modified_time" content="2024-05-08T00:00:00+00:00"><meta property="article:tag" content="Asm"><meta property="article:tag" content="Riscv"><meta property="og:image" content="https://projectf.io/posts/riscv-jump-function/img/social/riscv-jump-function.jpeg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://projectf.io/posts/riscv-jump-function/img/social/riscv-jump-function.jpeg"><meta name=twitter:title content="RISC-V Assembler: Jump and Function"><meta name=twitter:description content="Part six of RISC-V assembler begins by examining the RISC-V jump instructions: jal and jalr. Jump instructions are the basis of functions, so we&rsquo;ll then dig into function calls, the RISC-V ABI, calling convention, and how to use the stack."><link rel=canonical href=https://projectf.io/posts/riscv-jump-function/></head><body class="text-black duration-200 ease-out dark:text-white"><header class="mx-auto flex h-[4.5rem] max-w-4xl px-8 lg:justify-center"><div class="relative z-50 mr-auto flex items-center"><a class="-translate-x-[1px] -translate-y-[1px] text-2xl font-semibold" href=https://projectf.io/>Project F</a><div class="btn-dark text-[0] ml-4 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.png)_left_center/_auto_theme('spacing.6')_no-repeat] [transition:_background-position_0.4s_steps(5)] dark:[background-position:right]" role=button aria-label=Dark></div></div><div class="btn-menu relative z-50 -mr-8 flex h-[4.5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden" role=button aria-label=Menu></div><script>const htmlClass=document.documentElement.classList;setTimeout(()=>{htmlClass.remove("not-ready")},10);const btnMenu=document.querySelector(".btn-menu");btnMenu.addEventListener("click",()=>{htmlClass.toggle("open")});const metaTheme=document.querySelector('meta[name="theme-color"]'),lightBg="#fff".replace(/"/g,""),setDark=e=>{metaTheme.setAttribute("content",e?"#000":lightBg),htmlClass[e?"add":"remove"]("dark"),localStorage.setItem("dark",e)},darkScheme=window.matchMedia("(prefers-color-scheme: dark)");if(htmlClass.contains("dark"))setDark(!0);else{const e=localStorage.getItem("dark");setDark(e?e==="true":darkScheme.matches)}darkScheme.addEventListener("change",e=>{setDark(e.matches)});const btnDark=document.querySelector(".btn-dark");btnDark.addEventListener("click",()=>{setDark(localStorage.getItem("dark")!=="true")})</script><div class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full select-none flex-col justify-center pb-16 duration-200 dark:bg-black lg:static lg:h-auto lg:flex-row lg:!bg-transparent lg:pb-0 lg:transition-none"><nav class="lg:ml-12 lg:flex lg:flex-row lg:items-center lg:space-x-6"><a class="block text-center text-2xl leading-[5rem] lg:text-base lg:font-normal" href=/about/>About</a>
<a class="block text-center text-2xl leading-[5rem] lg:text-base lg:font-normal" href=/demos/>Demos</a>
<a class="block text-center text-2xl leading-[5rem] lg:text-base lg:font-normal" href=/verilog-lib/>Lib</a>
<a class="block text-center text-2xl leading-[5rem] lg:text-base lg:font-normal" href=/tools/>Tools</a>
<a class="block text-center text-2xl leading-[5rem] lg:text-base lg:font-normal" href=/tutorials/>Tutorials</a></nav><nav class="mt-12 flex justify-center space-x-10 dark:invert lg:ml-12 lg:mt-0 lg:items-center lg:space-x-6"><a class="h-8 w-8 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./twitter.svg) href=https://twitter.com/@WillFlux target=_blank rel=me>twitter
</a><a class="h-8 w-8 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./github.svg) href=https://github.com/projf target=_blank rel=me>github
</a><a class="h-8 w-8 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./mastodon.svg) href=https://mastodon.social/@WillFlux target=_blank rel=me>mastodon
</a><a class="h-8 w-8 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./rss.svg) href=https://projectf.io/index.xml target=_blank rel=alternate>rss</a></nav></div></header><main class="prose prose-neutral relative mx-auto min-h-[calc(100%-9rem)] max-w-4xl px-8 pb-4 pt-4 dark:prose-invert"><article><header class=mb-4><h1 class="!my-0 pb-2.5">RISC-V Assembler: Jump and Function</h1><div class="text-sm antialiased opacity-60">Published
<time>30 Apr 2024</time>
<span class=mx-1>&#183;</span>
<span>Updated
<time>08 May 2024</time></span></div></header><section><p>This post begins by examining the RISC-V jump instructions: <strong>jal</strong> and <strong>jalr</strong>. Jump instructions are the basis of functions, so we&rsquo;ll then dig into function calls, the RISC-V ABI, calling convention, and how to use the stack. Jump instructions are included in <strong>RV32I</strong>, the base integer instruction set. New to the RISC-V assembler series? Check out the first part on <a href=/posts/riscv-arithmetic>arithmetic instructions</a>.</p><p>In the last few years, we&rsquo;ve seen an explosion of RISC-V CPU designs, especially on FPGA. Thankfully, RISC-V is ideal for assembly programming with its compact, easy-to-learn instruction set. This series will help you learn and understand 32-bit RISC-V instructions (RV32) and the RISC-V ABI.</p><p>Share your thoughts with @WillFlux on <a href=https://mastodon.social/@WillFlux>Mastodon</a> or <a href=https://twitter.com/WillFlux>Twitter</a>. If you like what I do, <a href=https://github.com/sponsors/WillGreen>sponsor me</a>. üôè</p><h2 id=jump>Jump</h2><p>The main operation of the jump instructions is to update the program counter (<strong>PC</strong>).</p><p>The <strong>PC</strong> points to the <em>next</em> instruction the CPU will execute. Usually, the CPU adds 4 to the PC when executing an instruction, as each instruction is 4 bytes long. However, with a jump instruction, the CPU updates the <strong>PC</strong> to point at the jump destination instead.</p><p>The jump instructions are <strong>unconditional</strong>. For conditional jumps, see my separate post on <a href=/posts/riscv-branch-set/>branching</a>.</p><h2 id=just-the-two-of-us>Just the Two of Us</h2><p>At one level, this post is about two instructions: <strong>jal</strong> and <strong>jalr</strong>. But these two instructions are exciting because they enable functions (also known as subroutines or procedure calls).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>jal</span>   <span style=color:#75715e># jump and link
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>jalr</span>  <span style=color:#75715e># jump and link register
</span></span></span></code></pre></div><p>Before updating the <strong>PC</strong>, a jump instruction writes the address of the following instruction into a register. By saving this <strong>return address</strong>, we can return to it and continue execution where we left off.</p><p><strong>jal</strong> uses a 20-bit signed immediate for the jump destination, while <strong>jalr</strong> uses a register plus 12-bit signed offset in a similar way to <a href=/posts/riscv-load-store/>load/store</a> instructions. See <a href=/posts/riscv-arithmetic#sign-extension>arithmetic sign extension</a> for a reminder of how sign extension works.</p><p><strong>jal</strong> has a range of <code>¬±1MiB</code> - relative to the PC. Jumps are in units of two bytes to support compressed instructions.</p><p><strong>jalr</strong> offsets are only <code>¬±2KiB</code>, but you can combine <strong>jalr</strong> with <strong>lui</strong> to reach anywhere in 32-bit address space, or with <strong>auipc</strong> to reach any PC-relative address. See my previous coverage of <a href=/posts/riscv-branch-set/#auipc>auipc</a>.</p><h2 id=jump-1>Jump!</h2><p>Before we tackle more advanced uses for jump, let&rsquo;s consider a plain jump with no way back using:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>j</span>  <span style=color:#75715e># jump to label (no return)
</span></span></span></code></pre></div><p>For example, use <strong>j</strong> in an infinite loop:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span>.L_forever:
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>la</span>  <span style=color:#66d9ef>a0</span>, <span style=color:#66d9ef>message</span>  <span style=color:#75715e># load address of message
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>call</span> <span style=color:#66d9ef>printstr</span>    <span style=color:#75715e># call a function (discussed below)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>j</span> <span style=color:#66d9ef>.L_forever</span>     <span style=color:#75715e># jump to .L_forever label
</span></span></span></code></pre></div><p>You could also use the <strong>j</strong> instruction in case/switch code.</p><p>The assembler translates <strong>j</strong> into <strong>jal</strong> with the return address register set to <strong>x0</strong> (<strong>zero</strong>).</p><p><em>ProTip: Use <strong>j</strong> for unconditional jumps. It makes your intent clear and has a greater range than branches.</em></p><h2 id=functions>Functions</h2><p>To call a function, we must jump to a new address while remembering where we came from. The <strong>jal</strong> instruction can do this. We need to choose where to save the return address. By convention, this is the <strong>x1</strong> register, known in the ABI as the return address register or <strong>ra</strong>.</p><p>The use of <strong>ra</strong> for the return address is part of the standard <strong>RISC-V ABI</strong> (application binary interface). The ABI ensures programs written by different programmers and with different tools can interoperate. For example, the ABI allows a program written in C to call a function written in assembler.</p><p>How do we get back once we&rsquo;ve finished executing our function? We have the return address in <strong>ra</strong>, so the <strong>jalr</strong> (jump and link <em>register</em>) instruction can take us back.</p><p>Let&rsquo;s take a look at a trivial example, calling a function that adds two integers:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>li</span>  <span style=color:#66d9ef>a0</span>, <span style=color:#ae81ff>7</span>  <span style=color:#75715e># 1st argument in a0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>li</span>  <span style=color:#66d9ef>a1</span>, <span style=color:#ae81ff>8</span>  <span style=color:#75715e># 2nd argument in a1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>jal</span> <span style=color:#66d9ef>ra</span>, <span style=color:#66d9ef>add_int</span>  <span style=color:#75715e># save address in register ra (x1) and jump to label add_int
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ebreak</span>  <span style=color:#75715e># stop execution
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>add_int:
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>add</span>  <span style=color:#66d9ef>a0</span>, <span style=color:#66d9ef>a0</span>, <span style=color:#66d9ef>a1</span>  <span style=color:#75715e># a0 = a0 + a1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>jalr</span> <span style=color:#66d9ef>zero</span>, <span style=color:#ae81ff>0</span>(<span style=color:#66d9ef>ra</span>)   <span style=color:#75715e># jump to address in register ra
</span></span></span></code></pre></div><p>Does this seem unnecessarily fiddly? If we always use the <strong>ra</strong> register for the return address, why do we need to provide it? And it&rsquo;s not immediately obvious what the jump instructions are doing.</p><p>Pseudoinstructions <strong>call</strong> and <strong>ret</strong> to the rescue!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>call</span> <span style=color:#66d9ef>label</span>  <span style=color:#75715e># call function at &#39;label&#39;, saving return address in ra
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>ret</span>         <span style=color:#75715e># return from function using address in ra
</span></span></span></code></pre></div><p>This makes for simpler and clearer code:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>li</span> <span style=color:#66d9ef>a0</span>, <span style=color:#ae81ff>7</span>  <span style=color:#75715e># 1st argument in a0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>li</span> <span style=color:#66d9ef>a1</span>, <span style=color:#ae81ff>8</span>  <span style=color:#75715e># 2nd argument in a1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>call</span> <span style=color:#66d9ef>add_int</span>  <span style=color:#75715e># call function
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ebreak</span>  <span style=color:#75715e># stop execution
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>add_int:
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>add</span>  <span style=color:#66d9ef>a0</span>, <span style=color:#66d9ef>a0</span>, <span style=color:#66d9ef>a1</span>  <span style=color:#75715e># a0 = a0 + a1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>ret</span>  <span style=color:#75715e># return from function
</span></span></span></code></pre></div><h2 id=in-and-out>In and Out</h2><p>Most functions take arguments and return something: this is where the <strong>a0-a7</strong> registers come in.</p><p>Before calling a function, you put the first argument in <strong>a0</strong>, the 2nd argument in <strong>a1</strong>, etc. When it comes time to return our result, we put it in <strong>a0</strong>. Just like the convention of using <strong>ra</strong> for the return address, this ensures different code can easily work together.</p><p>We have already seen an example of arguments and return values with <code>add_int</code> (above).</p><h2 id=functions-calling-functions>Functions Calling Functions</h2><p>Functions that don&rsquo;t call other functions are known as <strong>leaf functions</strong>. After a leaf function executes it uses the return address in <strong>ra</strong> to return.</p><p>However, functions can easily call other functions and it&rsquo;s here things get interesting. When we call a function, the <strong>call</strong> instruction writes the return address into <strong>ra</strong>, overwriting the previous return address!</p><p>A function that calls a function <strong>must</strong> save its own return address before making the function call. We save the existing value of <strong>ra</strong> on the <strong>stack</strong>.</p><h2 id=stack>Stack</h2><p>The stack is an area of memory set aside for use by functions and local variables (not discussed here).</p><p>The <strong>stack pointer (sp)</strong> points to the bottom of the stack, which grows <strong>downwards</strong> to lower addresses. When the CPU is reset, the stack pointer is typically set to the very top of memory.</p><p>We allocate memory on the stack by decrementing the stack pointer <strong>sp</strong>. We can then save registers onto the stack using the <strong>sw</strong> (store word) instruction. See <a href=/posts/riscv-load-store/>Load Store</a> for coverage of RISC-V memory instructions.</p><p>For example, function <code>fun_one</code> calls function <code>fun_two</code>, so it must save its return address on the stack:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span>fun_one:
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>addi</span> <span style=color:#66d9ef>sp</span>, <span style=color:#66d9ef>sp</span>, -<span style=color:#ae81ff>16</span>  <span style=color:#75715e># allocate 16 bytes on stack
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>sw</span>   <span style=color:#66d9ef>ra</span>, <span style=color:#ae81ff>12</span>(<span style=color:#66d9ef>sp</span>)   <span style=color:#75715e># store return address on stack
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># do some fun stuff
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>call</span> <span style=color:#66d9ef>fun_two</span>  <span style=color:#75715e># call another function
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># do some more fun stuff
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>lw</span>   <span style=color:#66d9ef>ra</span>, <span style=color:#ae81ff>12</span>(<span style=color:#66d9ef>sp</span>)  <span style=color:#75715e># load return address from stack
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>addi</span> <span style=color:#66d9ef>sp</span>, <span style=color:#66d9ef>sp</span>, <span style=color:#ae81ff>16</span>  <span style=color:#75715e># restore stack pointer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ret</span>  <span style=color:#75715e># return from fun_one
</span></span></span></code></pre></div><p>Note how we store and then later load the return address from the same offset (<code>12</code>) to the stack pointer.</p><h3 id=stack-alignment>Stack Alignment</h3><p>Why did we allocate 16 bytes on the stack when our return address is only 4 bytes long?</p><p>The RISC-V calling convention says:</p><blockquote><p>The stack grows downwards (towards lower addresses) and the stack pointer shall be aligned to a 128-bit boundary upon procedure entry.</p></blockquote><p>This is another example of the ABI ensuring interoperability. We ensure all data types are correctly aligned by aligning the stack pointer to 16 bytes.</p><h2 id=ignorance-is-bliss>Ignorance is Bliss</h2><p>A function doesn&rsquo;t know what happened before it was called or what will happen after it returns. A function caller doesn&rsquo;t know what happens inside a function, just what it passes in and gets back. A well-written function is an example of a <a href=https://en.wikipedia.org/wiki/Black_box>black box</a>.</p><p>RISC-V gives us 32 general-purpose registers, but if every function used them indiscriminately, they&rsquo;d overwrite each other&rsquo;s data. We can solve this problem by pushing existing register values onto the stack. However, pushing values onto the stack makes functions slower. A simple function could spend more CPU cycles pushing and popping values from the stack than doing useful work.</p><p>The RISC-V ABI lets us have fast functions while preserving <em>some</em> register values.</p><p>There are three main categories of general-purpose registers:</p><ul><li><strong>saved registers: s0-s11</strong> - keep their value across function calls (<strong>preserved</strong>)</li><li><strong>argument registers: a0-a7</strong> - for passing arguments and the return value (<strong>not preserved</strong>)</li><li><strong>temporary registers: t0-t6</strong> - for internal function use (<strong>not preserved</strong>)</li></ul><p>Understanding how to handle preserved and non-preserved registers is critical to writing RISC-V assembler. I&rsquo;d go so far as to say its the most important skill beyond a basic knowledge of the instructions. Getting it right results in fast, elegant code. Getting it wrong leads to subtle bugs and much frustration. A good start is to always use ABI names for registers, otherwise it&rsquo;s really difficult to remember which registers you need to save!</p><ul><li>A function using a <strong>preserved register</strong> must restore its original value before returning.</li><li>A function using a <strong>non-preserved register</strong> must assume it&rsquo;s changed by a function call.</li></ul><p>Let&rsquo;s look at both cases in a little more detail.</p><h3 id=preserved-registers>Preserved Registers</h3><p>Preserved registers <strong>must</strong> be restored to their original value before returning from a function call. If your function uses preserved registers, such as <strong>s0-s11</strong>, save their existing values on the stack.</p><p>For example, <code>fun_foo</code> uses <strong>s1-s4</strong>, it saves them on the stack like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span>fun_foo:
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>addi</span> <span style=color:#66d9ef>sp</span>, <span style=color:#66d9ef>sp</span>, -<span style=color:#ae81ff>16</span>  <span style=color:#75715e># allocate space on stack
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>sw</span>   <span style=color:#66d9ef>s1</span>, <span style=color:#ae81ff>12</span>(<span style=color:#66d9ef>sp</span>)   <span style=color:#75715e># store saved registers on stack
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>sw</span>   <span style=color:#66d9ef>s2</span>,  <span style=color:#ae81ff>8</span>(<span style=color:#66d9ef>sp</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>sw</span>   <span style=color:#66d9ef>s3</span>,  <span style=color:#ae81ff>4</span>(<span style=color:#66d9ef>sp</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>sw</span>   <span style=color:#66d9ef>s4</span>,  <span style=color:#ae81ff>0</span>(<span style=color:#66d9ef>sp</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># we&#39;re now free to use s1-s4
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e># implement incredible algorithm here
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>lw</span>   <span style=color:#66d9ef>s1</span>, <span style=color:#ae81ff>12</span>(<span style=color:#66d9ef>sp</span>)  <span style=color:#75715e># restore saved registers from stack
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>lw</span>   <span style=color:#66d9ef>s2</span>,  <span style=color:#ae81ff>8</span>(<span style=color:#66d9ef>sp</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>lw</span>   <span style=color:#66d9ef>s3</span>,  <span style=color:#ae81ff>4</span>(<span style=color:#66d9ef>sp</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>lw</span>   <span style=color:#66d9ef>s4</span>,  <span style=color:#ae81ff>0</span>(<span style=color:#66d9ef>sp</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>addi</span> <span style=color:#66d9ef>sp</span>, <span style=color:#66d9ef>sp</span>, <span style=color:#ae81ff>16</span>  <span style=color:#75715e># restore stack pointer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>ret</span>
</span></span></code></pre></div><h3 id=other-registers>Other Registers</h3><p>With non-preserved registers, you can do what you want, but so can other functions. After you call another function, you must assume the values of the <strong>a</strong> and <strong>t</strong> registers have changed.</p><p>For example, I&rsquo;ve written a function to initialize my graphics display. The background colour is passed to <code>gfx_setup</code> in <strong>a0</strong>. However, before I set the background colour I need to call <code>frame_wait</code>.</p><p>The <code>frame_wait</code> function could overwrite <strong>a0</strong>, so I preserve it on the stack. Of course, I also need to save <strong>ra</strong> on the stack before calling another function, leading to this design:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span>gfx_setup:
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>addi</span> <span style=color:#66d9ef>sp</span>, <span style=color:#66d9ef>sp</span>, -<span style=color:#ae81ff>16</span>  <span style=color:#75715e># allocate space on stack
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>sw</span>   <span style=color:#66d9ef>ra</span>, <span style=color:#ae81ff>12</span>(<span style=color:#66d9ef>sp</span>)   <span style=color:#75715e># save return address onto stack
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>sw</span>   <span style=color:#66d9ef>a0</span>,  <span style=color:#ae81ff>8</span>(<span style=color:#66d9ef>sp</span>)   <span style=color:#75715e># save a0 (background colour)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>call</span> <span style=color:#66d9ef>frame_wait</span>  <span style=color:#75715e># wait for blanking before graphics setup
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>li</span> <span style=color:#66d9ef>t6</span>, <span style=color:#66d9ef>GFX_HWREG</span>  <span style=color:#75715e># graphics engine address
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># background colour
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>lw</span> <span style=color:#66d9ef>a0</span>, <span style=color:#ae81ff>8</span>(<span style=color:#66d9ef>sp</span>)  <span style=color:#75715e># load background colour (a0) from stack
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>sw</span> <span style=color:#66d9ef>a0</span>, <span style=color:#66d9ef>DISP_BGRD</span>(<span style=color:#66d9ef>t6</span>)  <span style=color:#75715e># set background colour
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># other graphics setup here...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>lw</span>   <span style=color:#66d9ef>ra</span>, <span style=color:#ae81ff>12</span>(<span style=color:#66d9ef>sp</span>)  <span style=color:#75715e># load return address from stack
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>addi</span> <span style=color:#66d9ef>sp</span>, <span style=color:#66d9ef>sp</span>, <span style=color:#ae81ff>16</span>  <span style=color:#75715e># restore stack pointer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>ret</span>
</span></span></code></pre></div><p>Functions that don&rsquo;t call other functions (leaf functions), don&rsquo;t have to worry about non-preserved registers changing. When writing leaf functions, stick to <strong>t</strong> and <strong>a</strong> registers, then you don&rsquo;t have to save anything to the stack: simple and fast.</p><h2 id=many-arguments>Many Arguments</h2><p>In the rare event your function needs more than eight arguments, you can pass them on the stack.</p><p>The RISC-V calling convention says:</p><blockquote><p>The first argument passed on the stack is located at offset zero of the stack pointer on function entry; following arguments are stored at correspondingly higher addresses.</p></blockquote><p>For example, a function with 10 arguments receives the first eight arguments in <strong>a0-a7</strong> and could handle the remaining arguments like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span>fun_ten:
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>lw</span> <span style=color:#66d9ef>t0</span>, <span style=color:#ae81ff>0</span>(<span style=color:#66d9ef>sp</span>)  <span style=color:#75715e># load 9th argument off stack into t0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>lw</span> <span style=color:#66d9ef>t1</span>, <span style=color:#ae81ff>4</span>(<span style=color:#66d9ef>sp</span>)  <span style=color:#75715e># load 10th argument off stack into t1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># the first 8 arguments are in a0-a7
</span></span></span></code></pre></div><p><em>NB. We use an offset of 4 for the 10th argument because we&rsquo;re loading a word (four bytes).</em></p><h2 id=64-bit-variables>64-bit Variables</h2><p>RV32 is a 32-bit architecture, but sometimes you need to work with 64-bit values, such as file offsets or UNIX time. In this case, you can combine pairs of registers, such as <strong>a0</strong> and <strong>a1</strong>.</p><p>The following function performs 64-bit subtraction, including handling the carry bit:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#75715e># 64-bit integer subtraction
</span></span></span><span style=display:flex><span><span style=color:#75715e>#   arguments:
</span></span></span><span style=display:flex><span><span style=color:#75715e>#       a0: x lower 32 bits
</span></span></span><span style=display:flex><span><span style=color:#75715e>#       a1: x upper 32 bits
</span></span></span><span style=display:flex><span><span style=color:#75715e>#       a2: y lower 32 bits
</span></span></span><span style=display:flex><span><span style=color:#75715e>#       a3: y upper 32 bits
</span></span></span><span style=display:flex><span><span style=color:#75715e>#   return:
</span></span></span><span style=display:flex><span><span style=color:#75715e>#       a0: x-y lower 32 bits
</span></span></span><span style=display:flex><span><span style=color:#75715e>#       a1: x-y upper 32 bits
</span></span></span><span style=display:flex><span><span style=color:#75715e>#
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>sub64:
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>sltu</span>    <span style=color:#66d9ef>t0</span>, <span style=color:#66d9ef>a0</span>, <span style=color:#66d9ef>a2</span>  <span style=color:#75715e># if a0 &lt; a2 then set t1=1 (carry bit)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>sub</span>     <span style=color:#66d9ef>a1</span>, <span style=color:#66d9ef>a1</span>, <span style=color:#66d9ef>a3</span>  <span style=color:#75715e># sub upper 32 bits
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>sub</span>     <span style=color:#66d9ef>a1</span>, <span style=color:#66d9ef>a1</span>, <span style=color:#66d9ef>t0</span>  <span style=color:#75715e># sub carry bit from upper 32 bits of answer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>sub</span>     <span style=color:#66d9ef>a0</span>, <span style=color:#66d9ef>a0</span>, <span style=color:#66d9ef>a2</span>  <span style=color:#75715e># sub lower 32 bits
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>ret</span>
</span></span></code></pre></div><p>Learn more on <a href=/posts/riscv-branch-set/#multi-word-addition>multi-word addition</a> with set instructions.</p><h2 id=rv32-abi-registers>RV32 ABI Registers</h2><p>Let&rsquo;s finish by taking a look at all 32 ABI registers.</p><table><thead><tr><th>ABI Name</th><th>Register</th><th>Description</th><th>Preserved</th></tr></thead><tbody><tr><td><strong>zero</strong></td><td>x0</td><td>always 0 (zero)</td><td>n/a</td></tr><tr><td><strong>ra</strong></td><td>x1</td><td>return address</td><td>no</td></tr><tr><td><strong>sp</strong></td><td>x2</td><td>stack pointer</td><td>yes</td></tr><tr><td><strong>gp</strong></td><td>x3</td><td>global pointer*</td><td>n/a</td></tr><tr><td><strong>tp</strong></td><td>x4</td><td>thread pointer*</td><td>n/a</td></tr><tr><td><strong>t0</strong></td><td>x5</td><td>temporary</td><td>no</td></tr><tr><td><strong>t1</strong></td><td>x6</td><td>temporary</td><td>no</td></tr><tr><td><strong>t2</strong></td><td>x7</td><td>temporary</td><td>no</td></tr><tr><td><strong>fp (s0)</strong></td><td>x8</td><td>frame pointer‚Ä†</td><td>yes</td></tr><tr><td><strong>s1</strong></td><td>x9</td><td>saved register</td><td>yes</td></tr><tr><td><strong>a0</strong></td><td>x10</td><td>function argument‚Ä°</td><td>no</td></tr><tr><td><strong>a1</strong></td><td>x11</td><td>function argument‚Ä°</td><td>no</td></tr><tr><td><strong>a2</strong></td><td>x12</td><td>function argument</td><td>no</td></tr><tr><td><strong>a3</strong></td><td>x13</td><td>function argument</td><td>no</td></tr><tr><td><strong>a4</strong></td><td>x14</td><td>function argument</td><td>no</td></tr><tr><td><strong>a5</strong></td><td>x15</td><td>function argument</td><td>no</td></tr><tr><td><strong>a6</strong></td><td>x16</td><td>function argument</td><td>no</td></tr><tr><td><strong>a7</strong></td><td>x17</td><td>function argument</td><td>no</td></tr><tr><td><strong>s2</strong></td><td>x18</td><td>saved register</td><td>yes</td></tr><tr><td><strong>s3</strong></td><td>x19</td><td>saved register</td><td>yes</td></tr><tr><td><strong>s4</strong></td><td>x20</td><td>saved register</td><td>yes</td></tr><tr><td><strong>s5</strong></td><td>x21</td><td>saved register</td><td>yes</td></tr><tr><td><strong>s6</strong></td><td>x22</td><td>saved register</td><td>yes</td></tr><tr><td><strong>s7</strong></td><td>x23</td><td>saved register</td><td>yes</td></tr><tr><td><strong>s8</strong></td><td>x24</td><td>saved register</td><td>yes</td></tr><tr><td><strong>s9</strong></td><td>x25</td><td>saved register</td><td>yes</td></tr><tr><td><strong>s10</strong></td><td>x26</td><td>saved register</td><td>yes</td></tr><tr><td><strong>s11</strong></td><td>x27</td><td>saved register</td><td>yes</td></tr><tr><td><strong>t3</strong></td><td>x28</td><td>temporary</td><td>no</td></tr><tr><td><strong>t4</strong></td><td>x29</td><td>temporary</td><td>no</td></tr><tr><td><strong>t5</strong></td><td>x30</td><td>temporary</td><td>no</td></tr><tr><td><strong>t6</strong></td><td>x31</td><td>temporary</td><td>no</td></tr></tbody></table><p>*Let the compiler/linker use the global <strong>gp</strong> and thread <strong>tp</strong> pointers; ignore them in your own code.<br>‚Ä†The frame pointer <strong>fp</strong> supports local variables but can be used as a regular saved register.<br>‚Ä°Argument registers <strong>a0</strong> and <strong>a1</strong> also handle the function return value.</p><h2 id=whats-next>What&rsquo;s Next?</h2><p>If you enjoyed this post, please <a href=https://github.com/sponsors/WillGreen>sponsor me</a>. Sponsors help me create more FPGA and RISC-V projects for everyone, <em>and</em> they get early access to blog posts and source code. üôè</p><p>This is the latest post on <em>RISC-V Assembler</em>, but look out for more posts in future.</p><p>Previous parts of this series include: <a href=/posts/riscv-arithmetic/>Arithmetic</a>, <a href=/posts/riscv-load-store/>Load Store</a>, and <a href=/posts/riscv-branch-set/>Branch Set</a> instructions. Or check out my <a href=/tutorials/>FPGA & RISC-V Tutorials</a> and my series on early <a href=https://systemtalk.org/post/macintosh-history-8510/>Macintosh History</a>.</p><h3 id=references>References</h3><ul><li><a href=https://wiki.riscv.org/display/HOME/RISC-V+Technical+Specifications>RISC-V Technical Specifications</a> (riscv.org)</li></ul></section><footer class="mt-12 flex flex-wrap"><a class="mb-1.5 mr-1.5 rounded-lg bg-black/[3%] px-5 py-1.5 no-underline dark:bg-white/[8%]" href=https://projectf.io/tags/asm>asm</a>
<a class="mb-1.5 mr-1.5 rounded-lg bg-black/[3%] px-5 py-1.5 no-underline dark:bg-white/[8%]" href=https://projectf.io/tags/riscv>riscv</a></footer></article></main><footer class="opaco mx-auto flex h-[4.5rem] max-w-4xl items-center px-8 text-[0.9em] opacity-60"><div class=mr-auto><a class=link href=https://projectf.io/>Project F</a>: A little oasis for FPGA and RISC-V design.
&copy; 2024 Will Green.</div></footer></body></html>