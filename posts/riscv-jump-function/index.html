<!doctype html><html class="not-ready lg:text-base" style=--bg:#fff lang=en-gb><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>RISC-V Assembler: Jump and Function - Project F</title>
<meta name=theme-color><meta name=description content="Part six of RISC-V assembler looks at the RISC-V jump instructions: jal and jalr. Jump instructions are the basis of function calls, so we&rsquo;ll also cover the stack and the RISC-V ABI. Jump instructions are included in RV32I, the base integer instruction set."><meta name=author content="Will Green"><link rel="preload stylesheet" as=style href=https://projectf.io/main.min.css><link rel=preload as=image href=https://projectf.io/theme.png><link rel=preload as=image href=https://projectf.io/twitter.svg><link rel=preload as=image href=https://projectf.io/github.svg><link rel=preload as=image href=https://projectf.io/mastodon.svg><link rel=preload as=image href=https://projectf.io/rss.svg><script defer src=https://projectf.io/highlight.min.js onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://projectf.io/favicon.ico><link rel=apple-touch-icon href=https://projectf.io/apple-touch-icon.png><meta name=generator content="Hugo 0.124.1"><script src=https://cdn-eu.usefathom.com/script.js data-site=EVCGKVDN defer></script><meta itemprop=name content="RISC-V Assembler: Jump and Function"><meta itemprop=description content="Part six of RISC-V assembler looks at the RISC-V jump instructions: jal and jalr. Jump instructions are the basis of function calls, so we&rsquo;ll also cover the stack and the RISC-V ABI. Jump instructions are included in RV32I, the base integer instruction set."><meta itemprop=datePublished content="2024-04-23T00:00:00+00:00"><meta itemprop=dateModified content="2024-04-23T00:00:00+00:00"><meta itemprop=wordCount content="1596"><meta itemprop=image content="https://projectf.io/img/social/riscv-jump-function.jpeg"><meta itemprop=keywords content><meta property="og:title" content="RISC-V Assembler: Jump and Function"><meta property="og:description" content="Part six of RISC-V assembler looks at the RISC-V jump instructions: jal and jalr. Jump instructions are the basis of function calls, so we&rsquo;ll also cover the stack and the RISC-V ABI. Jump instructions are included in RV32I, the base integer instruction set."><meta property="og:type" content="article"><meta property="og:url" content="https://projectf.io/posts/riscv-jump-function/"><meta property="og:image" content="https://projectf.io/img/social/riscv-jump-function.jpeg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-04-23T00:00:00+00:00"><meta property="article:modified_time" content="2024-04-23T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://projectf.io/img/social/riscv-jump-function.jpeg"><meta name=twitter:title content="RISC-V Assembler: Jump and Function"><meta name=twitter:description content="Part six of RISC-V assembler looks at the RISC-V jump instructions: jal and jalr. Jump instructions are the basis of function calls, so we&rsquo;ll also cover the stack and the RISC-V ABI. Jump instructions are included in RV32I, the base integer instruction set."><link rel=canonical href=https://projectf.io/posts/riscv-jump-function/></head><body class="text-black duration-200 ease-out dark:text-white"><header class="mx-auto flex h-[4.5rem] max-w-4xl px-8 lg:justify-center"><div class="relative z-50 mr-auto flex items-center"><a class="-translate-x-[1px] -translate-y-[1px] text-2xl font-semibold" href=https://projectf.io/>Project F</a><div class="btn-dark text-[0] ml-4 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.png)_left_center/_auto_theme('spacing.6')_no-repeat] [transition:_background-position_0.4s_steps(5)] dark:[background-position:right]" role=button aria-label=Dark></div></div><div class="btn-menu relative z-50 -mr-8 flex h-[4.5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden" role=button aria-label=Menu></div><script>const htmlClass=document.documentElement.classList;setTimeout(()=>{htmlClass.remove("not-ready")},10);const btnMenu=document.querySelector(".btn-menu");btnMenu.addEventListener("click",()=>{htmlClass.toggle("open")});const metaTheme=document.querySelector('meta[name="theme-color"]'),lightBg="#fff".replace(/"/g,""),setDark=e=>{metaTheme.setAttribute("content",e?"#000":lightBg),htmlClass[e?"add":"remove"]("dark"),localStorage.setItem("dark",e)},darkScheme=window.matchMedia("(prefers-color-scheme: dark)");if(htmlClass.contains("dark"))setDark(!0);else{const e=localStorage.getItem("dark");setDark(e?e==="true":darkScheme.matches)}darkScheme.addEventListener("change",e=>{setDark(e.matches)});const btnDark=document.querySelector(".btn-dark");btnDark.addEventListener("click",()=>{setDark(localStorage.getItem("dark")!=="true")})</script><div class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full select-none flex-col justify-center pb-16 duration-200 dark:bg-black lg:static lg:h-auto lg:flex-row lg:!bg-transparent lg:pb-0 lg:transition-none"><nav class="lg:ml-12 lg:flex lg:flex-row lg:items-center lg:space-x-6"><a class="block text-center text-2xl leading-[5rem] lg:text-base lg:font-normal" href=/about/>About</a>
<a class="block text-center text-2xl leading-[5rem] lg:text-base lg:font-normal" href=/demos/>Demos</a>
<a class="block text-center text-2xl leading-[5rem] lg:text-base lg:font-normal" href=/verilog-lib/>Lib</a>
<a class="block text-center text-2xl leading-[5rem] lg:text-base lg:font-normal" href=/tools/>Tools</a>
<a class="block text-center text-2xl leading-[5rem] lg:text-base lg:font-normal" href=/tutorials/>Tutorials</a></nav><nav class="mt-12 flex justify-center space-x-10 dark:invert lg:ml-12 lg:mt-0 lg:items-center lg:space-x-6"><a class="h-8 w-8 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./twitter.svg) href=https://twitter.com/@WillFlux target=_blank rel=me>twitter
</a><a class="h-8 w-8 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./github.svg) href=https://github.com/projf target=_blank rel=me>github
</a><a class="h-8 w-8 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./mastodon.svg) href=https://mastodon.social/@WillFlux target=_blank rel=me>mastodon
</a><a class="h-8 w-8 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./rss.svg) href=https://projectf.io/index.xml target=_blank rel=alternate>rss</a></nav></div></header><main class="prose prose-neutral relative mx-auto min-h-[calc(100%-9rem)] max-w-4xl px-8 pb-4 pt-4 dark:prose-invert"><article><header class=mb-4><h1 class="!my-0 pb-2.5">RISC-V Assembler: Jump and Function</h1><div class="text-sm antialiased opacity-60">Published
<time>23 Apr 2024</time></div></header><section><p>This post looks at the RISC-V jump instructions: <strong>jal</strong> and <strong>jalr</strong>. Jump instructions are the basis of function calls, so we&rsquo;ll also cover the stack and the RISC-V ABI. Jump instructions are included in <strong>RV32I</strong>, the base integer instruction set. New to the RISC-V assembler series? Check out the first part on <a href=/posts/riscv-arithmetic>arithmetic instructions</a>.</p><p>In the last few years, we&rsquo;ve seen an explosion of RISC-V CPU designs, especially on FPGA. Thankfully, RISC-V is ideal for assembly programming with its compact, easy-to-learn instruction set. This series will help you learn and understand 32-bit RISC-V instructions (RV32) and the RISC-V ABI.</p><p>Share your thoughts with @WillFlux on <a href=https://mastodon.social/@WillFlux>Mastodon</a> or <a href=https://twitter.com/WillFlux>Twitter</a>. If you like what I do, <a href=https://github.com/sponsors/WillGreen>sponsor me</a>. üôè</p><p><strong>This is a draft post - expect errors and omissions.</strong></p><h2 id=jump>Jump?</h2><p>The program counter points to the next instruction&mldr;</p><p>A jump is an <strong>unconditional</strong>&mldr; after most instructions, the program counter increases by four bytes (<strong>PC+4</strong>)&mldr;</p><p>&mldr;see <a href=/posts/riscv-branch-set/>branching</a> for conditional jumps.</p><h2 id=just-the-two-of-us>Just the Two of Us</h2><p>At one level, this post is about two instructions: <strong>jal</strong> and <strong>jalr</strong>. But these two instructions are exciting because they enable functions (or subroutines or procedures calls, if you prefer).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>jal</span>   <span style=color:#75715e># jump and link
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>jalr</span>  <span style=color:#75715e># jump and link register
</span></span></span></code></pre></div><p>The jump instructions put the address of the next instruction into a register before jumping to a new address. By recording the address of the instruction following the jump, we can return to it and continue execution where we left off.</p><p><strong>jal</strong> uses a 20-bit signed immediate for the jump destination, while <strong>jalr</strong> uses a register plus 12-bit signed offset in a similar way to <a href=/posts/riscv-load-store/>load/store</a> instructions. See <a href=/posts/riscv-arithmetic#sign-extension>arithmetic sign extension</a> for a reminder of how sign extension works.</p><p><strong>jal</strong> has a range of <code>¬±1MiB</code> - relative to the program counter. Jumps are in units of two bytes; the size of a compressed instructions.</p><p><strong>jalr</strong> offsets are only <code>¬±2KiB</code>, but you can combine <strong>jalr</strong> with <strong>lui</strong> to reach anywhere in 32-bit address space, or with <strong>auipc</strong> to reach any PC-relative address.</p><h2 id=jump-1>Jump!</h2><p>Before we tackle functions, let&rsquo;s consider a plain jump with no way back using <strong>j</strong>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>j</span>  <span style=color:#75715e># jump to label (no return)
</span></span></span></code></pre></div><p>For example, in an infinite loop:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span>.L_forever:
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>la</span>  <span style=color:#66d9ef>a0</span>, <span style=color:#66d9ef>message</span>  <span style=color:#75715e># load address of message
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>call</span> <span style=color:#66d9ef>printstr</span>    <span style=color:#75715e># call a function (discussed below)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>j</span> <span style=color:#66d9ef>.L_forever</span>     <span style=color:#75715e># jump to .L_forever label
</span></span></span></code></pre></div><p>You could also use the <strong>j</strong> instruction in case/switch code.</p><p>Using <strong>j</strong> for unconditional jumps makes your intent clear and it has a greater range than branches.</p><p>The assembler translates <strong>j</strong> into <strong>jal</strong> with the return address set to <strong>x0</strong> (zero).</p><h2 id=functions>Functions</h2><p>To call a function, we need to jump to a new address while remembering where we came from. The <strong>jal</strong> instruction can do this. We need to save the return address somewhere and by convention that somewhere is the <strong>x1</strong> register, which is known as the return address <strong>ra</strong> register.</p><p>The use of <strong>x1</strong> for the return address is part of the standard <strong>RISC-V ABI</strong> (application binary interface). The ABI ensures programs written by different programmers and with different tools can interoperate. For example, the ABI allows a program written in C to call function written in assembler.</p><p>Now we&rsquo;re in our function, how do we get back? We have the return address in <strong>ra</strong>, so the <strong>jalr</strong> instruction can take us back.</p><p>Let&rsquo;s take look at a trivial example, calling a function that adds two integers.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>li</span>  <span style=color:#66d9ef>a0</span>, <span style=color:#ae81ff>7</span>  <span style=color:#75715e># 1st argument in a0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>li</span>  <span style=color:#66d9ef>a1</span>, <span style=color:#ae81ff>8</span>  <span style=color:#75715e># 2nd argument in a1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>jal</span> <span style=color:#66d9ef>ra</span>, <span style=color:#66d9ef>add_int</span>  <span style=color:#75715e># save address in register x1 and jump to label add_int
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ebreak</span>  <span style=color:#75715e># stop execution
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>add_int:
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>add</span>  <span style=color:#66d9ef>a0</span>, <span style=color:#66d9ef>a0</span>, <span style=color:#66d9ef>a1</span>  <span style=color:#75715e># a0 = a0 + a1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>jalr</span> <span style=color:#66d9ef>x0</span>, <span style=color:#ae81ff>0</span>(<span style=color:#66d9ef>ra</span>)   <span style=color:#75715e># jump to address in register x1
</span></span></span></code></pre></div><p>If you think this seems unnecessarily fiddly, you&rsquo;re right. RISC-V gives us pseudoinstructions for calling and returning from a function:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>call</span> <span style=color:#66d9ef>label</span>  <span style=color:#75715e># call function saving return address in ra
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>ret</span>         <span style=color:#75715e># return from function using address in ra
</span></span></span></code></pre></div><p>This makes for simpler and clearer code:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>li</span> <span style=color:#66d9ef>a0</span>, <span style=color:#ae81ff>7</span>  <span style=color:#75715e># 1st argument in a0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>li</span> <span style=color:#66d9ef>a1</span>, <span style=color:#ae81ff>8</span>  <span style=color:#75715e># 2nd argument in a1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>call</span> <span style=color:#66d9ef>add_int</span>  <span style=color:#75715e># call function
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ebreak</span>  <span style=color:#75715e># stop execution
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>add_int:
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>add</span>  <span style=color:#66d9ef>a0</span>, <span style=color:#66d9ef>a0</span>, <span style=color:#66d9ef>a1</span>  <span style=color:#75715e># a0 = a0 + a1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>ret</span>  <span style=color:#75715e># return from function
</span></span></span></code></pre></div><h2 id=many-arguments>Many Arguments</h2><p>Most function take arguments and return something. This is where the <strong>a0-a7</strong> registers come in. Before calling a function, you put the first argument in <strong>a0</strong>, the 2nd argument in <strong>a1</strong>, etc. up to eight arguments. When it comes time to return our result we put it in <strong>a0</strong>.</p><p>We already saw an example of arguments and return values with the <code>add_int</code> function (above).</p><p>In the event you need more than eight arguments, you can push the remainder onto the stack. We&rsquo;ll meet the stack shortly.</p><h3 id=64-bit>64-bit</h3><p>RV32 is a 32-bit architecture, but sometimes you need to work with 64-bit values. In this case you can combine pairs of registers, such as <strong>a0</strong> and <strong>a1</strong>.</p><p>The following function performs 64-bit subtraction, including handling the carry bit:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#75715e># 64-bit integer subtraction
</span></span></span><span style=display:flex><span><span style=color:#75715e>#   arguments:
</span></span></span><span style=display:flex><span><span style=color:#75715e>#       a0: x lower 32 bits
</span></span></span><span style=display:flex><span><span style=color:#75715e>#       a1: x upper 32 bits
</span></span></span><span style=display:flex><span><span style=color:#75715e>#       a2: y lower 32 bits
</span></span></span><span style=display:flex><span><span style=color:#75715e>#       a3: y upper 32 bits
</span></span></span><span style=display:flex><span><span style=color:#75715e>#   return:
</span></span></span><span style=display:flex><span><span style=color:#75715e>#       a0: x-y lower 32 bits
</span></span></span><span style=display:flex><span><span style=color:#75715e>#       a1: x-y upper 32 bits
</span></span></span><span style=display:flex><span><span style=color:#75715e>#
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>sub64:
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>sltu</span>    <span style=color:#66d9ef>t0</span>, <span style=color:#66d9ef>a0</span>, <span style=color:#66d9ef>a2</span>  <span style=color:#75715e># if a0 &lt; a2 then set t1=1 (carry bit)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>sub</span>     <span style=color:#66d9ef>a1</span>, <span style=color:#66d9ef>a1</span>, <span style=color:#66d9ef>a3</span>  <span style=color:#75715e># sub upper 32 bits
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>sub</span>     <span style=color:#66d9ef>a1</span>, <span style=color:#66d9ef>a1</span>, <span style=color:#66d9ef>t0</span>  <span style=color:#75715e># sub carry bit from upper 32 bits of answer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>sub</span>     <span style=color:#66d9ef>a0</span>, <span style=color:#66d9ef>a0</span>, <span style=color:#66d9ef>a2</span>  <span style=color:#75715e># sub lower 32 bits
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>ret</span>
</span></span></code></pre></div><p>Learn more on <a href=/posts/riscv-branch-set/#multi-word-addition>multi-word addition</a> with set instructions.</p><h2 id=black-box>Black Box</h2><p>A function is a black box. It doesn&rsquo;t know what&rsquo;s happening before or after it&rsquo;s called. RISC-V gives us 32 general-purpose registers, but if every function used registers indiscriminately, they&rsquo;d be overwriting each other&rsquo;s data. Traditionally, the solution to this problem is pushing existing register values onto the stack before using them. However, pushing many values onto the stack is expensive in memory access.</p><p>The RISC-V provides the best of both worlds by dividing registers into those that the function needs to save and those the function <strong>caller</strong> needs to save.</p><p>Ignorance is Bliss&mldr;</p><p>explain why we used temporary reg in examples <code>t0-t6</code>.</p><p>Do what you want with <strong>t</strong> and <strong>a</strong> registers, but you MUST save <strong>s</strong> registers.</p><p>Use the ABI names for registers in your code: it reduces errors, especially when saving and restoring registers.</p><h2 id=in-too-deep>In Too Deep</h2><p>We said the return address is stored in the <strong>ra</strong> register, but what happens when a function calls another function? The second function call will overwrite the return address of the first function, so we can&rsquo;t return! We need to find somewhere to stash the previous return address so we can safely call another function; this is where the stack comes in.</p><h3 id=stack>Stack</h3><p>The stack pointer starts at the top of memory</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span>fun:
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>addi</span> <span style=color:#66d9ef>sp</span>, <span style=color:#66d9ef>sp</span>, -<span style=color:#ae81ff>16</span>  <span style=color:#75715e># allocate 16 bytes on stack
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>sw</span> <span style=color:#66d9ef>ra</span>, <span style=color:#ae81ff>12</span>(<span style=color:#66d9ef>sp</span>)  <span style=color:#75715e># store return address on stack
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>call</span> <span style=color:#66d9ef>fun_two</span>  <span style=color:#75715e># call another function
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>lw</span> <span style=color:#66d9ef>ra</span>, <span style=color:#ae81ff>12</span>(<span style=color:#66d9ef>sp</span>)    <span style=color:#75715e># load return address from stack
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>addi</span> <span style=color:#66d9ef>sp</span>, <span style=color:#66d9ef>sp</span>, <span style=color:#ae81ff>16</span>  <span style=color:#75715e># restore stack pointer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ret</span>  <span style=color:#75715e># return from fun
</span></span></span></code></pre></div><p><em>add a diagram of the stack</em></p><p>Why did we allocate 16 bytes on the stack when our return address is only four bytes long?</p><blockquote><p>&ldquo;The stack grows downwards (towards lower addresses) and the stack pointer shall be aligned to a 128-bit boundary upon procedure entry.&rdquo; - ABI spec</p></blockquote><blockquote><p>&ldquo;Tag_RISCV_stack_align records the N-byte stack alignment for this object. The default value is 16 for RV32I or RV64I, and 4 for RV32E&rdquo; - source ABI spec</p></blockquote><p>You might be tempted to ignore the ABI and save memory. Don&rsquo;t do this&mldr;</p><h3 id=leaf-functions>Leaf Functions</h3><p>Leaf functions don&rsquo;t call other functions, so don&rsquo;t need to save the return address on the stack.</p><h3 id=variables-on-the-stack>Variables on the Stack</h3><p>If you need more storage than the temporary register provide, you can use the stack&mldr;</p><p>Frame pointer <strong>fp</strong>&mldr; I avoid using <strong>s0</strong> in my functions in case I later want a frame pointer.</p><p>Local variables&mldr;</p><p>Prefer registers when you can as they&rsquo;re faster and avoid memory access.</p><h2 id=rv32-abi-registers>RV32 ABI Registers</h2><p>Let&rsquo;s take a look at all 32 ABI registers.</p><table><thead><tr><th>ABI Name</th><th>Register</th><th>Description</th></tr></thead><tbody><tr><td><strong>zero</strong></td><td>x0</td><td>always 0</td></tr><tr><td><strong>ra</strong></td><td>x1</td><td>return address</td></tr><tr><td><strong>sp</strong></td><td>x2</td><td>stack pointer</td></tr><tr><td><strong>gp</strong></td><td>x3</td><td>global pointer*</td></tr><tr><td><strong>tp</strong></td><td>x4</td><td>thread pointer*</td></tr><tr><td><strong>t0</strong></td><td>x5</td><td>temporary</td></tr><tr><td><strong>t1</strong></td><td>x6</td><td>temporary</td></tr><tr><td><strong>t2</strong></td><td>x7</td><td>temporary</td></tr><tr><td><strong>fp (s0)</strong></td><td>x8</td><td>frame pointer</td></tr><tr><td><strong>s1</strong></td><td>x9</td><td>saved register</td></tr><tr><td><strong>a0</strong></td><td>x10</td><td>function argument</td></tr><tr><td><strong>a1</strong></td><td>x11</td><td>function argument</td></tr><tr><td><strong>a2</strong></td><td>x12</td><td>function argument</td></tr><tr><td><strong>a3</strong></td><td>x13</td><td>function argument</td></tr><tr><td><strong>a4</strong></td><td>x14</td><td>function argument</td></tr><tr><td><strong>a5</strong></td><td>x15</td><td>function argument</td></tr><tr><td><strong>a6</strong></td><td>x16</td><td>function argument</td></tr><tr><td><strong>a7</strong></td><td>x17</td><td>function argument</td></tr><tr><td><strong>s2</strong></td><td>x18</td><td>saved register</td></tr><tr><td><strong>s3</strong></td><td>x19</td><td>saved register</td></tr><tr><td><strong>s4</strong></td><td>x20</td><td>saved register</td></tr><tr><td><strong>s5</strong></td><td>x21</td><td>saved register</td></tr><tr><td><strong>s6</strong></td><td>x22</td><td>saved register</td></tr><tr><td><strong>s7</strong></td><td>x23</td><td>saved register</td></tr><tr><td><strong>s8</strong></td><td>x24</td><td>saved register</td></tr><tr><td><strong>s9</strong></td><td>x25</td><td>saved register</td></tr><tr><td><strong>s10</strong></td><td>x26</td><td>saved register</td></tr><tr><td><strong>s11</strong></td><td>x27</td><td>saved register</td></tr><tr><td><strong>t3</strong></td><td>x28</td><td>temporary</td></tr><tr><td><strong>t4</strong></td><td>x29</td><td>temporary</td></tr><tr><td><strong>t5</strong></td><td>x30</td><td>temporary</td></tr><tr><td><strong>t6</strong></td><td>x31</td><td>temporary</td></tr></tbody></table><p>Remember, your function can do what it likes with <strong>t</strong> and <strong>a</strong> registers, but must restore the state of other registers before returning. <strong>a0</strong> and <strong>a1</strong> are also used for function return values.</p><p>*The linker uses global and thread pointers for optimisation, you normally ignore them in your own assembler code.</p><h2 id=whats-next>What&rsquo;s Next?</h2><p>This is the latest post on <em>RISC-V Assembler</em>, but look out for more posts in future.</p><p>Previous parts of this series include: <a href=/posts/riscv-arithmetic/>Arithmetic</a>, <a href=/posts/riscv-load-store/>Load Store</a>, and <a href=/posts/riscv-shift/>Branch Set</a> instructions. Or check out my <a href=/tutorials/>FPGA & RISC-V Tutorials</a> and my series on early <a href=https://systemtalk.org/post/macintosh-history-8510/>Macintosh History</a>.</p><h3 id=references>References</h3><ul><li><a href=https://wiki.riscv.org/display/HOME/RISC-V+Technical+Specifications>RISC-V Technical Specifications</a> (riscv.org)</li></ul></section></article></main><footer class="opaco mx-auto flex h-[4.5rem] max-w-4xl items-center px-8 text-[0.9em] opacity-60"><div class=mr-auto><a class=link href=https://projectf.io/>Project F</a>: A little oasis for FPGA and RISC-V design.
&copy; 2024 Will Green.</div></footer></body></html>