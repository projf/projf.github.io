<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"  lang="en-gb">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<title>Verilog Vectors and Arrays | Project F: FPGA Dev</title>

<meta property='og:title' content='Verilog Vectors and Arrays - Project F: FPGA Dev'>
<meta property='og:description' content='Welcome back to my series covering mathematics and algorithms with FPGAs. In this part, we dig into vectors and arrays, including slicing, configurable widths, for loops, and bit and byte ordering.
This post is being written during December 2022 and January 2023.
New to the series? Start with Numbers in Verilog.
Get in touch: @WillFlux (Mastodon), @WillGreen (GitHub), or find me on 1BitSquared Discord.
Series Outline Numbers in Verilog - introduction to numbers in Verilog Vectors and Arrays (this post) - working with Verilog vectors and arrays Multiplication with DSPs - efficient multiplication with FPGA DSPs Fixed-Point Numbers in Verilog - precision without complexity More maths in 2023 Sponsor My Work'>
<meta property='og:url' content='https://projectf.io/posts/verilog-vectors-arrays/'>
<meta property='og:site_name' content='Project F: FPGA Dev'>
<meta property='og:type' content='article'><meta property='og:image' content='https://projectf.io/img/posts/verilog-vectors-arrays/social-card.png'><meta property='article:published_time' content='2022-12-13T00:00:00Z'><meta property='article:modified_time' content='2022-12-13T00:00:00Z'><meta name='twitter:card' content='summary_large_image'><meta name='twitter:site' content='@WillFlux'><meta name='twitter:creator' content='@WillFlux'>


<link href="https://projectf.io/index.xml" rel="alternate" type="application/rss+xml" title="Project F: FPGA Dev">

<link rel="stylesheet" href="/css/style.css"><link rel='stylesheet' href='https://projectf.io/css/custom.css'>

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
<link rel="canonical" href="https://projectf.io/posts/verilog-vectors-arrays/">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff">
</head>
<body>

<section class="section">
  <div class="container">
    <nav id="nav-main" class="nav">
      <div id="nav-name" class="nav-left">
        <a id="nav-anchor" class="nav-item" href="https://projectf.io">
          <h1 id="nav-heading" class="title is-4">Project F: FPGA Dev</h1>
        </a>
      </div>
      <div class="nav-right">
        <nav id="nav-items" class="nav-item level is-mobile"><a class="level-item" aria-label="github" href='https://github.com/projf/projf-explore'
            target='_blank' rel='me noopener'>
            <span class="icon">
              <i class><svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
    
    <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"/>
    
  </svg>
</i>
            </span>
          </a><a class="level-item" aria-label="mastodon" href='https://mastodon.social/@WillFlux'
            target='_blank' rel='me noopener'>
            <span class="icon">
              <i class><svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
    
    <path d="M 11.966876,0.80329086 C 9.1123466,0.82665791 6.3664935,1.1367094 4.7662978,1.8737549 c 0,0 -3.1736685,1.4237835 -3.1736685,6.2815982 0,1.1123884 -0.021554,2.4424309 0.013571,3.8529439 0.1152443,4.750677 0.8683725,9.432704 5.2479219,10.595273 2.0193066,0.53604 3.7531218,0.648348 5.1494078,0.571373 2.532141,-0.140797 3.953603,-0.906282 3.953603,-0.906282 l -0.08353,-1.842608 c 0,0 -1.809527,0.572181 -3.841713,0.50245 -2.013417,-0.06922 -4.138986,-0.217713 -4.4646269,-2.696937 -0.030082,-0.217772 -0.045075,-0.450712 -0.045075,-0.695267 0,0 1.9765387,0.484554 4.4813709,0.599656 1.531629,0.07049 2.9679,-0.08996 4.426746,-0.264563 2.797636,-0.335045 5.233581,-2.063856 5.539741,-3.643517 0.482392,-2.488386 0.442651,-6.0725219 0.442651,-6.0725219 0,-4.8578147 -3.173492,-6.2815982 -3.173492,-6.2815982 C 17.639136,1.1367094 14.891579,0.82669685 12.03704,0.80329086 Z"/>
  <path d="M 6.4286668,14.016701 V 9.1034254 c 0,-1.0041614 0.2549569,-1.8022059 0.7670342,-2.3925638 0.5280486,-0.590366 1.2196579,-0.8929946 2.0781049,-0.8929946 0.9931961,0 1.7452181,0.3828583 2.2425191,1.1486808 L 11.999859,7.7793695 12,11.451148 11.999859,7.7793695 12.483392,6.9665478 C 12.980596,6.2007253 13.732618,5.817867 14.72592,5.817867 c 0.858341,0 1.549951,0.3026286 2.078097,0.8929946 0.511971,0.5903579 0.766887,1.3884024 0.766887,2.3925638 v 4.9132756" />
    
  </svg>
</i>
            </span>
          </a><a class="level-item" aria-label="youtube" href='https://youtube.com/@projf'
            target='_blank' rel='me noopener'>
            <span class="icon">
              <i class><svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
    
    <path d="M22.54 6.42a2.78 2.78 0 0 0-1.94-2C18.88 4 12 4 12 4s-6.88 0-8.6.46a2.78 2.78 0 0 0-1.94 2A29 29 0 0 0 1 11.75a29 29 0 0 0 .46 5.33A2.78 2.78 0 0 0 3.4 19c1.72.46 8.6.46 8.6.46s6.88 0 8.6-.46a2.78 2.78 0 0 0 1.94-2 29 29 0 0 0 .46-5.25 29 29 0 0 0-.46-5.33z"/>
    <polygon points="9.75 15.02 15.5 11.75 9.75 8.48 9.75 15.02"/>
    
  </svg>
</i>
            </span>
          </a><a class="level-item" aria-label="rss" href='/index.xml'
            target='_blank' rel='me noopener'>
            <span class="icon">
              <i class><svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
    
    <path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle>
    
  </svg>
</i>
            </span>
          </a></nav>
      </div>
    </nav>

    <nav class="nav">
      
      <div class="nav-left"><a class="nav-item" href="/about">
          <h2 class="title is-5">About</h2>
        </a><a class="nav-item" href="/demos">
          <h2 class="title is-5">Demos</h2>
        </a><a class="nav-item" href="/howto">
          <h2 class="title is-5">How To</h2>
        </a><a class="nav-item" href="/tags/news">
          <h2 class="title is-5">News</h2>
        </a><a class="nav-item" href="/tutorials">
          <h2 class="title is-5">Tutorials</h2>
        </a><a class="nav-item" href="/verilog-lib">
          <h2 class="title is-5">Verilog Lib</h2>
        </a></div>
      

      
    </nav>

  </div>
  <script src="/js/navicon-shift.js"></script>
</section>

<section class="section">
  <div class="container">
    <div class="subtitle tags is-6 is-pulled-right">
      
      
<a class="subtitle is-6" href="/tags/maths/">#maths</a>




      
    </div>
    <h2 class="subtitle is-6">13 December 2022</h2>
    <h1 class="title">Verilog Vectors and Arrays</h1>
    
    <div class="content">
      <p>Welcome back to my series covering mathematics and algorithms with FPGAs. In this part, we dig into vectors and arrays, including slicing, configurable widths, for loops, and bit and byte ordering.</p>
<p><strong>This post is being written during December 2022 and January 2023.</strong></p>
<p>New to the series? Start with <a href="/posts/numbers-in-verilog/">Numbers in Verilog</a>.</p>
<p><em>Get in touch: <a href="https://mastodon.social/@WillFlux">@WillFlux</a> (Mastodon), <a href="https://github.com/WillGreen">@WillGreen</a> (GitHub), or find me on <a href="https://discord.gg/cf869yDbXf">1BitSquared Discord</a>.</em></p>
<h3 id="series-outline">Series Outline</h3>
<ul>
<li><a href="/posts/numbers-in-verilog">Numbers in Verilog</a> - introduction to numbers in Verilog</li>
<li>Vectors and Arrays (this post) - working with Verilog vectors and arrays</li>
<li><a href="/posts/multiplication-fpga-dsps">Multiplication with DSPs</a> - efficient multiplication with FPGA DSPs</li>
<li><a href="/posts/fixed-point-numbers-in-verilog/">Fixed-Point Numbers in Verilog</a> - precision without complexity</li>
<li><em>More maths in 2023</em></li>
</ul>
<blockquote>
<p><strong>Sponsor My Work</strong><br>
If you like what I do, consider <a href="https://github.com/sponsors/WillGreen">sponsoring me</a> on GitHub.<br>
I love FPGAs and want to help more people discover and use them in their projects.<br>
My hardware designs are open source, and my blog is advert free.</p>
</blockquote>
<h2 id="what-is-a-vector">What is a Vector?</h2>
<p>A quick recap from <a href="/posts/numbers-in-verilog">Numbers in Verilog</a>:</p>
<p>By default, a Verilog register or wire is 1 bit wide. This is a <strong>scalar</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#66d9ef">wire</span>  x;  <span style="color:#75715e">// 1 bit wire
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">reg</span>   y;  <span style="color:#75715e">// also 1 bit
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">logic</span> z;  <span style="color:#75715e">// me too!
</span></span></span></code></pre></div><p>A scalar can only hold 0 or 1<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>.</p>
<p>We need a <strong>vector</strong> to hold something larger.</p>
<p>A vector is declared like this: <code>type [upper:lower] name;</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#66d9ef">wire</span>   [<span style="color:#ae81ff">5</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] a;  <span style="color:#75715e">// 6-bit wire
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">reg</span>    [<span style="color:#ae81ff">7</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] b;  <span style="color:#75715e">// 8-bit reg
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">logic</span> [<span style="color:#ae81ff">11</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] c;  <span style="color:#75715e">// 12-bit logic
</span></span></span></code></pre></div><p><code>a</code>, <code>b</code>, and <code>c</code> are vectors:</p>
<ul>
<li>Wire <strong>a</strong> handles 0-63 inclusive (2<sup>6</sup> is 64).</li>
<li>Register <strong>b</strong> handles 0-255 inclusive (2<sup>8</sup> is 256).</li>
<li>Logic <strong>c</strong> handles 0-4095 inclusive (2<sup>12</sup> is 4096).</li>
</ul>
<p>With that recap out of the way, let&rsquo;s look at some things we can do with vectors.</p>
<h2 id="slicing-vectors">Slicing Vectors</h2>
<p>You select an individual bit using its index; for example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#66d9ef">wire</span> [<span style="color:#ae81ff">3</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] n;  <span style="color:#75715e">// 4-bit wire vector
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">wire</span> p, q;     <span style="color:#75715e">// wire scalars
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">always_comb</span> <span style="color:#66d9ef">begin</span>
</span></span><span style="display:flex;"><span>    p <span style="color:#f92672">=</span> n[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>    q <span style="color:#f92672">=</span> n[<span style="color:#ae81ff">3</span>];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span></code></pre></div><p>You select a subset by specifying the start and end bits:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#66d9ef">wire</span> [<span style="color:#ae81ff">11</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] a;       <span style="color:#75715e">// 12-bit wire vector
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">wire</span> [<span style="color:#ae81ff">3</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] x, y, z;  <span style="color:#75715e">// 4-bit wire vectors
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">always_comb</span> <span style="color:#66d9ef">begin</span>
</span></span><span style="display:flex;"><span>    x <span style="color:#f92672">=</span> a[<span style="color:#ae81ff">11</span><span style="color:#f92672">:</span><span style="color:#ae81ff">8</span>];
</span></span><span style="display:flex;"><span>    y <span style="color:#f92672">=</span> a[<span style="color:#ae81ff">7</span><span style="color:#f92672">:</span><span style="color:#ae81ff">4</span>];
</span></span><span style="display:flex;"><span>    z <span style="color:#f92672">=</span> a[<span style="color:#ae81ff">3</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span></code></pre></div><p>You can also use the concat operator <code>{}</code> to select bits from vectors. The following example is equivalent to the one above:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#66d9ef">wire</span> [<span style="color:#ae81ff">11</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] a;       <span style="color:#75715e">// 12-bit wire vector
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">wire</span> [<span style="color:#ae81ff">3</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] x, y, z;  <span style="color:#75715e">// 4-bit wire vectors
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">always_comb</span> <span style="color:#66d9ef">begin</span>
</span></span><span style="display:flex;"><span>    {x,y,z} <span style="color:#f92672">=</span> a;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span></code></pre></div><p>Rather than specify an end bit, you can specify a width with <code>-</code> and <code>+</code>.</p>
<p>These three assignments all select the same four bits:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#66d9ef">wire</span> [<span style="color:#ae81ff">11</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] a;       <span style="color:#75715e">// 12-bit wire vector
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">wire</span> [<span style="color:#ae81ff">3</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] x, y, z;  <span style="color:#75715e">// 4-bit wire vectors
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">always_comb</span> <span style="color:#66d9ef">begin</span>
</span></span><span style="display:flex;"><span>    x <span style="color:#f92672">=</span> a[<span style="color:#ae81ff">11</span><span style="color:#f92672">:</span><span style="color:#ae81ff">8</span>];   <span style="color:#75715e">// 11:8
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    y <span style="color:#f92672">=</span> a[<span style="color:#ae81ff">11</span><span style="color:#f92672">-:</span><span style="color:#ae81ff">4</span>];  <span style="color:#75715e">// also 11:8
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    z <span style="color:#f92672">=</span> a[<span style="color:#ae81ff">8</span><span style="color:#f92672">+:</span><span style="color:#ae81ff">4</span>];   <span style="color:#75715e">// also 11:8
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">end</span>
</span></span></code></pre></div><p><em>ProTip: The start bit can be a variable, but not the width.</em></p>
<h3 id="loss-of-sign">Loss of Sign</h3>
<p>With signed variables, using slices will make the value unsigned, even if you select the whole range!</p>
<p>However, you can force a variable to be signed with the <code>$signed</code> system function:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#66d9ef">wire</span> <span style="color:#66d9ef">signed</span> [<span style="color:#ae81ff">11</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] a <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">64</span>;  <span style="color:#75715e">// 12-bit signed wire vector
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">initial</span> <span style="color:#66d9ef">begin</span>
</span></span><span style="display:flex;"><span>    $display(<span style="color:#e6db74">&#34;a is signed:   %d&#34;</span>, a);
</span></span><span style="display:flex;"><span>    $display(<span style="color:#e6db74">&#34;a is unsigned:  %d&#34;</span>, a[<span style="color:#ae81ff">11</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>]);
</span></span><span style="display:flex;"><span>    $display(<span style="color:#e6db74">&#34;a is signed:   %d&#34;</span>, $signed(a[<span style="color:#ae81ff">11</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>]));
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span></code></pre></div><p>Produces the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>a is signed:     -64
</span></span><span style="display:flex;"><span>a is unsigned:  4032
</span></span><span style="display:flex;"><span>a is signed:     -64
</span></span></code></pre></div><p><code>$signed</code> is no panacea: <a href="/posts/numbers-in-verilog#signed-expressions">sign extension</a> can still catch you out.</p>
<h2 id="configurable-widths">Configurable Widths</h2>
<p>Avoid hard-coding vector widths; it limits your design flexibility.</p>
<p>Parameters provide a simple way to configure vector widths:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#66d9ef">parameter</span> ADDRW<span style="color:#f92672">=</span><span style="color:#ae81ff">16</span>;  <span style="color:#75715e">// address width: 16 bits for 2^16 memory locations
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">logic</span> [ADDRW<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] addr_read;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">logic</span> [ADDRW<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] addr_write;
</span></span></code></pre></div><p>The width of a vector often depends on another parameter, so calculating it yourself isn&rsquo;t ideal.</p>
<p>Imagine you&rsquo;re creating a game engine where the number of sprites is configurable:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#66d9ef">parameter</span> SPR_CNT<span style="color:#f92672">=</span><span style="color:#ae81ff">10</span>;   <span style="color:#75715e">// maximum number of sprites on screen
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">logic</span> [<span style="color:#ae81ff">3</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] sprite_id;  <span style="color:#75715e">// 4 bits is correct for a count of 10, but if SPR_CNT changes?
</span></span></span></code></pre></div><p>Changing the sprite count will break the design if we hardcode the width.</p>
<p>Verilog 2005 introduced <code>$clog2</code> to handle this.</p>
<h3 id="calculating-widths">Calculating Widths</h3>
<p>The <code>$clog2</code> function returns the ceiling of the logarithm to base 2.</p>
<p>For example, <code>$clog2(10) = 4</code> because 2<sup>3</sup> &lt; 10 ≤ 2<sup>4</sup>.</p>
<p>If you need to handle N things (such as sprites or memory locations), then <code>$clog2(N)</code> will tell you how wide your vector needs to be:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#66d9ef">parameter</span> SPR_CNT<span style="color:#f92672">=</span><span style="color:#ae81ff">10</span>;  <span style="color:#75715e">// maximum number of sprites on screen
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">parameter</span> SPR_BITW<span style="color:#f92672">=</span>$clog2(SPR_CNT);  <span style="color:#75715e">// sprite ID bit width
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">logic</span> [SPR_BITW<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] sprite_id;  <span style="color:#75715e">// sprite identifier
</span></span></span></code></pre></div><p><code>$clog2</code> is handy, but you need to be careful.</p>
<p>If you&rsquo;re specifying a maximum value (rather than a count), it doesn&rsquo;t do what you want:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#66d9ef">parameter</span> MAX_VOLTAGE<span style="color:#f92672">=</span><span style="color:#ae81ff">256</span>;  <span style="color:#75715e">// maximum voltage
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">parameter</span> VOLTW<span style="color:#f92672">=</span>$clog2(MAX_VOLTAGE);  <span style="color:#75715e">// voltage bit width (INCORRECT!)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">logic</span> [VOLTW<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] volatage;  <span style="color:#75715e">// we can&#39;t handle 256!
</span></span></span></code></pre></div><p><code>$clog2</code> returns &lsquo;8&rsquo;, giving a voltage range of 0-255 inclusive. 256 is out of range.</p>
<p>If you&rsquo;re specifying a maximum value, you need to add one to the value passed to <code>$clog2</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#66d9ef">parameter</span> MAX_VOLTAGE<span style="color:#f92672">=</span><span style="color:#ae81ff">256</span>;  <span style="color:#75715e">// maximum voltage
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">parameter</span> VOLTW<span style="color:#f92672">=</span>$clog2(MAX_VOLTAGE<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);  <span style="color:#75715e">// voltage bit width (add one for max)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">logic</span> [VOLTW<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] volatage;  <span style="color:#75715e">// we can now handle 256 volts :)
</span></span></span></code></pre></div><p>This problem is often hidden because it doesn&rsquo;t occur if your parameter isn&rsquo;t a power of 2. For example, if you specify &lsquo;240&rsquo; as your <code>MAX_VOLTAGE</code>, you won&rsquo;t see any issues. Later, you increase <code>MAX_VOLTAGE</code> to &lsquo;256&rsquo;, and the design has a subtle bug.</p>
<h2 id="a-bit-significant">A Bit Significant</h2>
<p>Earlier, we said a vector was declared like this: <code>type [upper:lower] name;</code></p>
<p>A more general definition is: <code>type [msb_index:lsb_index] name;</code><br>
Where <em>msb_index</em> is the most significant bit index, and <em>lsb_index</em> is the least significant bit index.</p>
<p>The usual way of declaring vectors has the least significant bit at the lowest index (LSB first):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#66d9ef">wire</span>   [<span style="color:#ae81ff">5</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] a;  <span style="color:#75715e">// 6-bit wire (LSB first)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">reg</span>   [<span style="color:#ae81ff">11</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] b;  <span style="color:#75715e">// 12-bit reg (LSB first)
</span></span></span></code></pre></div><p>The most significant bit of <code>a</code> is stored in <code>a[5]</code> and that of <code>b</code> in <code>b[11]</code>.</p>
<p>Alternatively, we can declare vectors with the most significant bit at the lowest index (MSB first):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#66d9ef">wire</span>   [<span style="color:#ae81ff">0</span><span style="color:#f92672">:</span><span style="color:#ae81ff">5</span>] c;  <span style="color:#75715e">// 6-bit wire (MSB first)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">reg</span>   [<span style="color:#ae81ff">0</span><span style="color:#f92672">:</span><span style="color:#ae81ff">11</span>] d;  <span style="color:#75715e">// 12-bit reg (MSB first)
</span></span></span></code></pre></div><p>The most significant bit of <code>c</code> is stored in <code>c[0]</code> and that of <code>d</code> in <code>d[0]</code>.</p>
<h3 id="switching-ends">Switching Ends</h3>
<p>MSB-first vectors are comparatively rare in Verilog. However, some hardware interfaces send the most significant bit first, for example, I<sup>2</sup>C.</p>
<p>Say you&rsquo;ve got an MSB first byte from I<sup>2</sup>C and want to convert it to LSB first.</p>
<p>You could try directly swapping the order:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#66d9ef">wire</span> [<span style="color:#ae81ff">0</span><span style="color:#f92672">:</span><span style="color:#ae81ff">7</span>] i2c_x;  <span style="color:#75715e">// 8-bit wire (MSB first)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">reg</span>  [<span style="color:#ae81ff">7</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] x;      <span style="color:#75715e">// 8-bit reg (LSB first)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">always_ff</span> @(<span style="color:#66d9ef">posedge</span> clk) x <span style="color:#f92672">&lt;=</span> i2c_x;  <span style="color:#75715e">// Doesn&#39;t work in all tools :(
</span></span></span></code></pre></div><p>Alas, some tools won&rsquo;t let you mix LSB- and MSB-first vectors in one expression.</p>
<p>A more general approach is to reverse the bits explicitly. All bits are swapped in parallel:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#66d9ef">always_ff</span> @(<span style="color:#66d9ef">posedge</span> clk) <span style="color:#66d9ef">begin</span>
</span></span><span style="display:flex;"><span>    x[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&lt;=</span> i2c_x[<span style="color:#ae81ff">7</span>];
</span></span><span style="display:flex;"><span>    x[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">&lt;=</span> i2c_x[<span style="color:#ae81ff">6</span>];
</span></span><span style="display:flex;"><span>    x[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">&lt;=</span> i2c_x[<span style="color:#ae81ff">5</span>];
</span></span><span style="display:flex;"><span>    x[<span style="color:#ae81ff">3</span>] <span style="color:#f92672">&lt;=</span> i2c_x[<span style="color:#ae81ff">4</span>];
</span></span><span style="display:flex;"><span>    x[<span style="color:#ae81ff">4</span>] <span style="color:#f92672">&lt;=</span> i2c_x[<span style="color:#ae81ff">3</span>];
</span></span><span style="display:flex;"><span>    x[<span style="color:#ae81ff">5</span>] <span style="color:#f92672">&lt;=</span> i2c_x[<span style="color:#ae81ff">2</span>];
</span></span><span style="display:flex;"><span>    x[<span style="color:#ae81ff">6</span>] <span style="color:#f92672">&lt;=</span> i2c_x[<span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>    x[<span style="color:#ae81ff">7</span>] <span style="color:#f92672">&lt;=</span> i2c_x[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span></code></pre></div><p>Updating individual bits is tedious, but a <code>for</code> loop can handle this for us:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#66d9ef">always_ff</span> @(<span style="color:#66d9ef">posedge</span> clk) <span style="color:#66d9ef">begin</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">8</span>; i<span style="color:#f92672">=</span>i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>) x[i] <span style="color:#f92672">&lt;=</span> i2c_x[<span style="color:#ae81ff">7</span><span style="color:#f92672">-</span>i];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span></code></pre></div><p>Verilog <code>for</code> is NOT like a software loop: this <code>for</code> loop is unrolled into parallel bit swaps.</p>
<h2 id="big-endian-little-endian">Big Endian, Little Endian</h2>
<p>So far, we&rsquo;ve been talking about ordering at the bit level, but it also occurs in the context of bytes. If you have a 32-bit word, do you store the least significant byte at the lowest address (little-endian) or the most significant byte at the lowest address (big-endian)?</p>
<p>RISC-V, x86, and ARM are little-endian, while Internet protocols (TCP/IP) and Motorola 68K are big-endian. There&rsquo;s also the cursed middle-endian, but I won&rsquo;t discuss that here.</p>
<p><em>Being written January 2023.</em></p>
<h2 id="arrays">Arrays</h2>
<p><em>Being written January 2023.</em></p>
<h2 id="next-time">Next Time</h2>
<p>Part three covers <a href="/posts/multiplication-fpga-dsps">Multiplication with DSPs</a> or jump ahead to <a href="/posts/fixed-point-numbers-in-verilog">Fixed-Point Numbers</a>.</p>
<p>You can also check out our other maths posts: <a href="/posts/division-in-verilog/">division</a>, <a href="/posts/square-root-in-verilog/">square root</a>, and <a href="/posts/fpga-sine-table/">sine &amp; cosine</a>.</p>
<p><em>Get in touch: <a href="https://mastodon.social/@WillFlux">@WillFlux</a> (Mastodon), <a href="https://github.com/WillGreen">@WillGreen</a> (GitHub), or find me on <a href="https://discord.gg/cf869yDbXf">1BitSquared Discord</a>.</em></p>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>We&rsquo;re ignoring X and Z for the purpose of this introduction. See <a href="/posts/numbers-in-verilog/">Numbers in Verilog</a>.&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>

      
    </div>
    
  </div>
</section>

    <script src="/js/copycode.js"></script>



<section class="section">
  <div class="container has-text-centered">
    <p>©2023 Will Green, Project F</p>
    
  </div>
</section>


<script src="https://badgers.projectf.io/script.js" data-site="EVCGKVDN" defer></script>



</body>
</html>

