<!doctype html><html class="not-ready lg:text-base" style=--bg:#fff lang=en-gb><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>RISC-V Assembler: Branch Set - Project F</title>
<meta name=theme-color><meta name=description content="This RISC-V assembler post covers branch and set instructions, such as beq, bltu, bgez, and slt. We&rsquo;ll also cover the zero register, program counter, condition codes, and multi-word addition."><meta name=author content="Will Green"><link rel="preload stylesheet" as=style href=https://projectf.io/main.min.css><link rel=preload as=image href=https://projectf.io/theme.png><link rel=preload as=image href=https://projectf.io/rss.svg><script defer src=https://projectf.io/highlight.min.js onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://projectf.io/favicon.ico><link rel=apple-touch-icon href=https://projectf.io/apple-touch-icon.png><meta name=generator content="Hugo 0.128.2"><script src=https://cdn-eu.usefathom.com/script.js data-site=EVCGKVDN defer></script><meta itemprop=name content="RISC-V Assembler: Branch Set"><meta itemprop=description content="This RISC-V assembler post covers branch and set instructions, such as beq, bltu, bgez, and slt. We’ll also cover the zero register, program counter, condition codes, and multi-word addition."><meta itemprop=datePublished content="2024-03-19T00:00:00+00:00"><meta itemprop=dateModified content="2024-09-17T00:00:00+00:00"><meta itemprop=wordCount content="2077"><meta itemprop=image content="https://projectf.io/posts/riscv-branch-set/img/social/riscv-branch-set.jpeg"><meta itemprop=keywords content="Asm,Riscv"><meta property="og:url" content="https://projectf.io/posts/riscv-branch-set/"><meta property="og:site_name" content="Project F"><meta property="og:title" content="RISC-V Assembler: Branch Set"><meta property="og:description" content="This RISC-V assembler post covers branch and set instructions, such as beq, bltu, bgez, and slt. We’ll also cover the zero register, program counter, condition codes, and multi-word addition."><meta property="og:locale" content="en_gb"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-03-19T00:00:00+00:00"><meta property="article:modified_time" content="2024-09-17T00:00:00+00:00"><meta property="article:tag" content="Asm"><meta property="article:tag" content="Riscv"><meta property="og:image" content="https://projectf.io/posts/riscv-branch-set/img/social/riscv-branch-set.jpeg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://projectf.io/posts/riscv-branch-set/img/social/riscv-branch-set.jpeg"><meta name=twitter:title content="RISC-V Assembler: Branch Set"><meta name=twitter:description content="This RISC-V assembler post covers branch and set instructions, such as beq, bltu, bgez, and slt. We’ll also cover the zero register, program counter, condition codes, and multi-word addition."><link rel=canonical href=https://projectf.io/posts/riscv-branch-set/></head><body class="text-black duration-200 ease-out dark:text-white"><header class="mx-auto flex h-[4.5rem] max-w-4xl px-8 lg:justify-center"><div class="relative z-50 mr-auto flex items-center"><a class="-translate-x-[1px] -translate-y-[1px] text-2xl font-semibold" href=https://projectf.io/>Project F</a><div class="btn-dark text-[0] ml-4 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.png)_left_center/_auto_theme('spacing.6')_no-repeat] [transition:_background-position_0.4s_steps(5)] dark:[background-position:right]" role=button aria-label=Dark></div></div><div class="btn-menu relative z-50 -mr-8 flex h-[4.5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden" role=button aria-label=Menu></div><script>const htmlClass=document.documentElement.classList;setTimeout(()=>{htmlClass.remove("not-ready")},10);const btnMenu=document.querySelector(".btn-menu");btnMenu.addEventListener("click",()=>{htmlClass.toggle("open")});const metaTheme=document.querySelector('meta[name="theme-color"]'),lightBg="#fff".replace(/"/g,""),setDark=e=>{metaTheme.setAttribute("content",e?"#000":lightBg),htmlClass[e?"add":"remove"]("dark"),localStorage.setItem("dark",e)},darkScheme=window.matchMedia("(prefers-color-scheme: dark)");if(htmlClass.contains("dark"))setDark(!0);else{const e=localStorage.getItem("dark");setDark(e?e==="true":darkScheme.matches)}darkScheme.addEventListener("change",e=>{setDark(e.matches)});const btnDark=document.querySelector(".btn-dark");btnDark.addEventListener("click",()=>{setDark(localStorage.getItem("dark")!=="true")})</script><div class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full select-none flex-col justify-center pb-16 duration-200 dark:bg-black lg:static lg:h-auto lg:flex-row lg:!bg-transparent lg:pb-0 lg:transition-none"><nav class="lg:ml-12 lg:flex lg:flex-row lg:items-center lg:space-x-6"><a class="block text-center text-2xl leading-[5rem] lg:text-base lg:font-normal" href=/about/>About</a>
<a class="block text-center text-2xl leading-[5rem] lg:text-base lg:font-normal" href=/demos/>Demos</a>
<a class="block text-center text-2xl leading-[5rem] lg:text-base lg:font-normal" href=/verilog-lib/>Lib</a>
<a class="block text-center text-2xl leading-[5rem] lg:text-base lg:font-normal" href=/tools/>Tools</a>
<a class="block text-center text-2xl leading-[5rem] lg:text-base lg:font-normal" href=/tutorials/>Tutorials</a></nav><nav class="mt-12 flex justify-center space-x-10 dark:invert lg:ml-12 lg:mt-0 lg:items-center lg:space-x-6"><a class="h-8 w-8 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./rss.svg) href=https://projectf.io/index.xml target=_blank rel=alternate>rss</a></nav></div></header><main class="prose prose-neutral relative mx-auto min-h-[calc(100%-9rem)] max-w-4xl px-8 pb-4 pt-4 dark:prose-invert"><article><header class=mb-4><h1 class="!my-0 pb-2.5">RISC-V Assembler: Branch Set</h1><div class="text-sm antialiased opacity-60">Published
<time>19 Mar 2024</time>
<span class=mx-1>&#183;</span>
<span>Updated
<time>17 Sep 2024</time></span></div></header><section><p>This RISC-V assembler post covers branch and set instructions, such as <strong>beq</strong>, <strong>bltu</strong>, <strong>bgez</strong>, and <strong>slt</strong>. RISC-V takes a different approach to branching, even compared to other RISC processors. We&rsquo;ll also cover the zero register, program counter, condition codes, and multi-word addition. Branch and set instructions are included in RV32I, the base integer instruction set. You can also check out my other <a href=/tags/riscv>RISC-V</a> posts.</p><p>In the last few years, we&rsquo;ve seen an explosion of RISC-V CPU designs, especially on FPGA. Thankfully, RISC-V is ideal for assembly programming with its compact, easy-to-learn instruction set. This series will help you learn and understand 32-bit RISC-V instructions and programming.</p><h2 id=branch>Branch</h2><p>Conditional branches control the flow of execution in a program. A conditional branch jumps to another program address if a condition is true. In high-level programming languages, this can take the form of a for-loop, if-then-else, or switch/case statement.</p><p>RISC-V is unusual because branch instructions include the comparison and branch target in one instruction. This makes branching simple and fast, but it has trade-offs, which we will consider later.</p><p>Let&rsquo;s start by looking at the six regular branch instructions:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>beq</span>   <span style=color:#75715e># equal
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>bne</span>   <span style=color:#75715e># not equal
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>blt</span>   <span style=color:#75715e># less than
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>bgt</span>   <span style=color:#75715e># greater than
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>ble</span>   <span style=color:#75715e># less than or equal to
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>bge</span>   <span style=color:#75715e># greater than or equal to
</span></span></span></code></pre></div><p>Branch instructions have a consistent format and always <strong>compare two registers</strong>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>branch</span> <span style=color:#66d9ef>rs1</span>, <span style=color:#66d9ef>rs2</span>, <span style=color:#66d9ef>imm</span>
</span></span></code></pre></div><p>Where <strong>rs1</strong> and <strong>rs2</strong> are the registers to compare, and <strong>imm</strong> is the immediate offset to the <strong>program counter</strong> (discussed shortly).</p><p>These instructions use <strong>signed comparisons</strong>: a register with the contents <code>0xFFFFFFFF</code> is treated as <code>-1</code>. We&rsquo;ll cover unsigned comparisons in the next section.</p><p>Branch offsets are signed 12-bit immediates but in units of <strong>two bytes</strong>. RISC-V instructions are four bytes long, so why are offsets in units of two bytes? Compressed instructions (to be covered in a future post) are only two bytes long, so branch offsets need to be in units of two bytes.</p><p>Offsets are sign extended, so you can easily branch backwards in your code. With 12-bit offsets in units of two bytes, branch instructions have a range of ±4 KiB.</p><p>In practice, you never write an offset directly; you use a <strong>label</strong> instead.</p><p>For example, we can create a wait loop with <strong>bne</strong>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span>    <span style=color:#a6e22e>li</span>  <span style=color:#66d9ef>t0</span>, <span style=color:#ae81ff>1000</span>  <span style=color:#75715e># time to wait
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>.L_timer:  <span style=color:#75715e># local label
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>lw</span>  <span style=color:#66d9ef>t1</span>, <span style=color:#66d9ef>TIMER_WAIT</span>(<span style=color:#66d9ef>t6</span>)  <span style=color:#75715e># load hardware timer into t1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>bne</span> <span style=color:#66d9ef>t0</span>, <span style=color:#66d9ef>t1</span>, <span style=color:#66d9ef>.L_timer</span>    <span style=color:#75715e># branch (loop) if t1 isn&#39;t equal to t0
</span></span></span></code></pre></div><p><em>ProTip: <code>.L_name</code> is a common naming convention for local labels.</em></p><p>Some of these branch instructions are pseudoinstructions, but this doesn&rsquo;t matter to you as a programmer: they always assemble to one instruction. For example, <strong>bgt</strong> (greater than) assembles to <strong>blt</strong> (less than) with the source registers swapped. Use whichever branch instruction you prefer, and let the assembler worry about the underlying instruction.</p><h2 id=branch-unsigned>Branch Unsigned</h2><p>If your numbers are unsigned, add a &ldquo;u&rdquo; to the end of the instruction name:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>bltu</span>  <span style=color:#75715e># less than unsigned
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>bgtu</span>  <span style=color:#75715e># greater than unsigned
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>bleu</span>  <span style=color:#75715e># less than or equal to unsigned
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>bgeu</span>  <span style=color:#75715e># greater than or equal to unsigned
</span></span></span></code></pre></div><p>Equal and not equal aren&rsquo;t affected by sign, so there aren&rsquo;t unsigned versions of them.</p><p>With unsigned comparison, a register with the contents <code>0xFFFFFFFF</code> is treated as <code>4294967295</code>.</p><h2 id=branch-zero>Branch Zero</h2><p>You often want to compare a register to zero, for example, to check for the end of a loop or null-terminated string. RISC-V provides a set of handy pseudoinstructions for this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>beqz</span>  <span style=color:#75715e># equal to zero
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>bnez</span>  <span style=color:#75715e># not equal to zero
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>bltz</span>  <span style=color:#75715e># less than zero
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>bgtz</span>  <span style=color:#75715e># greater than zero
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>blez</span>  <span style=color:#75715e># less than or equal to zero
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>bgez</span>  <span style=color:#75715e># greater than or equal to zero
</span></span></span></code></pre></div><p>They&rsquo;re the same as the regular branch instructions with a &ldquo;z&rdquo; at the end of the instruction name.</p><p>With these instructions, you only specify a single register because the second register is <strong>x0</strong>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>beqz</span> <span style=color:#66d9ef>rs1</span>, <span style=color:#66d9ef>imm</span>
</span></span></code></pre></div><p>For example, you could implement the <a href=https://en.wikipedia.org/wiki/Absolute_value>absolute</a> function with <strong>bgez</strong>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span>abs:
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>bgez</span> <span style=color:#66d9ef>a0</span>, <span style=color:#66d9ef>.L_abs_end</span>  <span style=color:#75715e># branch to .L_abs_end if a0 is greater or equal to zero
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>neg</span> <span style=color:#66d9ef>a0</span>, <span style=color:#66d9ef>a0</span>  <span style=color:#75715e># make negative a0 value positive
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>.L_abs_end:
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ret</span>  <span style=color:#75715e># return from function (a0 holds the return value)
</span></span></span></code></pre></div><p>We cover the <strong>neg</strong> instruction under <a href=/posts/riscv-arithmetic/#subtraction>subtraction</a> and learn about <a href=/posts/riscv-jump-function/#functions>calling functions</a> in the next post.</p><h3 id=the-power-of-zero>The Power of Zero</h3><p>RISC-V dedicates the <strong>zero</strong> (<strong>x0</strong>) register to the number zero. At first glance, this appears wasteful, but zero is used in many places and having it permanently available simplifies the instruction set. Other architectures, such as MIPS and ARM64, have a zero register, and mainframe computers, such as the <a href=https://en.wikipedia.org/wiki/CDC_6600>CDC 6600</a> and <a href=https://en.wikipedia.org/wiki/IBM_System/360>IBM System/360</a> used a zero register in the 1960s!</p><p>As we&rsquo;ve seen, many branch pseudoinstructions use the zero register, but you&rsquo;ll find the zero register used across RISC-V.</p><h2 id=branch-instruction-summary>Branch Instruction Summary</h2><p>The following table summarises all 16 RISC-V branch (pseudo)instructions:</p><table><thead><tr><th>Comparison</th><th>Registers</th><th>Signed</th><th>Unsigned</th><th>Zero</th></tr></thead><tbody><tr><td>equal (<strong>eq</strong>)</td><td>rs1 = rs2</td><td>beq</td><td>beq</td><td>beqz</td></tr><tr><td>not equal (<strong>ne</strong>)</td><td>rs1 ≠ rs2</td><td>bne</td><td>bne</td><td>bnez</td></tr><tr><td>less than (<strong>lt</strong>)</td><td>rs1 &lt; rs2</td><td>blt</td><td>bltu</td><td>bltz</td></tr><tr><td>greater than (<strong>gt</strong>)</td><td>rs1 > rs2</td><td>bgt</td><td>bgtu</td><td>bgtz</td></tr><tr><td>less or equal (<strong>le</strong>)</td><td>rs1 ≤ rs2</td><td>ble</td><td>bleu</td><td>blez</td></tr><tr><td>greater or equal (<strong>ge</strong>)</td><td>rs1 ≥ rs2</td><td>bge</td><td>bgeu</td><td>bgez</td></tr></tbody></table><p><em>NB. equal and not equal are the same for signed and unsigned comparisons.</em></p><h2 id=program-counter>Program Counter</h2><p>Branch offsets are relative to the <strong>program counter</strong> (PC). The CPU uses the program counter to track its location in the code, for example when fetching the next instruction. Usually, the CPU adds four to the PC during instruction execution: addresses are in bytes, and each RISC-V instruction is four bytes long. When a branch is taken, the CPU updates the program counter to point to the branch target address instead.</p><p>Learn more about <a href=/posts/riscv-load-store/#memory-addresses>memory addresses, alignment, and addressing modes</a>.</p><p><em>ProTip: In x86 land, the PC is known as the instruction pointer (IP), a much more descriptive name.</em></p><h3 id=auipc>auipc</h3><p>The program counter is also used to calculate the address of memory locations. RISC-V includes an instruction to help with <a href=https://en.wikipedia.org/wiki/Position-independent_code>position-independent code</a>: <strong>auipc</strong> (add upper immediate to PC). <strong>auipc</strong> works just like <strong>lui</strong> (load upper immediate) but adds a 20-bit immediate value to the program counter.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>auipc</span> <span style=color:#66d9ef>rd</span>, <span style=color:#66d9ef>imm</span>  <span style=color:#75715e># rd = pc + imm &lt;&lt; 12
</span></span></span></code></pre></div><p>With <strong>auipc</strong>, you can use PC-relative addressing to reach a symbol anywhere in 32-bit memory space. For example, combine <strong>auipc</strong> and <a href=/posts/riscv-load-store/>load</a> instructions to load data from a distant memory location or <strong>auipc</strong> and <a href=/posts/riscv-jump-function/#functions>jalr</a> to far call a function.</p><p>The program counter (<strong>pc</strong>) is not one of the general-purpose registers, so you can&rsquo;t access it directly. However, you can copy the <strong>pc</strong> register using <strong>auipc</strong> with an immediate of zero:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>auipc</span> <span style=color:#66d9ef>t0</span>, <span style=color:#ae81ff>0</span>  <span style=color:#75715e># copy program counter into register t0
</span></span></span></code></pre></div><h2 id=set>Set</h2><p>Earlier, we noted that RISC-V combines comparison and branching into a single instruction. However, sometimes you want to compare then do something other than branch.</p><p>Most CPUs set condition codes or status flags such as <a href=https://en.wikipedia.org/wiki/Zero_flag>zero</a>, <a href=https://en.wikipedia.org/wiki/Carry_flag>carry</a>, and <a href=https://en.wikipedia.org/wiki/Overflow_flag>overflow</a> based on the result of arithmetic or a dedicated compare instruction. These condition codes can be used for branching, but also for arithmetic and general comparisons.</p><p>RISC-V doesn&rsquo;t have condition codes, but the <strong>set</strong> instructions can handle many of the same situations, such as checking for zero, carry, or overflow. Set instructions compare two registers or a register to an immediate and write <strong>1</strong> to the destination register if true.</p><p>There are only four set instructions, all variants of <strong>set less than</strong>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>slt</span>  <span style=color:#66d9ef>rd</span>, <span style=color:#66d9ef>rs1</span>, <span style=color:#66d9ef>rs2</span>  <span style=color:#75715e># set less than:                     rd = rs1 &lt; rs2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>sltu</span> <span style=color:#66d9ef>rd</span>, <span style=color:#66d9ef>rs1</span>, <span style=color:#66d9ef>rs2</span>  <span style=color:#75715e># set less than unsigned:            rd = rs1 &lt; rs2 (unsigned)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>slti</span>  <span style=color:#66d9ef>rd</span>, <span style=color:#66d9ef>rs</span>, <span style=color:#66d9ef>imm</span>  <span style=color:#75715e># set less than immediate:           rd = rs1 &lt; imm
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>sltiu</span> <span style=color:#66d9ef>rd</span>, <span style=color:#66d9ef>rs</span>, <span style=color:#66d9ef>imm</span>  <span style=color:#75715e># set less than immediate unsigned:  rd = rs1 &lt; imm (unsigned)
</span></span></span></code></pre></div><p>These immediates are 12-bit sign-extended values that can represent -2048 to 2047 inclusive. See <a href=/posts/riscv-arithmetic#sign-extension>arithmetic sign extension</a> for further details.</p><p>There aren&rsquo;t standard pseudoinstructions for &ldquo;set greater than&rdquo;, which seems like an oversight. Recent versions of GCC do allow <strong>sgt</strong>, but this isn&rsquo;t supported by other assemblers.</p><p>Register-register set examples:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>li</span>   <span style=color:#66d9ef>t0</span>, <span style=color:#ae81ff>2</span>       <span style=color:#75715e># t0 =  2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>li</span>   <span style=color:#66d9ef>t1</span>, -<span style=color:#ae81ff>2</span>      <span style=color:#75715e># t1 = -2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>li</span>   <span style=color:#66d9ef>t2</span>, <span style=color:#ae81ff>42</span>      <span style=color:#75715e># t2 = 42
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>slt</span>  <span style=color:#66d9ef>t3</span>, <span style=color:#66d9ef>t0</span>, <span style=color:#66d9ef>t2</span>  <span style=color:#75715e># t3 = 1 because 2 &lt; 42
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>sltu</span> <span style=color:#66d9ef>t4</span>, <span style=color:#66d9ef>t0</span>, <span style=color:#66d9ef>t2</span>  <span style=color:#75715e># t4 = 1 because 2 &lt; 42
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>slt</span>  <span style=color:#66d9ef>t5</span>, <span style=color:#66d9ef>t1</span>, <span style=color:#66d9ef>t2</span>  <span style=color:#75715e># t5 = 1 because -2 &lt; 42
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>sltu</span> <span style=color:#66d9ef>t6</span>, <span style=color:#66d9ef>t1</span>, <span style=color:#66d9ef>t2</span>  <span style=color:#75715e># t6 = 0 because 4294967294 &gt; 42
</span></span></span></code></pre></div><p>Note how treating <strong>t1</strong> as unsigned produces a completely different result! Negative numbers are stored using two&rsquo;s complement, with -1 being 0xFFFFFFFF. Treating 0xFFFFFFFF as unsigned we get 2<sup>32</sup>-1 or 4,294,967,295.</p><p>Register-immediate set examples:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>li</span>   <span style=color:#66d9ef>t0</span>, <span style=color:#ae81ff>2</span>        <span style=color:#75715e># t0 =  2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>li</span>   <span style=color:#66d9ef>t1</span>, -<span style=color:#ae81ff>2</span>       <span style=color:#75715e># t1 = -2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>slti</span>  <span style=color:#66d9ef>t3</span>, <span style=color:#66d9ef>t0</span>, -<span style=color:#ae81ff>1</span>  <span style=color:#75715e># t3 = 0 because 2 &gt; -1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>sltiu</span> <span style=color:#66d9ef>t4</span>, <span style=color:#66d9ef>t0</span>, -<span style=color:#ae81ff>1</span>  <span style=color:#75715e># t4 = 1 because 2 &lt; 4294967295
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>slti</span>  <span style=color:#66d9ef>t5</span>, <span style=color:#66d9ef>t1</span>, -<span style=color:#ae81ff>1</span>  <span style=color:#75715e># t5 = 1 because -2 &lt; -1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>sltiu</span> <span style=color:#66d9ef>t6</span>, <span style=color:#66d9ef>t1</span>, -<span style=color:#ae81ff>1</span>  <span style=color:#75715e># t6 = 1 because 4294967294 &lt; 4294967295
</span></span></span></code></pre></div><h3 id=set-less-than-or-equal-to>Set Less Than or Equal To</h3><p>For &ldquo;less than or equal to&rdquo; you need two instructions.</p><p>For example, to set if <strong>a0</strong> is less than or equal to <strong>a1</strong>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>slt</span>     <span style=color:#66d9ef>t0</span>, <span style=color:#66d9ef>a1</span>, <span style=color:#66d9ef>a0</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>xori</span>    <span style=color:#66d9ef>t0</span>, <span style=color:#66d9ef>t0</span>, <span style=color:#ae81ff>1</span>
</span></span></code></pre></div><p>We check if <strong>a1</strong> is less than <strong>a0</strong>, then invert the set bit with <code>xori</code> because:</p><p><code>(a0 &lt;= a1) == !(a1 > a0)</code></p><p>Learn more about <a href=/posts/riscv-logical/#xor>xor and xori</a> (exclusive OR) in my post on logical instructions.</p><h3 id=set-zero>Set Zero</h3><p>RISC-V provides pseudoinstructions for comparing with zero:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>seqz</span> <span style=color:#66d9ef>rd</span>, <span style=color:#66d9ef>rs</span>  <span style=color:#75715e># set equal zero:         rd = rs == 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>snez</span> <span style=color:#66d9ef>rd</span>, <span style=color:#66d9ef>rs</span>  <span style=color:#75715e># set not equal zero:     rd = rs != 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>sltz</span> <span style=color:#66d9ef>rd</span>, <span style=color:#66d9ef>rs</span>  <span style=color:#75715e># set less than zero:     rd = rs &lt; 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>sgtz</span> <span style=color:#66d9ef>rd</span>, <span style=color:#66d9ef>rs</span>  <span style=color:#75715e># set greater than zero:  rd = rs &gt; 0
</span></span></span></code></pre></div><p>Examples of set zero comparisons:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>li</span>   <span style=color:#66d9ef>t0</span>, -<span style=color:#ae81ff>2</span>  <span style=color:#75715e># t0 =  -2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>seqz</span> <span style=color:#66d9ef>t3</span>, <span style=color:#66d9ef>t0</span>  <span style=color:#75715e># t3 = 0 because -2 != 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>snez</span> <span style=color:#66d9ef>t4</span>, <span style=color:#66d9ef>t0</span>  <span style=color:#75715e># t4 = 1 because -2 != 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>sltz</span> <span style=color:#66d9ef>t5</span>, <span style=color:#66d9ef>t0</span>  <span style=color:#75715e># t5 = 1 because -2 &lt;  0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>sgtz</span> <span style=color:#66d9ef>t6</span>, <span style=color:#66d9ef>t0</span>  <span style=color:#75715e># t6 = 0 because  0 &gt; -2
</span></span></span></code></pre></div><h3 id=multi-word-addition>Multi-Word Addition</h3><p>You can use a set instruction to carry out multi-word addition in place of a carry flag. For example, to add 64-bit integers on 32-bit RISC-V:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#75715e># 64-bit integer addition
</span></span></span><span style=display:flex><span><span style=color:#75715e>#   arguments:
</span></span></span><span style=display:flex><span><span style=color:#75715e>#       a0: x lower 32 bits
</span></span></span><span style=display:flex><span><span style=color:#75715e>#       a1: x upper 32 bits
</span></span></span><span style=display:flex><span><span style=color:#75715e>#       a2: y lower 32 bits
</span></span></span><span style=display:flex><span><span style=color:#75715e>#       a3: y upper 32 bits
</span></span></span><span style=display:flex><span><span style=color:#75715e>#   return:
</span></span></span><span style=display:flex><span><span style=color:#75715e>#       a0: x+y lower 32 bits
</span></span></span><span style=display:flex><span><span style=color:#75715e>#       a1: x+y upper 32 bits
</span></span></span><span style=display:flex><span><span style=color:#75715e>#
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>add64:
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>add</span>  <span style=color:#66d9ef>a0</span>, <span style=color:#66d9ef>a0</span>, <span style=color:#66d9ef>a2</span>  <span style=color:#75715e># add lower 32 bits
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>add</span>  <span style=color:#66d9ef>t0</span>, <span style=color:#66d9ef>a1</span>, <span style=color:#66d9ef>a3</span>  <span style=color:#75715e># add upper 32 bits
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>sltu</span> <span style=color:#66d9ef>t1</span>, <span style=color:#66d9ef>a0</span>, <span style=color:#66d9ef>a2</span>  <span style=color:#75715e># if lower 32-bit sum &lt; a2 then set t1=1 (carry bit)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>add</span>  <span style=color:#66d9ef>a1</span>, <span style=color:#66d9ef>t0</span>, <span style=color:#66d9ef>t1</span>  <span style=color:#75715e># upper 32 bits of answer (upper sum + carry bit)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>ret</span>
</span></span></code></pre></div><p>If the sum of the lower 32 bits is less than a2, then we need to carry a bit. The <strong>sltu</strong> instruction tests for this and sets <code>t1=1</code> when it occurs. We add <code>t1</code> to the sum of the upper 32 bits to create the correct answer.</p><p>32-bit CPUs with a carry flag can add 64 bits in just two instructions. For example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#75715e># multi-word addition on arm
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>add64_arm:
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>adds</span> <span style=color:#66d9ef>r0</span>, <span style=color:#66d9ef>r0</span>, <span style=color:#66d9ef>r2</span>  <span style=color:#75715e># add and set flags (including carry)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>adc</span>  <span style=color:#66d9ef>r1</span>, <span style=color:#66d9ef>r1</span>, <span style=color:#66d9ef>r3</span>  <span style=color:#75715e># add with carry
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>bx</span>   <span style=color:#66d9ef>lr</span>
</span></span></code></pre></div><p>At first glance, RISC-V&rsquo;s approach seems inferior. However, avoiding condition codes simplifies hardware design, especially on modern out-of-order CPUs. RISC-V CPUs can also fuse multiple instructions into one internally, so the set instruction in multi-word add don&rsquo;t necessarily increase the number of instructions executed.</p><p>CPU design is a trade-off. While a load-store architecture and zero register are almost universally admired, not everyone appreciates RISC-V&rsquo;s lack of condition codes.</p><p>To learn more about RISC-V addition and subtraction, see the post on <a href=/posts/riscv-arithmetic/>arithmetic</a>.</p><h2 id=whats-next>What&rsquo;s Next?</h2><p>The next post looks at RISC-V <strong><a href=/posts/riscv-jump-function/>Jump and Function Instructions</a></strong>, including the stack and RISC-V ABI.</p><p>Check out the <a href=/posts/riscv-cheat-sheet/>RISC-V Assembler Cheat Sheet</a> and all my <a href=/tutorials/>FPGA & RISC-V Tutorials</a>.</p><p>Share your thoughts with me on <a href=https://mastodon.social/@WillFlux>Mastodon</a> or <a href=https://x.com/WillFlux>X</a>. If you enjoy my work, please <a href=https://github.com/sponsors/WillGreen>sponsor me</a>. Sponsors help me create more FPGA and RISC-V projects for everyone, <em>and</em> they get early access to blog posts and source code. 🙏</p><h3 id=references>References</h3><ul><li><a href=https://wiki.riscv.org/display/HOME/RISC-V+Technical+Specifications>RISC-V Technical Specifications</a> (riscv.org)</li></ul></section><footer class="mt-12 flex flex-wrap"><a class="mb-1.5 mr-1.5 rounded-lg bg-black/[3%] px-5 py-1.5 no-underline dark:bg-white/[8%]" href=https://projectf.io/tags/asm>asm</a>
<a class="mb-1.5 mr-1.5 rounded-lg bg-black/[3%] px-5 py-1.5 no-underline dark:bg-white/[8%]" href=https://projectf.io/tags/riscv>riscv</a></footer></article></main><footer class="opaco mx-auto flex h-[4.5rem] max-w-4xl items-center px-8 text-[0.9em] opacity-60"><div class=mr-auto><a class=link href=https://projectf.io/>Project F</a>: A little oasis for FPGA and RISC-V design.
&copy; 2024 Will Green.</div></footer></body></html>