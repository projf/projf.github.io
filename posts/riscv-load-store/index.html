<!doctype html><html class="not-ready lg:text-base" style=--bg:#fff lang=en-gb><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>RISC-V Assembler: Load Store - Project F</title>
<meta name=theme-color><meta name=description content="This post looks at RISC-V load and store instructions, such as lw, sw, and lbu. We&rsquo;ll also cover memory alignment, addressing modes, and loading symbol addresses. These instructions are included in RV32I, the base integer instruction set. New to the series? Check out the first part on arithmetic instructions.
In the last few years, we&rsquo;ve seen an explosion of RISC-V CPU designs, especially on FPGA. Thankfully, RISC-V is ideal for assembly programming with its compact, easy-to-learn instruction set."><meta name=author content="Will Green"><link rel="preload stylesheet" as=style href=https://projectf.io/main.min.css><link rel=preload as=image href=https://projectf.io/theme.png><link rel=preload as=image href=https://projectf.io/twitter.svg><link rel=preload as=image href=https://projectf.io/github.svg><link rel=preload as=image href=https://projectf.io/mastodon.svg><link rel=preload as=image href=https://projectf.io/rss.svg><script defer src=https://projectf.io/highlight.min.js onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://projectf.io/favicon.ico><link rel=apple-touch-icon href=https://projectf.io/apple-touch-icon.png><meta name=generator content="Hugo 0.122.0"><script src=https://cdn-eu.usefathom.com/script.js data-site=EVCGKVDN defer></script><meta itemprop=name content="RISC-V Assembler: Load Store"><meta itemprop=description content="This post looks at RISC-V load and store instructions, such as lw, sw, and lbu. We&rsquo;ll also cover memory alignment, addressing modes, and loading symbol addresses. These instructions are included in RV32I, the base integer instruction set. New to the series? Check out the first part on arithmetic instructions.
In the last few years, we&rsquo;ve seen an explosion of RISC-V CPU designs, especially on FPGA. Thankfully, RISC-V is ideal for assembly programming with its compact, easy-to-learn instruction set."><meta itemprop=datePublished content="2024-02-14T00:00:00+00:00"><meta itemprop=dateModified content="2024-02-14T00:00:00+00:00"><meta itemprop=wordCount content="1651"><meta itemprop=image content="https://projectf.io/posts/riscv-load-store/img/social/riscv-load-store.png"><meta itemprop=keywords content="asm,memory,riscv,"><meta property="og:title" content="RISC-V Assembler: Load Store"><meta property="og:description" content="This post looks at RISC-V load and store instructions, such as lw, sw, and lbu. We&rsquo;ll also cover memory alignment, addressing modes, and loading symbol addresses. These instructions are included in RV32I, the base integer instruction set. New to the series? Check out the first part on arithmetic instructions.
In the last few years, we&rsquo;ve seen an explosion of RISC-V CPU designs, especially on FPGA. Thankfully, RISC-V is ideal for assembly programming with its compact, easy-to-learn instruction set."><meta property="og:type" content="article"><meta property="og:url" content="https://projectf.io/posts/riscv-load-store/"><meta property="og:image" content="https://projectf.io/posts/riscv-load-store/img/social/riscv-load-store.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-02-14T00:00:00+00:00"><meta property="article:modified_time" content="2024-02-14T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://projectf.io/posts/riscv-load-store/img/social/riscv-load-store.png"><meta name=twitter:title content="RISC-V Assembler: Load Store"><meta name=twitter:description content="This post looks at RISC-V load and store instructions, such as lw, sw, and lbu. We&rsquo;ll also cover memory alignment, addressing modes, and loading symbol addresses. These instructions are included in RV32I, the base integer instruction set. New to the series? Check out the first part on arithmetic instructions.
In the last few years, we&rsquo;ve seen an explosion of RISC-V CPU designs, especially on FPGA. Thankfully, RISC-V is ideal for assembly programming with its compact, easy-to-learn instruction set."><link rel=canonical href=https://projectf.io/posts/riscv-load-store/></head><body class="text-black duration-200 ease-out dark:text-white"><header class="mx-auto flex h-[4.5rem] max-w-4xl px-8 lg:justify-center"><div class="relative z-50 mr-auto flex items-center"><a class="-translate-x-[1px] -translate-y-[1px] text-2xl font-semibold" href=https://projectf.io>Project F</a><div class="btn-dark text-[0] ml-4 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.png)_left_center/_auto_theme('spacing.6')_no-repeat] [transition:_background-position_0.4s_steps(5)] dark:[background-position:right]" role=button aria-label=Dark></div></div><div class="btn-menu relative z-50 -mr-8 flex h-[4.5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden" role=button aria-label=Menu></div><script>const htmlClass=document.documentElement.classList;setTimeout(()=>{htmlClass.remove("not-ready")},10);const btnMenu=document.querySelector(".btn-menu");btnMenu.addEventListener("click",()=>{htmlClass.toggle("open")});const metaTheme=document.querySelector('meta[name="theme-color"]'),lightBg="#fff".replace(/"/g,""),setDark=e=>{metaTheme.setAttribute("content",e?"#000":lightBg),htmlClass[e?"add":"remove"]("dark"),localStorage.setItem("dark",e)},darkScheme=window.matchMedia("(prefers-color-scheme: dark)");if(htmlClass.contains("dark"))setDark(!0);else{const e=localStorage.getItem("dark");setDark(e?e==="true":darkScheme.matches)}darkScheme.addEventListener("change",e=>{setDark(e.matches)});const btnDark=document.querySelector(".btn-dark");btnDark.addEventListener("click",()=>{setDark(localStorage.getItem("dark")!=="true")})</script><div class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full select-none flex-col justify-center pb-16 duration-200 dark:bg-black lg:static lg:h-auto lg:flex-row lg:!bg-transparent lg:pb-0 lg:transition-none"><nav class="lg:ml-12 lg:flex lg:flex-row lg:items-center lg:space-x-6"><a class="block text-center text-2xl leading-[5rem] lg:text-base lg:font-normal" href=/about/>About</a>
<a class="block text-center text-2xl leading-[5rem] lg:text-base lg:font-normal" href=/demos/>Demos</a>
<a class="block text-center text-2xl leading-[5rem] lg:text-base lg:font-normal" href=/verilog-lib/>Lib</a>
<a class="block text-center text-2xl leading-[5rem] lg:text-base lg:font-normal" href=/tools/>Tools</a>
<a class="block text-center text-2xl leading-[5rem] lg:text-base lg:font-normal" href=/tutorials/>Tutorials</a></nav><nav class="mt-12 flex justify-center space-x-10 dark:invert lg:ml-12 lg:mt-0 lg:items-center lg:space-x-6"><a class="h-8 w-8 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./twitter.svg) href=https://twitter.com/@WillFlux target=_blank rel=me>twitter
</a><a class="h-8 w-8 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./github.svg) href=https://github.com/projf target=_blank rel=me>github
</a><a class="h-8 w-8 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./mastodon.svg) href=https://mastodon.social/@WillFlux target=_blank rel=me>mastodon
</a><a class="h-8 w-8 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./rss.svg) href=https://projectf.io/index.xml target=_blank rel=alternate>rss</a></nav></div></header><main class="prose prose-neutral relative mx-auto min-h-[calc(100%-9rem)] max-w-4xl px-8 pb-4 pt-4 dark:prose-invert"><article><header class=mb-4><h1 class="!my-0 pb-2.5">RISC-V Assembler: Load Store</h1><div class="text-sm antialiased opacity-60">Published
<time>14 Feb 2024</time></div></header><section><p>This post looks at RISC-V load and store instructions, such as <strong>lw</strong>, <strong>sw</strong>, and <strong>lbu</strong>. We&rsquo;ll also cover memory alignment, addressing modes, and loading symbol addresses. These instructions are included in <strong>RV32I</strong>, the base integer instruction set. New to the series? Check out the first part on <a href=/posts/riscv-arithmetic>arithmetic instructions</a>.</p><p>In the last few years, we&rsquo;ve seen an explosion of RISC-V CPU designs, especially on FPGA. Thankfully, RISC-V is ideal for assembly programming with its compact, easy-to-learn instruction set. This mini-series will help you learn and understand 32-bit RISC-V instructions (RV32) and the RISC-V ABI.</p><p>Share your thoughts with @WillFlux on <a href=https://mastodon.social/@WillFlux>Mastodon</a> or <a href=https://twitter.com/WillFlux>Twitter</a>. If you like what I do, <a href=https://github.com/sponsors/WillGreen>sponsor me</a>. üôè</p><p><strong>DRAFT POST</strong></p><h2 id=load-store-architecture>Load-Store Architecture</h2><p>RISC-V is a load-store architecture: load and store instructions access memory, while other instructions work with CPU registers. A <strong>load</strong> reads a value from memory into a register. A <strong>store</strong> writes a value from a register into memory.</p><h2 id=data-sizes>Data Sizes</h2><p>RV32 is a 32-bit architecture, and all arithmetic is performed on 32-bit words (there&rsquo;s no &ldquo;byte add&rdquo; instruction, for example). However, loads and stores support 8 and 16-bit data as programmers commonly work with 8 and 16-bit data, such as text.</p><p>RISC-V uses consistent names and one-letter abbreviations for data sizes:</p><ul><li><strong>b</strong> - <strong>byte</strong> - 8 bits</li><li><strong>h</strong> - <strong>half word</strong> - 16 bits (2 bytes)</li><li><strong>w</strong> - <strong>word</strong> - 32 bits (4 bytes)</li><li><strong>d</strong> - <strong>double word</strong> - 64 bits (8 bytes)</li></ul><p>Being familiar with these one-letter abbreviations is a great help in understanding loads and stores.</p><p><em>ProTip: A word is always 32 bits wide, even on 64-bit RISC-V (RV64).</em></p><h2 id=load>Load</h2><p>RISC-V has five load instructions:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>lw</span>   <span style=color:#75715e># load word
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>lh</span>   <span style=color:#75715e># load half word
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>lhu</span>  <span style=color:#75715e># load half word unsigned
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>lb</span>   <span style=color:#75715e># load byte
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>lbu</span>  <span style=color:#75715e># load byte unsigned
</span></span></span></code></pre></div><p>Load instructions have a consistent format that we&rsquo;ll illustrate with load word:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>lw</span> <span style=color:#66d9ef>rd</span>, <span style=color:#66d9ef>offset</span>(<span style=color:#66d9ef>rs1</span>)
</span></span></code></pre></div><p>Where <strong>rd</strong> is the destination register, <strong>rs1</strong> holds the memory address, and <strong>offset</strong> is an address offset.</p><p>The offset is a 12-bit signed immediate, so can reach addresses -2048 to +2047 bytes from the the address in <code>rs1</code>.</p><p>For example, if we want to load the word at address 0x140 into register <strong>t0</strong>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>li</span> <span style=color:#66d9ef>t6</span>, <span style=color:#ae81ff>0x140</span>  <span style=color:#75715e># load an address into register t6
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>lw</span> <span style=color:#66d9ef>t0</span>, <span style=color:#ae81ff>0</span>(<span style=color:#66d9ef>t6</span>)  <span style=color:#75715e># load word from memory address in t6 with 0 byte offset
</span></span></span></code></pre></div><p><strong>t0</strong> is loaded with the word at 0x140.</p><p>To load the next word, we increase the address by 4 because addresses are in units of bytes:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>lw</span> <span style=color:#66d9ef>t1</span>, <span style=color:#ae81ff>4</span>(<span style=color:#66d9ef>t6</span>)  <span style=color:#75715e># load word from memory address in t6 with 4 byte offset
</span></span></span></code></pre></div><p><strong>t1</strong> is loaded with the word at address 0x144.</p><p>Halves and bytes work in the same way, but the value is sign-extended:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>lh</span> <span style=color:#66d9ef>t2</span>, <span style=color:#ae81ff>6</span>(<span style=color:#66d9ef>t6</span>)  <span style=color:#75715e># load sign-extended half from memory address in t6 with 6 byte offset
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>lb</span> <span style=color:#66d9ef>t3</span>, <span style=color:#ae81ff>7</span>(<span style=color:#66d9ef>t6</span>)  <span style=color:#75715e># load sign-extended byte from memory address in t6 with 7 byte offset
</span></span></span></code></pre></div><p><strong>t2</strong> is loaded with the half word at address 0x146. <strong>t3</strong> is loaded with the byte at address 0x147.</p><p>Thanks to sign extension, a byte in memory with the value -1 retains the correct value when loaded into a register. See <a href=/posts/riscv-arithmetic#sign-extension>arithmetic sign extension</a> for a reminder of how sign extension works.</p><p>RISC-V includes unsigned load half and byte to handle unsigned data, such as UTF-8 text:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>lhu</span> <span style=color:#66d9ef>t4</span>, <span style=color:#ae81ff>8</span>(<span style=color:#66d9ef>t6</span>)   <span style=color:#75715e># load zero-extended half from memory address in t6 with 8 byte offset
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>lbu</span> <span style=color:#66d9ef>t5</span>, <span style=color:#ae81ff>10</span>(<span style=color:#66d9ef>t6</span>)  <span style=color:#75715e># load zero-extended byte from memory address in t6 with 10 byte offset
</span></span></span></code></pre></div><h2 id=store>Store</h2><p>The store instructions are straightforward because there&rsquo;s no need to worry about sign extension:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>sw</span>   <span style=color:#75715e># store word
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>sh</span>   <span style=color:#75715e># store half word
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>sb</span>   <span style=color:#75715e># store byte
</span></span></span></code></pre></div><p>Store instructions look just like the equivalent load instruction:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>sw</span> <span style=color:#66d9ef>rs2</span>, <span style=color:#66d9ef>offset</span>(<span style=color:#66d9ef>rs1</span>)
</span></span></code></pre></div><p>Where <strong>rs2</strong> is the source register, <strong>rs1</strong> holds the memory address, and <strong>offset</strong> is an address offset.</p><p>Note how the source register is the first operand, which makes stores like loads but is different from other RISC-V instructions. This is best seen with some examples:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>li</span> <span style=color:#66d9ef>t0</span>, <span style=color:#ae81ff>42</span>     <span style=color:#75715e># load the immediate 42 into register t0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>li</span> <span style=color:#66d9ef>t6</span>, <span style=color:#ae81ff>0x140</span>  <span style=color:#75715e># load an address into register t6
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>sw</span> <span style=color:#66d9ef>t0</span>, <span style=color:#ae81ff>0</span>(<span style=color:#66d9ef>t6</span>)  <span style=color:#75715e># store the word in t0 to memory address in t6 with 0 byte offset
</span></span></span></code></pre></div><p>Memory location 0x140 now contains a word with the value 42 (0x0000002A).</p><p>If we want to <strong>zero a word of memory</strong>, we can store the zero register (<strong>x0</strong>) to it:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>sw</span> <span style=color:#66d9ef>zero</span>, <span style=color:#ae81ff>4</span>(<span style=color:#66d9ef>t6</span>)  <span style=color:#75715e># store 0 to memory address in t6 with 4 byte offset
</span></span></span></code></pre></div><p>Halves and bytes work in the same way, storing the least significant 16 or 8 bits to memory:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>sw</span> <span style=color:#66d9ef>zero</span>, <span style=color:#ae81ff>4</span>(<span style=color:#66d9ef>t6</span>)  <span style=color:#75715e># store 0 to memory address in t6 with 4 byte offset
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>li</span> <span style=color:#66d9ef>t0</span>, <span style=color:#ae81ff>0xFACE</span>   <span style=color:#75715e># load the immediate 0xFACE into register t0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>sh</span> <span style=color:#66d9ef>t0</span>, <span style=color:#ae81ff>4</span>(<span style=color:#66d9ef>t6</span>)  <span style=color:#75715e># store half from t0 to memory address in t6 with 4 byte offset
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>sb</span> <span style=color:#66d9ef>t0</span>, <span style=color:#ae81ff>6</span>(<span style=color:#66d9ef>t6</span>)  <span style=color:#75715e># store byte from t0 to memory address in t6 with 6 byte offset
</span></span></span></code></pre></div><p>What state is our memory now in? A good way to think about this is to ask what happens if we load a word from memory address 0x144? The answer hinges on RISC-V being <strong>little endian</strong>.</p><p>A little-endian CPU stores the least significant byte at the lowest address.</p><p>Our <strong>sh</strong> instruction puts the least significant byte, 0xCE, at address 0x144 and the most significant byte, 0xFA, at address 0x145.</p><p>The following <strong>sb</strong> instruction puts 0xCE at address 0x146. 0x147 is still zero from the previous &ldquo;sw zero&rdquo; instruction.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>lw</span> <span style=color:#66d9ef>t1</span>, <span style=color:#ae81ff>4</span>(<span style=color:#66d9ef>t6</span>)  <span style=color:#75715e># load word from memory address in t6 with 4 byte offset
</span></span></span></code></pre></div><p>After this load, <strong>t1</strong> contains 0x00CECEFA.</p><p>Most of the time, you&rsquo;ll be accessing data as either words or bytes, in which case you needn&rsquo;t worry about RISC-V being little endian.</p><p>This is a cursory look at endianness, but there&rsquo;s plenty of material online. Wikipedia&rsquo;s <a href=https://en.wikipedia.org/wiki/Endianness>Endianness</a> article is a decent place to start.</p><h2 id=loading-symbol-addresses>Loading Symbol Addresses</h2><p>The load and store instructions require a memory address, but what if you want to reference a symbol? This sounds too abstract, so let&rsquo;s look at a concrete example let&rsquo;s say &ldquo;Hello, World!&rdquo;.</p><p>We put our greeting string in the data section with the <strong>.ascii</strong> assembler directive:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>.section</span> <span style=color:#66d9ef>.data</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>.balign</span> <span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span>greeting:
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>.ascii</span> <span style=color:#e6db74>&#34;Hello, World!\0&#34;</span>  <span style=color:#75715e># null-terminated string
</span></span></span></code></pre></div><p>Imagine a function called <code>print_string</code> that displays a null-terminated string. We need to pass the address of our greeting string from the data section, but we don&rsquo;t know the address!</p><p>The <strong>la</strong> (load address) pseudoinstruction comes to our rescue:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>la</span> <span style=color:#66d9ef>rd</span>, <span style=color:#66d9ef>symbol</span>
</span></span></code></pre></div><p>Loading our symbol address is simple:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>la</span>   <span style=color:#66d9ef>a0</span>, <span style=color:#66d9ef>greeting</span>  <span style=color:#75715e># load address of greeting label in the data section
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>call</span> <span style=color:#66d9ef>print_string</span>  <span style=color:#75715e># call print_string function
</span></span></span></code></pre></div><p>Note how we pass the (first) argument to a function in register <strong>a0</strong>. We&rsquo;ll look into functions in more detail in a forthcoming post.</p><h2 id=memory-addresses>Memory Addresses</h2><p>RISC-V uses <strong>byte addressing</strong>, the norm for all general-purpose CPUs. With byte addressing, you can access an individual byte in memory (even with a 32-bit CPU).</p><p>We&rsquo;re so used to thinking of data sizes in bytes that we rarely stop to think about it, but there&rsquo;s no fundamental reason we should divide data into 8-bit chunks. If a CPU is 32-bit, why not address memory in units of 32-bit words? Word addressing would be simpler, and a 32-bit CPU could access 16 GiB or memory vs 4 GiB with byte addressing.</p><p>However, the dominant UTF-8 text encoding is byte-based and with good reason. CPU performance depends on cache hits, so efficient data storage of frequent data, such as text, is essential.</p><p>The upshot of byte addressing is that if you want to move to the next <strong>word</strong>, you must add <strong>4</strong> to the address. On 64-bit CPUs, you add <strong>8</strong> to get to the next <strong>double word</strong>. Accidentally adding 1, rather than 4, to a memory address is a common source of bugs in my personal experience. üòÖ</p><p>Remember, the load and store memory offset is a <strong>signed 12-bit</strong> value, so you can access memory locations between -2048 and +2047 <strong>bytes</strong> from the base address in the register.</p><h2 id=memory-alignment>Memory Alignment</h2><p>RISC-V doesn&rsquo;t require data to be naturally aligned; for example, words don&rsquo;t have to be on a 4-byte boundary. However, not all CPUs support misaligned memory access, and it&rsquo;s invariably slower on those that do support it. I strongly recommend using natural alignment in your code.</p><p>You can align your data with the GNU assembler <strong>.balign</strong> assembler directive.</p><p>For example, to align the word with the label &ldquo;foo&rdquo; to a 4-byte boundary:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>.section</span> <span style=color:#66d9ef>.data</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>.balign</span> <span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span>foo:
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>.word</span> <span style=color:#ae81ff>0</span>
</span></span></code></pre></div><p>NB. The alignment directive applies to the label, so it must appear <em>before</em> &ldquo;foo&rdquo;!</p><h2 id=addressing-modes>Addressing Modes</h2><p>An addressing mode is how the CPU calculates a memory address. With x86 and 68K, the smart use of addressing modes is critical to writing good code. With RISC-V, addressing modes aren&rsquo;t really a thing. I will stick my neck out a little and say RISC-V has three addressing modes, but it&rsquo;s not something you usually need to consider.</p><ol><li><strong>Register Offset</strong> (AKA Displacement on x86) - most instructions (including load/store)</li><li><strong>PC Relative</strong> - <strong>auipc</strong>, <strong>jal</strong>, and branch instructions</li><li><strong>Absolute</strong> (AKA Immediate) - <strong>lui</strong></li></ol><p><strong>PC</strong> is the <strong>program counter</strong>, which points to the next instruction. In x86 land, this is known as the instruction pointer (IP), which is frankly a much better name. We&rsquo;ll learn more about the program counter when we discuss branches (future post).</p><p>Including variations, the Motorola 68000 has 14 addressing modes! For example <em>address register indirect with post-increment</em>. These help you write compact assembly code but complicate the CPU design. I love 68000 assembler, but I appreciate the simplicity of RISC-V.</p><h2 id=whats-next>What&rsquo;s Next?</h2><p>The next instalment of <em>RISC-V Assembler</em> is all about setting and branching (coming soon). In the meantime, read my posts on <a href=/posts/riscv-logical>logical instructions</a> and <a href=/posts/riscv-shift>shift instructions</a>.</p><p>Check out my <a href=/tutorials/>FPGA & RISC-V Tutorials</a> and my series on early <a href=https://systemtalk.org/post/macintosh-history-8510/>Macintosh History</a>.</p></section><footer class="mt-12 flex flex-wrap"><a class="mb-1.5 mr-1.5 rounded-lg bg-black/[3%] px-5 py-1.5 no-underline dark:bg-white/[8%]" href=https://projectf.io/tags/asm>asm</a>
<a class="mb-1.5 mr-1.5 rounded-lg bg-black/[3%] px-5 py-1.5 no-underline dark:bg-white/[8%]" href=https://projectf.io/tags/memory>memory</a>
<a class="mb-1.5 mr-1.5 rounded-lg bg-black/[3%] px-5 py-1.5 no-underline dark:bg-white/[8%]" href=https://projectf.io/tags/riscv>riscv</a></footer></article></main><footer class="opaco mx-auto flex h-[4.5rem] max-w-4xl items-center px-8 text-[0.9em] opacity-60"><div class=mr-auto><a class=link href=https://projectf.io>Project F</a>: A little oasis for FPGA and RISC-V design.
&copy; 2024 Will Green.</div></footer></body></html>