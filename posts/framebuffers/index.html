<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"  lang="en-gb">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1"/>

<title>Framebuffers | Project F - FPGA Development</title>

<meta property='og:title' content='Framebuffers - Project F - FPGA Development'>
<meta property='og:description' content='Welcome back to Exploring FPGA Graphics. In the previous two parts, we worked with sprites, but as graphics become more complex, a different approach is needed. Instead of drawing directly to the screen, we draw to a framebuffer, which is read by the display controller. This post provides an introduction to framebuffers and how to scale and fade them Wolfenstein 3D style. In the next part, we&rsquo;ll use a framebuffer to visualize a simulation of life.'>
<meta property='og:url' content='https://projectf.io/posts/framebuffers/'>
<meta property='og:site_name' content='Project F - FPGA Development'>
<meta property='og:type' content='article'><meta property='og:image' content='https://projectf.io/img/posts/framebuffers/social-card.png'><meta property='article:published_time' content='2020-10-30T00:00:00Z'/><meta property='article:modified_time' content='2020-10-30T00:00:00Z'/><meta name='twitter:card' content='summary_large_image'><meta name='twitter:site' content='@WillFlux'><meta name='twitter:creator' content='@WillFlux'>


<link href="https://projectf.io/index.xml" rel="alternate" type="application/rss+xml" title="Project F - FPGA Development" />

<link rel="stylesheet" href="/css/style.css"/><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
<link rel="canonical" href="https://projectf.io/posts/framebuffers/">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff">
<meta name="referrer" content="no-referrer, same-origin">
</head>
<body>
<section class="section">
  <div class="container">
    <nav id="nav-main" class="nav">
      <div id="nav-name" class="nav-left">
        <a id="nav-anchor" class="nav-item" href="https://projectf.io">
          <h1 id="nav-heading" class="title is-4">Project F - FPGA Development</h1>
        </a>
      </div>
      <div class="nav-right">
        <nav id="nav-items" class="nav-item level is-mobile"><a class="level-item" aria-label="github" href='https://github.com/projf'
            target='_blank' rel='noopener'>
            <span class="icon">
              <i class><svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
    
    <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"/>
    
  </svg></i>
            </span>
          </a><a class="level-item" aria-label="twitter" href='https://twitter.com/WillFlux'
            target='_blank' rel='noopener'>
            <span class="icon">
              <i class><svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
    
    <path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"/>
    
  </svg></i>
            </span>
          </a><a class="level-item" aria-label="youtube" href='https://youtube.com/channel/UCaT0lvfWo1GStbp0neg8weg'
            target='_blank' rel='noopener'>
            <span class="icon">
              <i class><svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
    
    <path d="M22.54 6.42a2.78 2.78 0 0 0-1.94-2C18.88 4 12 4 12 4s-6.88 0-8.6.46a2.78 2.78 0 0 0-1.94 2A29 29 0 0 0 1 11.75a29 29 0 0 0 .46 5.33A2.78 2.78 0 0 0 3.4 19c1.72.46 8.6.46 8.6.46s6.88 0 8.6-.46a2.78 2.78 0 0 0 1.94-2 29 29 0 0 0 .46-5.25 29 29 0 0 0-.46-5.33z"/>
    <polygon points="9.75 15.02 15.5 11.75 9.75 8.48 9.75 15.02"/>
    
  </svg></i>
            </span>
          </a><a class="level-item" aria-label="rss" href='/index.xml'
            target='_blank' rel='noopener'>
            <span class="icon">
              <i class><svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
    
    <path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle>
    
  </svg></i>
            </span>
          </a></nav>
      </div>
    </nav>

    <nav class="nav">
      
      <div class="nav-left"><a class="nav-item" href="/about">
          <h2 class="title is-5">About</h2>
        </a><a class="nav-item" href="/sitemap">
          <h2 class="title is-5">Sitemap</h2>
        </a><a class="nav-item" href="/tags/cookbook">
          <h2 class="title is-5">Cookbook</h2>
        </a><a class="nav-item" href="/tags/explore">
          <h2 class="title is-5">Explore</h2>
        </a><a class="nav-item" href="/tags/tools">
          <h2 class="title is-5">Tools</h2>
        </a></div>
      

      
    </nav>

  </div>
  <script src="/js/navicon-shift.js"></script>
</section>
<section class="section">
  <div class="container">
    <div class="subtitle tags is-6 is-pulled-right">
      
      
<a class="subtitle is-6" href="/tags/explore/">#explore</a>



  
  | <a class="subtitle is-6" href="/tags/graphics/">#graphics</a>
  


      
    </div>
    <h2 class="subtitle is-6">30 October 2020</h2>
    <h1 class="title">Framebuffers</h1>
    
    <div class="content">
      <p>Welcome back to <em>Exploring FPGA Graphics</em>. In the previous two parts, we worked with sprites, but as graphics become more complex, a different approach is needed. Instead of drawing directly to the screen, we draw to a framebuffer, which is read by the display controller. This post provides an introduction to framebuffers and how to scale and fade them Wolfenstein 3D style. In the <a href="/posts/life-on-screen/">next part</a>, we&rsquo;ll use a framebuffer to visualize a simulation of life.</p>
<p>In this series, we explore graphics at the hardware level and get a feel for the power of FPGAs. We start by learning how displays work, before racing the beam with Pong, starfields and sprites, simulating life with bitmaps, drawing lines and triangles, and finally creating simple 3D models. I&rsquo;ll be writing and revising this series throughout 2020 and 2021. New to the series? Start with <a href="/posts/fpga-graphics/">Exploring FPGA Graphics</a>.</p>
<p><strong>Designs for iCEBreaker are not yet available pending a BRAM fix.</strong></p>
<p><em>Updated 2021-01-09. Get in touch with <a href="https://twitter.com/WillFlux">@WillFlux</a> or open an <a href="https://github.com/projf/projf-explore/issues">issue on GitHub</a>.</em></p>
<h3 id="series-outline">Series Outline</h3>
<ul>
<li><a href="/posts/fpga-graphics/">Exploring FPGA Graphics</a> - learn how displays work and animate simple shapes</li>
<li><a href="/posts/fpga-pong/">FPGA Pong</a> - race the beam to create the arcade classic</li>
<li><a href="/posts/hardware-sprites/">Hardware Sprites</a> - fast, colourful, graphics with minimal resources</li>
<li><a href="/posts/fpga-ad-astra/">FPGA Ad Astra</a> - demo with hardware sprites and animated starfields</li>
<li>Framebuffers (this post) - driving the display from a bitmap in memory</li>
<li><a href="/posts/life-on-screen/">Life on Screen</a> - the screen comes alive with Conway&rsquo;s Game of Life</li>
</ul>
<p><em>More parts to follow.</em></p>
<h3 id="requirements">Requirements</h3>
<p>For this series, you need an FPGA board with video output. We&rsquo;ll be working at 640x480, so pretty much any video output will do. You should be comfortable with programming your FPGA board and reasonably familiar with Verilog.</p>
<p>We&rsquo;ll be demoing with these boards:</p>
<ul>
<li><strong><a href="https://docs.icebreaker-fpga.org/hardware/icebreaker/">iCEBreaker</a></strong> (Lattice iCE40) with <strong><a href="https://docs.icebreaker-fpga.org/hardware/pmod/dvi/">12-Bit DVI Pmod</a></strong></li>
<li><strong><a href="https://reference.digilentinc.com/reference/programmable-logic/arty-a7/reference-manual">Digilent Arty A7-35T</a></strong> (Xilinx Artix-7) with <strong><a href="https://reference.digilentinc.com/reference/pmod/pmodvga/reference-manual">Pmod VGA</a></strong></li>
</ul>
<h3 id="source">Source</h3>
<p>The SystemVerilog designs featured in this series are available from the <a href="https://github.com/projf/projf-explore/">projf-explore</a> repo on GitHub. The designs are open source hardware under the permissive MIT licence, but this blog is subject to normal copyright restrictions.</p>
<h2 id="framebuffer">Framebuffer</h2>
<p>A framebuffer is an in-memory bitmap that drives pixels on screen. When you write to a memory location within the framebuffer, the corresponding pixel will change on screen. Using a framebuffer provides two big benefits: we&rsquo;re free to create sophisticated graphics using whatever technique we like, and the setting of pixel colour is separated from the process driving the screen. The flexibility of a framebuffer comes at the cost of increased memory storage and latency.</p>
<h2 id="a-small-buffer">A Small Buffer</h2>
<p>Framebuffers require memory to hold the whole frame. To keep things simple, we want to be able to store our framebuffer in FPGA block memory (BRAM), rather than relying on external ram. The iCE40 FPGA on the iCEBreaker board has 120 Kb of block memory, so that&rsquo;s what we&rsquo;ll target for this post. You can learn more about block ram in <a href="/posts/fpga-memory-types/">FPGA Memory Types</a>.</p>
<p>If we divide our 640x480 screen by four in both dimensions, we get 160x120. 160x120 is 19,200 pixels, so a monochrome framebuffer requires 18.75 kilobits of memory (19,200 = 18.75 * 1024).</p>
<h3 id="a-small-bitmap">A Small Bitmap</h3>
<p><img src="/img/posts/framebuffers/david-comparison.png" alt="Michelangelo&rsquo;s David" title="David is a masterpiece of Renaissance sculpture created in marble between 1501 and 1504 by the Italian artist Michelangelo."></p>
<p>A small monochrome framebuffer calls for a striking image: I&rsquo;ve chosen <a href="https://en.wikipedia.org/wiki/David_(Michelangelo)">David by Michelangelo</a>.</p>
<p>The version on the right is the <a href="https://commons.wikimedia.org/wiki/File:Michelangelo%27s_David_-_63_grijswaarden.png">original from Wikipedia</a>; it has 64 shades of grey. I created the middle image by reducing the original to 16 colours using img2fmem with no dithering (we will discuss this tool later in the post). The monochrome image on the left was created by <a href="https://commons.wikimedia.org/wiki/User:Gerbrant/Dithering_algorithms">Gerbrant</a> using <a href="https://en.wikipedia.org/wiki/Floyd%E2%80%93Steinberg_dithering">Floyd-Steinberg dithering</a>.</p>
<h3 id="a-corner-of-the-screen">A Corner of the Screen</h3>
<p>Let&rsquo;s create a top module to output our framebuffer loaded with the monochrome image of David. The Xilinx version uses a new BRAM module, <strong><a href="https://github.com/projf/projf-explore/blob/master/common/xc7/bram_sdp.sv">bram_sdp.sv</a></strong>, but is otherwise similar to other top designs we&rsquo;ve used in previous parts.</p>
<ul>
<li>Xilinx XC7: <strong><a href="https://github.com/projf/projf-explore/blob/master/framebuffers/xc7/top_david_v1.sv">xc7/top_david_v1.sv</a></strong></li>
<li>Lattice iCE40: <em>awaiting BRAM fix</em></li>
</ul>
<p><strong>top_david_v1 memory usage:</strong> 160x120x1: 1x36Kb BRAM on the XC7.</p>
<p>The Xilinx version is shown below:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-verilog" data-lang="verilog"><span style="color:#66d9ef">module</span> top_david_v1 (
    <span style="color:#66d9ef">input</span>  <span style="color:#66d9ef">wire</span> <span style="color:#66d9ef">logic</span> clk_100m,     <span style="color:#75715e">// 100 MHz clock
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">input</span>  <span style="color:#66d9ef">wire</span> <span style="color:#66d9ef">logic</span> btn_rst,      <span style="color:#75715e">// reset button (active low)
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">output</span>      <span style="color:#66d9ef">logic</span> vga_hsync,    <span style="color:#75715e">// horizontal sync
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">output</span>      <span style="color:#66d9ef">logic</span> vga_vsync,    <span style="color:#75715e">// vertical sync
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">output</span>      <span style="color:#66d9ef">logic</span> [<span style="color:#ae81ff">3</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] vga_r,  <span style="color:#75715e">// 4-bit VGA red
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">output</span>      <span style="color:#66d9ef">logic</span> [<span style="color:#ae81ff">3</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] vga_g,  <span style="color:#75715e">// 4-bit VGA green
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">output</span>      <span style="color:#66d9ef">logic</span> [<span style="color:#ae81ff">3</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] vga_b   <span style="color:#75715e">// 4-bit VGA blue
</span><span style="color:#75715e"></span>    );

    <span style="color:#75715e">// generate pixel clock
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">logic</span> clk_pix;
    <span style="color:#66d9ef">logic</span> clk_locked;
    clock_gen clock_640x480 (
       .clk(clk_100m),
       .rst(<span style="color:#f92672">!</span>btn_rst),  <span style="color:#75715e">// reset button is active low
</span><span style="color:#75715e"></span>       .clk_pix,
       .clk_locked
    );

    <span style="color:#75715e">// display timings
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">localparam</span> CORDW <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;  <span style="color:#75715e">// screen coordinate width in bits
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">logic</span> [CORDW<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] sx, sy;
    <span style="color:#66d9ef">logic</span> hsync, vsync;
    display_timings_480p timings_640x480 (
        .clk_pix,
        .rst(<span style="color:#f92672">!</span>clk_locked),  <span style="color:#75715e">// wait for clock lock
</span><span style="color:#75715e"></span>        .sx,
        .sy,
        .hsync,
        .vsync,
        .de()
    );

    <span style="color:#75715e">// size of screen with and without blanking
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">localparam</span> H_RES_FULL <span style="color:#f92672">=</span> <span style="color:#ae81ff">800</span>;
    <span style="color:#66d9ef">localparam</span> V_RES_FULL <span style="color:#f92672">=</span> <span style="color:#ae81ff">525</span>;
    <span style="color:#66d9ef">localparam</span> H_RES <span style="color:#f92672">=</span> <span style="color:#ae81ff">640</span>;
    <span style="color:#66d9ef">localparam</span> V_RES <span style="color:#f92672">=</span> <span style="color:#ae81ff">480</span>;

    <span style="color:#75715e">// framebuffer
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">localparam</span> FB_WIDTH  <span style="color:#f92672">=</span> <span style="color:#ae81ff">160</span>;
    <span style="color:#66d9ef">localparam</span> FB_HEIGHT <span style="color:#f92672">=</span> <span style="color:#ae81ff">120</span>;
    <span style="color:#66d9ef">localparam</span> FB_PIXELS <span style="color:#f92672">=</span> FB_WIDTH <span style="color:#f92672">*</span> FB_HEIGHT;
    <span style="color:#66d9ef">localparam</span> FB_ADDRW  <span style="color:#f92672">=</span> $clog2(FB_PIXELS);
    <span style="color:#66d9ef">localparam</span> FB_DATAW  <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;  <span style="color:#75715e">// colour bits per pixel
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">localparam</span> FB_IMAGE  <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;david_1bit.mem&#34;</span>;

    <span style="color:#66d9ef">logic</span> [FB_ADDRW<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] fb_addr_read;
    <span style="color:#66d9ef">logic</span> [FB_DATAW<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] colr;

    bram_sdp #(
        .WIDTH(FB_DATAW),
        .DEPTH(FB_PIXELS),
        .INIT_F(FB_IMAGE)
    ) framebuffer (
        .clk_read(clk_pix),
        .clk_write(clk_pix),
        .we(<span style="color:#ae81ff">0</span>),
        .addr_write(),
        .addr_read(fb_addr_read),
        .data_in(),
        .data_out(colr)
    );

    <span style="color:#75715e">// flag when framebuffer is active
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">logic</span> fb_active;
    <span style="color:#66d9ef">always_comb</span> fb_active <span style="color:#f92672">=</span> (sy <span style="color:#f92672">&lt;</span> FB_HEIGHT <span style="color:#f92672">&amp;&amp;</span> sx <span style="color:#f92672">&lt;</span> FB_WIDTH);

    <span style="color:#66d9ef">always_ff</span> @(<span style="color:#66d9ef">posedge</span> clk_pix) <span style="color:#66d9ef">begin</span>
        <span style="color:#66d9ef">if</span> (sy <span style="color:#f92672">==</span> V_RES_FULL<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span> sx <span style="color:#f92672">==</span> H_RES_FULL<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">begin</span>
            fb_addr_read <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>;  <span style="color:#75715e">// reset address at end of frame
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">end</span> <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (fb_active) <span style="color:#66d9ef">begin</span>
            fb_addr_read <span style="color:#f92672">&lt;=</span> fb_addr_read <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">end</span>
    <span style="color:#66d9ef">end</span>

    <span style="color:#75715e">// VGA output
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">always_ff</span> @(<span style="color:#66d9ef">posedge</span> clk_pix) <span style="color:#66d9ef">begin</span>
        vga_hsync <span style="color:#f92672">&lt;=</span> hsync;
        vga_vsync <span style="color:#f92672">&lt;=</span> vsync;
        vga_r <span style="color:#f92672">&lt;=</span> (fb_active <span style="color:#f92672">&amp;&amp;</span> colr) <span style="color:#f92672">?</span> <span style="color:#ae81ff">4&#39;hF</span> <span style="color:#f92672">:</span> <span style="color:#ae81ff">4&#39;h0</span>;
        vga_g <span style="color:#f92672">&lt;=</span> (fb_active <span style="color:#f92672">&amp;&amp;</span> colr) <span style="color:#f92672">?</span> <span style="color:#ae81ff">4&#39;hF</span> <span style="color:#f92672">:</span> <span style="color:#ae81ff">4&#39;h0</span>;
        vga_b <span style="color:#f92672">&lt;=</span> (fb_active <span style="color:#f92672">&amp;&amp;</span> colr) <span style="color:#f92672">?</span> <span style="color:#ae81ff">4&#39;hF</span> <span style="color:#f92672">:</span> <span style="color:#ae81ff">4&#39;h0</span>;
    <span style="color:#66d9ef">end</span>
<span style="color:#66d9ef">endmodule</span>
</code></pre></div><p>Build this design and program your board. You should see the dithered image of David looking at you from the top left of your screen.</p>
<blockquote>
<p><strong>Building the Designs</strong><br>
In the <a href="https://github.com/projf/projf-explore/tree/master/framebuffers">Framebuffers</a> section of the git repo, you&rsquo;ll find the design files, a makefile for iCEBreaker, a Vivado project for Arty, and instructions for building the designs for both boards.</p>
</blockquote>
<h2 id="casting-shade">Casting Shade</h2>
<p>We can increase the bits assigned to each pixel to support more colours, or in the case of this image of David, more shades. Our video output is 12-bit, which means there are 16 possible shades of grey.</p>
<p>As with the hedgehog graphic in <a href="/posts/hardware-sprites/">Hardware Sprites</a>, we load the palette from a file, <strong><a href="https://github.com/projf/projf-explore/blob/master/framebuffers/res/david/david_palette.mem">david_palette.mem</a></strong>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-plaintext" data-lang="plaintext">FFF EEE DDD CCC BBB AAA 999 888 777 666 555 444 333 222 111 000
</code></pre></div><p><img src="/img/posts/framebuffers/david-palette.png" alt="Greyscale" title="16 shades: #FFF to #000"></p>
<p>Build the updated top module with 4-bit greyscale David:</p>
<ul>
<li>Xilinx XC7: <strong><a href="https://github.com/projf/projf-explore/blob/master/framebuffers/xc7/top_david_v2.sv">xc7/top_david_v2.sv</a></strong></li>
<li>Lattice iCE40: <em>coming soon</em></li>
</ul>
<p><strong>top_david_v2 memory usage:</strong> 160x120x4: 4x36Kb BRAM on the XC7.</p>
<h3 id="warm-tones">Warm Tones</h3>
<p>Because the palette is separate from the image, we can quickly change it. In <code>top_david_v2.sv</code>, update <code>localparam FB_PALETTE</code> to reference <code>david_palette_warm.mem</code> and rebuild.</p>
<p>The warm palette looks like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-plaintext" data-lang="plaintext">FED EDC DCB CBA BA9 A98 987 876 765 654 543 432 321 210 100 000
</code></pre></div><p><img src="/img/posts/framebuffers/david-palette-warm.png" alt="Warm shades" title="Cosy"></p>
<p>There is also an inverted palette, <code>david_palette_invert.mem</code>, or you can create your own.</p>
<blockquote>
<p><strong>Quick Aside: Palettes</strong><br>
Wikipedia has a lovely <em><a href="https://en.wikipedia.org/wiki/List_of_color_palettes">List of color palettes</a></em> for different systems.</p>
</blockquote>
<h2 id="framebuffer-scaling">Framebuffer Scaling</h2>
<p>Our framebuffer is too small to fill a 640x480 screen, and modern monitors don&rsquo;t support lower resolutions. To make our framebuffer fill the screen, we need to scale it up.</p>
<p>We&rsquo;ve made our framebuffer an integer divisor of our display resolution, so scaling ought to be simple. However, practical scaling isn&rsquo;t quite as simple as it first appears. For example, given our display coordinates <code>sx</code> and <code>sy</code> you <em>could</em> calculate the current framebuffer read address with:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-verilog" data-lang="verilog"><span style="color:#66d9ef">always_comb</span> fb_read_addr <span style="color:#f92672">=</span> sx <span style="color:#f92672">/</span> <span style="color:#ae81ff">4</span> <span style="color:#f92672">+</span> (sy <span style="color:#f92672">/</span> <span style="color:#ae81ff">4</span>) <span style="color:#f92672">*</span> <span style="color:#ae81ff">160</span>;  <span style="color:#75715e">// ?!
</span></code></pre></div><p>This has at least three problems:</p>
<ol>
<li>It doesn&rsquo;t account for memory latency: it takes one or more cycles to read BRAM</li>
<li>It wastes memory bandwidth: every value is read 16 times per frame!</li>
<li>It uses multiplication, which takes up valuable (probably DSP) logic</li>
</ol>
<p>Using a <strong>linebuffer</strong> allows us to avoid all three of these problems. The linebuffer uses three simple dual-port BRAMs, one for each colour channel (red, green, blue). We copy a single 160-pixel line of the framebuffer into the linebuffer, then we read this out for four display lines before going back to the framebuffer for the next line. By making efficient use of memory bandwidth, we can better share memory with other systems, such as a CPU.</p>
<p>Add a linebuffer module - <strong><a href="https://github.com/projf/projf-explore/blob/master/common/linebuffer.sv">linebuffer.sv</a></strong>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-verilog" data-lang="verilog"><span style="color:#66d9ef">module</span> linebuffer #(
    <span style="color:#66d9ef">parameter</span> WIDTH<span style="color:#f92672">=</span><span style="color:#ae81ff">8</span>,   <span style="color:#75715e">// data width of each channel
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">parameter</span> LEN<span style="color:#f92672">=</span><span style="color:#ae81ff">2048</span>,  <span style="color:#75715e">// length of line
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">parameter</span> SCALEW<span style="color:#f92672">=</span><span style="color:#ae81ff">6</span>   <span style="color:#75715e">// horizontal scaling width
</span><span style="color:#75715e"></span>    ) (
    <span style="color:#66d9ef">input</span>  <span style="color:#66d9ef">wire</span> <span style="color:#66d9ef">logic</span> clk_in,
    <span style="color:#66d9ef">input</span>  <span style="color:#66d9ef">wire</span> <span style="color:#66d9ef">logic</span> clk_out,
    <span style="color:#66d9ef">input</span>  <span style="color:#66d9ef">wire</span> <span style="color:#66d9ef">logic</span> en_in,
    <span style="color:#66d9ef">input</span>  <span style="color:#66d9ef">wire</span> <span style="color:#66d9ef">logic</span> en_out,
    <span style="color:#66d9ef">input</span>  <span style="color:#66d9ef">wire</span> <span style="color:#66d9ef">logic</span> rst_in,
    <span style="color:#66d9ef">input</span>  <span style="color:#66d9ef">wire</span> <span style="color:#66d9ef">logic</span> rst_out,
    <span style="color:#66d9ef">input</span>  <span style="color:#66d9ef">wire</span> <span style="color:#66d9ef">logic</span> [SCALEW<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] scale,
    <span style="color:#66d9ef">input</span>  <span style="color:#66d9ef">wire</span> <span style="color:#66d9ef">logic</span> [WIDTH<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] data_in_0, data_in_1, data_in_2,
    <span style="color:#66d9ef">output</span>      <span style="color:#66d9ef">logic</span> [WIDTH<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] data_out_0, data_out_1, data_out_2
    );

    <span style="color:#66d9ef">logic</span> [$clog2(LEN)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] addr_in, addr_out;
    <span style="color:#66d9ef">logic</span> [SCALEW<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] cnt_scale;

    <span style="color:#75715e">// correct scale: if scale is 0, set to 1
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">logic</span> [SCALEW<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] scale_cor;
    <span style="color:#66d9ef">always_comb</span> scale_cor <span style="color:#f92672">=</span> (scale <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#f92672">?</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">:</span> scale;

    <span style="color:#66d9ef">always_ff</span> @(<span style="color:#66d9ef">posedge</span> clk_in) <span style="color:#66d9ef">begin</span>
        <span style="color:#66d9ef">if</span> (en_in) addr_in <span style="color:#f92672">&lt;=</span> (addr_in <span style="color:#f92672">==</span> LEN<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">?</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">:</span> addr_in <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">if</span> (rst_in) addr_in <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>;  <span style="color:#75715e">// reset takes precedence
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">end</span>

    <span style="color:#66d9ef">always_ff</span> @(<span style="color:#66d9ef">posedge</span> clk_out) <span style="color:#66d9ef">begin</span>
        <span style="color:#66d9ef">if</span> (en_out) <span style="color:#66d9ef">begin</span>
            cnt_scale <span style="color:#f92672">&lt;=</span> (cnt_scale <span style="color:#f92672">==</span> scale_cor<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">?</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">:</span> cnt_scale <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
            <span style="color:#66d9ef">if</span> (cnt_scale <span style="color:#f92672">==</span> scale_cor<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) addr_out <span style="color:#f92672">&lt;=</span> (addr_out <span style="color:#f92672">==</span> LEN<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">?</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">:</span> addr_out <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">end</span>
        <span style="color:#66d9ef">if</span> (rst_out) <span style="color:#66d9ef">begin</span>  <span style="color:#75715e">// reset takes precedence
</span><span style="color:#75715e"></span>            addr_out <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>;
            cnt_scale <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">end</span>
    <span style="color:#66d9ef">end</span>

    <span style="color:#75715e">// channel 0
</span><span style="color:#75715e"></span>    bram_sdp #(.WIDTH(WIDTH), .DEPTH(LEN)) ch0 (
        .clk_write(clk_in),
        .clk_read(clk_out),
        .we(en_in),
        .addr_write(addr_in),
        .addr_read(addr_out),
        .data_in(data_in_0),
        .data_out(data_out_0)
    );

    <span style="color:#75715e">// channel 1
</span><span style="color:#75715e"></span>    bram_sdp #(.WIDTH(WIDTH), .DEPTH(LEN)) ch1 (
        .clk_write(clk_in),
        .clk_read(clk_out),
        .we(en_in),
        .addr_write(addr_in),
        .addr_read(addr_out),
        .data_in(data_in_1),
        .data_out(data_out_1)
    );

    <span style="color:#75715e">// channel 2
</span><span style="color:#75715e"></span>    bram_sdp #(.WIDTH(WIDTH), .DEPTH(LEN)) ch2 (
        .clk_write(clk_in),
        .clk_read(clk_out),
        .we(en_in),
        .addr_write(addr_in),
        .addr_read(addr_out),
        .data_in(data_in_2),
        .data_out(data_out_2)
    );
<span style="color:#66d9ef">endmodule</span>
</code></pre></div><p>The linebuffer module handles horizontal scaling, but not vertical scaling. Vertical scaling requires the repetition of lines; this is dealt with by the top module. We use three separate BRAM instances because colours are output separately to the display and 4-bit-wide buffers are a better fit for BRAM hardware than a single 12-wide buffer.</p>
<blockquote>
<p><strong>Quick Aside: Clock Domain Crossing</strong><br>
The linebuffer module has another significant benefit: it allows the pixel clock to be different from the rest of the design. For example, you could draw on the framebuffer at 100 MHz (linebuffer data_in) and display it on a 720p60 screen with a 74.25 MHz pixel clock (linebuffer data_out). CDC is usually achieved with a FIFO, but the linebuffer does it <em>while</em> providing efficient scaling.</p>
</blockquote>
<h3 id="top-scaling">Top Scaling</h3>
<p>To drive the linebuffer we need to enable and reset its data inputs and outputs at appropriate times. This extract from the top module (source link below listing), shows scaling up by four times:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-verilog" data-lang="verilog">    <span style="color:#75715e">// linebuffer (LB)
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">localparam</span> LB_SCALE_V <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>;               <span style="color:#75715e">// scale vertical drawing
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">localparam</span> LB_SCALE_H <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>;               <span style="color:#75715e">// scale horizontal drawing
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">localparam</span> LB_LEN <span style="color:#f92672">=</span> H_RES <span style="color:#f92672">/</span> LB_SCALE_H;  <span style="color:#75715e">// line length
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">localparam</span> LB_WIDTH <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>;                 <span style="color:#75715e">// bits per colour channel
</span><span style="color:#75715e"></span>
    <span style="color:#75715e">// LB data in from FB
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">logic</span> lb_en_in, lb_en_in_1;  <span style="color:#75715e">// allow for BRAM latency correction
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">logic</span> [LB_WIDTH<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] lb_in_0, lb_in_1, lb_in_2;

    <span style="color:#75715e">// correct vertical scale: if scale is 0, set to 1
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">logic</span> [$clog2(LB_SCALE_V<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] scale_v_cor;
    <span style="color:#66d9ef">always_comb</span> scale_v_cor <span style="color:#f92672">=</span> (LB_SCALE_V <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#f92672">?</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">:</span> LB_SCALE_V;

    <span style="color:#75715e">// count screen lines for vertical scaling - read when cnt_scale_v==0
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">logic</span> [$clog2(LB_SCALE_V)<span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] cnt_scale_v;
    <span style="color:#66d9ef">always_ff</span> @(<span style="color:#66d9ef">posedge</span> clk_pix) <span style="color:#66d9ef">begin</span>
        <span style="color:#66d9ef">if</span> (sx <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
            cnt_scale_v <span style="color:#f92672">&lt;=</span> (cnt_scale_v <span style="color:#f92672">==</span> scale_v_cor<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">?</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">:</span> cnt_scale_v <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">if</span> (sy <span style="color:#f92672">==</span> V_RES_FULL<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) cnt_scale_v <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">end</span>

    <span style="color:#66d9ef">logic</span> [$clog2(FB_WIDTH)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] fb_h_cnt;  <span style="color:#75715e">// counter for FB pixels on line
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">always_ff</span> @(<span style="color:#66d9ef">posedge</span> clk_pix) <span style="color:#66d9ef">begin</span>
        <span style="color:#66d9ef">if</span> (sy <span style="color:#f92672">==</span> V_RES_FULL<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span> sx <span style="color:#f92672">==</span> H_RES<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) fb_addr_read <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>;

        <span style="color:#75715e">// reset horizontal counter at the start of blanking on reading lines
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (cnt_scale_v <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> sx <span style="color:#f92672">==</span> H_RES) <span style="color:#66d9ef">begin</span>
            <span style="color:#66d9ef">if</span> (fb_addr_read <span style="color:#f92672">&lt;</span> FB_PIXELS<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) fb_h_cnt <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>;  <span style="color:#75715e">// read all pixels?
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">end</span>

        <span style="color:#75715e">// read each pixel on FB line and write to LB
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (fb_h_cnt <span style="color:#f92672">&lt;</span> FB_WIDTH) <span style="color:#66d9ef">begin</span>
            lb_en_in <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span>;
            fb_h_cnt <span style="color:#f92672">&lt;=</span> fb_h_cnt <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
            fb_addr_read <span style="color:#f92672">&lt;=</span> fb_addr_read <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">end</span> <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">begin</span>
            lb_en_in <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">end</span>

        <span style="color:#75715e">// enable LB data in with latency correction
</span><span style="color:#75715e"></span>        lb_en_in_1 <span style="color:#f92672">&lt;=</span> lb_en_in;
    <span style="color:#66d9ef">end</span>

    <span style="color:#75715e">// LB data out to display
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">logic</span> [LB_WIDTH<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] lb_out_0, lb_out_1, lb_out_2;

    linebuffer #(
        .WIDTH(LB_WIDTH),
        .LEN(LB_LEN)
        ) lb_inst (
        .clk_in(clk_pix),
        .clk_out(clk_pix),
        .en_in(lb_en_in_1),  <span style="color:#75715e">// correct for BRAM latency
</span><span style="color:#75715e"></span>        .en_out(sy <span style="color:#f92672">&lt;</span> V_RES <span style="color:#f92672">&amp;&amp;</span> sx <span style="color:#f92672">&lt;</span> H_RES),
        .rst_in(sx <span style="color:#f92672">==</span> H_RES),  <span style="color:#75715e">// reset at start of horizontal blanking
</span><span style="color:#75715e"></span>        .rst_out(sx <span style="color:#f92672">==</span> H_RES),
        .scale(LB_SCALE_H),
        .data_in_0(lb_in_0),
        .data_in_1(lb_in_1),
        .data_in_2(lb_in_2),
        .data_out_0(lb_out_0),
        .data_out_1(lb_out_1),
        .data_out_2(lb_out_2)
    );
</code></pre></div><p>Build the updated top module with scaled David:</p>
<ul>
<li>Xilinx XC7: <strong><a href="https://github.com/projf/projf-explore/blob/master/framebuffers/xc7/top_david.sv">xc7/top_david.sv</a></strong></li>
<li>Lattice iCE40: <em>coming soon</em></li>
</ul>
<p><strong>top_david memory usage:</strong> <code>160x120x4 + linebuffer: 4.5 x 36Kb BRAMs on the XC7.</code></p>
<blockquote>
<p><strong>Quick Aside: BRAM Optimization</strong><br>
You&rsquo;d expect the linebuffer to use 1.5 BRAMs (36Kb), but because all three colour channels are the same for the greyscale palette, the linebuffer is reduced from 3x18Kb BRAMs to 1x18Kb. The warm palette does use 1.5 BRAMs for a total of 5.5.</p>
</blockquote>
<h2 id="the-blue-planet">The Blue Planet</h2>
<p><em>This next section is for the Arty (XC7) only, sorry. The iCEBreaker doesn&rsquo;t have enough BRAM for larger framebuffers. If there&rsquo;s enough interest, I&rsquo;ll consider creating a version using SPRAM.</em></p>
<p><img src="/img/posts/framebuffers/earth.jpg" alt="Earth" title="The eastern hemisphere of Earth from space, courtesy of NASA."></p>
<p>Our design is nice and flexible, so it&rsquo;s not hard to adapt for a larger, more colourful image. If you&rsquo;ve got an Arty board, or FPGA with at least 640 Kb of BRAM, try this image of Earth (courtesy of <a href="https://www.nasa.gov/centers/ames/news/releases/2002/02images/earthimages/earth.html">NASA</a>):</p>
<ul>
<li>Earth Image: <strong><a href="https://github.com/projf/projf-explore/blob/master/framebuffers/res/earth/earth.mem">earth.mem</a></strong></li>
<li>Earth Palette: <strong><a href="https://github.com/projf/projf-explore/blob/master/framebuffers/res/earth/earth_palette.mem">earth_palette.mem</a></strong></li>
</ul>
<p>There are three changes required to the top module to display the Earth.</p>
<ol>
<li>We increase the framebuffer size (320x240) and depth (6 bits for 64 colours):</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-verilog" data-lang="verilog">    <span style="color:#75715e">// framebuffer
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">localparam</span> FB_WIDTH   <span style="color:#f92672">=</span> <span style="color:#ae81ff">320</span>;
    <span style="color:#66d9ef">localparam</span> FB_HEIGHT  <span style="color:#f92672">=</span> <span style="color:#ae81ff">240</span>;
    <span style="color:#66d9ef">localparam</span> FB_PIXELS  <span style="color:#f92672">=</span> FB_WIDTH <span style="color:#f92672">*</span> FB_HEIGHT;
    <span style="color:#66d9ef">localparam</span> FB_ADDRW   <span style="color:#f92672">=</span> $clog2(FB_PIXELS);
    <span style="color:#66d9ef">localparam</span> FB_DATAW   <span style="color:#f92672">=</span> <span style="color:#ae81ff">6</span>;  <span style="color:#75715e">// colour bits per pixel
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">localparam</span> FB_IMAGE   <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;earth.mem&#34;</span>;
    <span style="color:#66d9ef">localparam</span> FB_PALETTE <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;earth_palette.mem&#34;</span>;
</code></pre></div><ol start="2">
<li>We reduce the linebuffer scaling factor (from 4 to 2):</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-verilog" data-lang="verilog">    <span style="color:#75715e">// linebuffer (LB)
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">localparam</span> LB_SCALE_V <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;               <span style="color:#75715e">// scale vertical drawing
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">localparam</span> LB_SCALE_H <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;               <span style="color:#75715e">// scale horizontal drawing
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">localparam</span> LB_LEN <span style="color:#f92672">=</span> H_RES <span style="color:#f92672">/</span> LB_SCALE_H;  <span style="color:#75715e">// line length
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">localparam</span> LB_WIDTH <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>;                 <span style="color:#75715e">// bits per colour channel
</span></code></pre></div><ol start="3">
<li>And we expand the colour lookup table to 64 entries:</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-verilog" data-lang="verilog">    <span style="color:#75715e">// colour lookup table (ROM) 64x12-bit entries
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">logic</span> [<span style="color:#ae81ff">11</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] clut_colr;
    rom_async #(
        .WIDTH(<span style="color:#ae81ff">12</span>),
        .DEPTH(<span style="color:#ae81ff">64</span>),
        .INIT_F(FB_PALETTE)
    ) clut (
        .addr(colr_idx),
        .data(clut_colr)
    );
</code></pre></div><p>Try building the top_earth module:</p>
<ul>
<li>Xilinx XC7: <strong><a href="https://github.com/projf/projf-explore/blob/master/framebuffers/xc7/top_earth.sv">xc7/top_earth.sv</a></strong></li>
<li>Lattice iCE40: <em>not available</em></li>
</ul>
<p><strong>top_earth memory usage:</strong> 320x240x6 + linebuffer: 19.5 x 36Kb BRAMs on the XC7.</p>
<h2 id="creating-your-own-images">Creating Your Own Images</h2>
<p>You can easily create your own images using <strong>img2fmem</strong>. The script is written in Python and uses the Pillow image library to perform the conversion. You can find it in the Project F <a href="https://github.com/projf/fpgatools">FPGA Tools</a> repo. Make sure your images are exactly the same size as the framebuffer you&rsquo;re using.</p>
<p>To convert an image called <code>acme.png</code> to 4-bit colour with 12-bit palette for use with <code>$readmemh</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">img2fmem.py acme.png <span style="color:#ae81ff">4</span> mem <span style="color:#ae81ff">12</span>
</code></pre></div><p>For details on installation and command line options, see the <a href="https://github.com/projf/fpgatools/blob/master/README.md">img2fmem README</a>.</p>
<h2 id="fizzle-out">Fizzle Out</h2>
<p>So far we&rsquo;ve read from our framebuffer, but we haven&rsquo;t updated our display in any way. In <a href="/posts/fpga-ad-astra/">FPGA Ad Astra</a>, we used linear feedback shift registers (LFSRs) to create animated starfields. LFSRs have another graphical use: creating random dissolve effects, as used in <a href="https://en.wikipedia.org/wiki/Wolfenstein_3D">Wolfenstein 3D</a> and explained by Fabien Sanglard in his excellent post: <a href="https://fabiensanglard.net/fizzlefade/">Fizzlefade</a>.</p>
<p>We can use LFSRs to dissolve our image of David using a mask. Our mask is another bitmap, but with only 1 bit per pixel. If a mask pixel is set to 0, then the framebuffer pixel colour is shown, otherwise we show red. By using a mask, rather than altering the original bitmap, we can fade the image back in again or apply other effects.</p>
<ul>
<li>Xilinx XC7: <strong><a href="https://github.com/projf/projf-explore/blob/master/framebuffers/xc7/top_david_fizzle.sv">xc7/top_david_fizzle.sv</a></strong></li>
<li>Lattice iCE40: <em>coming soon</em></li>
</ul>
<p>Xilinx version shown below:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-verilog" data-lang="verilog"><span style="color:#66d9ef">module</span> top_david_fizzle (
    <span style="color:#66d9ef">input</span>  <span style="color:#66d9ef">wire</span> <span style="color:#66d9ef">logic</span> clk_100m,     <span style="color:#75715e">// 100 MHz clock
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">input</span>  <span style="color:#66d9ef">wire</span> <span style="color:#66d9ef">logic</span> btn_rst,      <span style="color:#75715e">// reset button (active low)
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">output</span>      <span style="color:#66d9ef">logic</span> vga_hsync,    <span style="color:#75715e">// horizontal sync
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">output</span>      <span style="color:#66d9ef">logic</span> vga_vsync,    <span style="color:#75715e">// vertical sync
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">output</span>      <span style="color:#66d9ef">logic</span> [<span style="color:#ae81ff">3</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] vga_r,  <span style="color:#75715e">// 4-bit VGA red
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">output</span>      <span style="color:#66d9ef">logic</span> [<span style="color:#ae81ff">3</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] vga_g,  <span style="color:#75715e">// 4-bit VGA green
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">output</span>      <span style="color:#66d9ef">logic</span> [<span style="color:#ae81ff">3</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] vga_b   <span style="color:#75715e">// 4-bit VGA blue
</span><span style="color:#75715e"></span>    );

    <span style="color:#75715e">// generate pixel clock
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">logic</span> clk_pix;
    <span style="color:#66d9ef">logic</span> clk_locked;
    clock_gen clock_640x480 (
       .clk(clk_100m),
       .rst(<span style="color:#f92672">!</span>btn_rst),  <span style="color:#75715e">// reset button is active low
</span><span style="color:#75715e"></span>       .clk_pix,
       .clk_locked
    );

    <span style="color:#75715e">// display timings
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">localparam</span> CORDW <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;  <span style="color:#75715e">// screen coordinate width in bits
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">logic</span> [CORDW<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] sx, sy;
    <span style="color:#66d9ef">logic</span> hsync, vsync, de;
    display_timings_480p timings_640x480 (
        .clk_pix,
        .rst(<span style="color:#f92672">!</span>clk_locked),  <span style="color:#75715e">// wait for clock lock
</span><span style="color:#75715e"></span>        .sx,
        .sy,
        .hsync,
        .vsync,
        .de
    );

    <span style="color:#75715e">// size of screen with and without blanking
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">localparam</span> H_RES_FULL <span style="color:#f92672">=</span> <span style="color:#ae81ff">800</span>;
    <span style="color:#66d9ef">localparam</span> V_RES_FULL <span style="color:#f92672">=</span> <span style="color:#ae81ff">525</span>;
    <span style="color:#66d9ef">localparam</span> H_RES <span style="color:#f92672">=</span> <span style="color:#ae81ff">640</span>;
    <span style="color:#66d9ef">localparam</span> V_RES <span style="color:#f92672">=</span> <span style="color:#ae81ff">480</span>;

    <span style="color:#75715e">// framebuffer (FB)
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">localparam</span> FB_WIDTH   <span style="color:#f92672">=</span> <span style="color:#ae81ff">160</span>;
    <span style="color:#66d9ef">localparam</span> FB_HEIGHT  <span style="color:#f92672">=</span> <span style="color:#ae81ff">120</span>;
    <span style="color:#66d9ef">localparam</span> FB_PIXELS  <span style="color:#f92672">=</span> FB_WIDTH <span style="color:#f92672">*</span> FB_HEIGHT;
    <span style="color:#66d9ef">localparam</span> FB_ADDRW   <span style="color:#f92672">=</span> $clog2(FB_PIXELS);
    <span style="color:#66d9ef">localparam</span> FB_DATAW   <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>;  <span style="color:#75715e">// colour bits per pixel
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">localparam</span> FB_IMAGE   <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;david.mem&#34;</span>;
    <span style="color:#66d9ef">localparam</span> FB_PALETTE <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;david_palette.mem&#34;</span>;

    <span style="color:#66d9ef">logic</span> [FB_ADDRW<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] fb_addr_read;
    <span style="color:#66d9ef">logic</span> [FB_DATAW<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] colr_idx;

    bram_sdp #(
        .WIDTH(FB_DATAW),
        .DEPTH(FB_PIXELS),
        .INIT_F(FB_IMAGE)
    ) fb_inst (
        .clk_read(clk_pix),
        .clk_write(clk_pix),
        .we(<span style="color:#ae81ff">0</span>),
        .addr_write(),
        .addr_read(fb_addr_read),
        .data_in(),
        .data_out(colr_idx)
    );

    <span style="color:#75715e">// fizzlebuffer (FZ)
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">logic</span> [FB_ADDRW<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] fz_addr_write;
    <span style="color:#66d9ef">logic</span> fz_en_in, fz_en_out;
    <span style="color:#66d9ef">logic</span> fz_we;

    bram_sdp #(
        .WIDTH(<span style="color:#ae81ff">1</span>),
        .DEPTH(FB_PIXELS),
        .INIT_F(<span style="color:#e6db74">&#34;&#34;</span>)
    ) fz_inst (
        .clk_read(clk_pix),
        .clk_write(clk_pix),
        .we(fz_we),
        .addr_write(fz_addr_write),
        .addr_read(fb_addr_read),  <span style="color:#75715e">// share read address with framebuffer
</span><span style="color:#75715e"></span>        .data_in(fz_en_in),
        .data_out(fz_en_out)
    );

    <span style="color:#75715e">// 15-bit LFSR (160x120 &lt; 2^15)
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">logic</span> lfsr_en;
    <span style="color:#66d9ef">logic</span> [<span style="color:#ae81ff">14</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] lfsr;
    lfsr #(
        .LEN(<span style="color:#ae81ff">15</span>),
        .TAPS(<span style="color:#ae81ff">15</span><span style="color:#ae81ff">&#39;b110000000000000</span>)
    ) lsfr_fz (
        .clk(clk_pix),
        .rst(<span style="color:#f92672">!</span>clk_locked),
        .en(lfsr_en),
        .sreg(lfsr)
    );

    <span style="color:#66d9ef">localparam</span> FADE_WAIT <span style="color:#f92672">=</span> <span style="color:#ae81ff">240</span>;   <span style="color:#75715e">// wait for 240 frames before fading
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">localparam</span> FADE_RATE <span style="color:#f92672">=</span> <span style="color:#ae81ff">3200</span>;  <span style="color:#75715e">// every 3200 pixel clocks update LFSR
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">logic</span> [$clog2(FADE_WAIT)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] cnt_fade_wait;
    <span style="color:#66d9ef">logic</span> [$clog2(FADE_RATE)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] cnt_fade_rate;
    <span style="color:#66d9ef">always_ff</span> @(<span style="color:#66d9ef">posedge</span> clk_pix) <span style="color:#66d9ef">begin</span>
        <span style="color:#66d9ef">if</span> (sy <span style="color:#f92672">==</span> V_RES <span style="color:#f92672">&amp;&amp;</span> sx <span style="color:#f92672">==</span> H_RES) <span style="color:#66d9ef">begin</span>  <span style="color:#75715e">// start of blanking
</span><span style="color:#75715e"></span>            cnt_fade_wait <span style="color:#f92672">&lt;=</span> (cnt_fade_wait <span style="color:#f92672">!=</span> FADE_WAIT<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">?</span>
                cnt_fade_wait <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">:</span> cnt_fade_wait;
        <span style="color:#66d9ef">end</span>
        <span style="color:#66d9ef">if</span> (cnt_fade_wait <span style="color:#f92672">==</span> FADE_WAIT<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">begin</span>
            cnt_fade_rate <span style="color:#f92672">&lt;=</span> (cnt_fade_rate <span style="color:#f92672">==</span> FADE_RATE) <span style="color:#f92672">?</span>
                <span style="color:#ae81ff">0</span> <span style="color:#f92672">:</span> cnt_fade_rate <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">end</span>
    <span style="color:#66d9ef">end</span>

    <span style="color:#66d9ef">always_comb</span> <span style="color:#66d9ef">begin</span>
        fz_addr_write <span style="color:#f92672">=</span> lfsr;
        <span style="color:#66d9ef">if</span> (cnt_fade_rate <span style="color:#f92672">==</span> FADE_RATE) <span style="color:#66d9ef">begin</span>
            lfsr_en <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
            fz_we <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
            fz_en_in <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">end</span> <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">begin</span>
            lfsr_en <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
            fz_we <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
            fz_en_in <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">end</span>
    <span style="color:#66d9ef">end</span>

    <span style="color:#75715e">// linebuffer (LB)
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">localparam</span> LB_SCALE_V <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>;               <span style="color:#75715e">// scale vertical drawing
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">localparam</span> LB_SCALE_H <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>;               <span style="color:#75715e">// scale horizontal drawing
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">localparam</span> LB_LEN <span style="color:#f92672">=</span> H_RES <span style="color:#f92672">/</span> LB_SCALE_H;  <span style="color:#75715e">// line length
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">localparam</span> LB_WIDTH <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>;                 <span style="color:#75715e">// bits per colour channel
</span><span style="color:#75715e"></span>
    <span style="color:#75715e">// LB data in from FB
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">logic</span> lb_en_in, lb_en_in_1;  <span style="color:#75715e">// allow for BRAM latency correction
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">logic</span> [LB_WIDTH<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] lb_in_0, lb_in_1, lb_in_2;

    <span style="color:#75715e">// correct vertical scale: if scale is 0, set to 1
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">logic</span> [$clog2(LB_SCALE_V<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] scale_v_cor;
    <span style="color:#66d9ef">always_comb</span> scale_v_cor <span style="color:#f92672">=</span> (LB_SCALE_V <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#f92672">?</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">:</span> LB_SCALE_V;

    <span style="color:#75715e">// count screen lines for vertical scaling - read when cnt_scale_v==0
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">logic</span> [$clog2(LB_SCALE_V)<span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] cnt_scale_v;
    <span style="color:#66d9ef">always_ff</span> @(<span style="color:#66d9ef">posedge</span> clk_pix) <span style="color:#66d9ef">begin</span>
        <span style="color:#66d9ef">if</span> (sx <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
            cnt_scale_v <span style="color:#f92672">&lt;=</span> (cnt_scale_v <span style="color:#f92672">==</span> scale_v_cor<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">?</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">:</span> cnt_scale_v <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">if</span> (sy <span style="color:#f92672">==</span> V_RES_FULL<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) cnt_scale_v <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">end</span>

    <span style="color:#66d9ef">logic</span> [$clog2(FB_WIDTH)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] fb_h_cnt;  <span style="color:#75715e">// counter for FB pixels on line
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">always_ff</span> @(<span style="color:#66d9ef">posedge</span> clk_pix) <span style="color:#66d9ef">begin</span>
        <span style="color:#66d9ef">if</span> (sy <span style="color:#f92672">==</span> V_RES_FULL<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span> sx <span style="color:#f92672">==</span> H_RES<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) fb_addr_read <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>;

        <span style="color:#75715e">// reset horizontal counter at the start of blanking on reading lines
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (cnt_scale_v <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> sx <span style="color:#f92672">==</span> H_RES) <span style="color:#66d9ef">begin</span>
            <span style="color:#66d9ef">if</span> (fb_addr_read <span style="color:#f92672">&lt;</span> FB_PIXELS<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) fb_h_cnt <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>;  <span style="color:#75715e">// read all pixels?
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">end</span>

        <span style="color:#75715e">// read each pixel on FB line and write to LB
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (fb_h_cnt <span style="color:#f92672">&lt;</span> FB_WIDTH) <span style="color:#66d9ef">begin</span>
            lb_en_in <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span>;
            fb_h_cnt <span style="color:#f92672">&lt;=</span> fb_h_cnt <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
            fb_addr_read <span style="color:#f92672">&lt;=</span> fb_addr_read <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">end</span> <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">begin</span>
            lb_en_in <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">end</span>

        <span style="color:#75715e">// enable LB data in with latency correction
</span><span style="color:#75715e"></span>        lb_en_in_1 <span style="color:#f92672">&lt;=</span> lb_en_in;
    <span style="color:#66d9ef">end</span>

    <span style="color:#75715e">// LB data out to display
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">logic</span> [LB_WIDTH<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] lb_out_0, lb_out_1, lb_out_2;

    linebuffer #(
        .WIDTH(LB_WIDTH),
        .LEN(LB_LEN)
        ) lb_inst (
        .clk_in(clk_pix),
        .clk_out(clk_pix),
        .en_in(lb_en_in_1),  <span style="color:#75715e">// correct for BRAM latency
</span><span style="color:#75715e"></span>        .en_out(sy <span style="color:#f92672">&lt;</span> V_RES <span style="color:#f92672">&amp;&amp;</span> sx <span style="color:#f92672">&lt;</span> H_RES),
        .rst_in(sx <span style="color:#f92672">==</span> H_RES),  <span style="color:#75715e">// reset at start of horizontal blanking
</span><span style="color:#75715e"></span>        .rst_out(sx <span style="color:#f92672">==</span> H_RES),
        .scale(LB_SCALE_H),
        .data_in_0(lb_in_0),
        .data_in_1(lb_in_1),
        .data_in_2(lb_in_2),
        .data_out_0(lb_out_0),
        .data_out_1(lb_out_1),
        .data_out_2(lb_out_2)
    );

    <span style="color:#75715e">// colour lookup table (ROM) 16x12-bit entries
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">logic</span> [<span style="color:#ae81ff">11</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] clut_colr;
    rom_async #(
        .WIDTH(<span style="color:#ae81ff">12</span>),
        .DEPTH(<span style="color:#ae81ff">16</span>),
        .INIT_F(FB_PALETTE)
    ) clut (
        .addr(colr_idx),
        .data(clut_colr)
    );

    <span style="color:#75715e">// map colour index to palette using CLUT and read into LB
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">always_ff</span> @(<span style="color:#66d9ef">posedge</span> clk_pix) <span style="color:#66d9ef">begin</span>
        {lb_in_2, lb_in_1, lb_in_0} <span style="color:#f92672">&lt;=</span> fz_en_out <span style="color:#f92672">?</span> <span style="color:#ae81ff">12&#39;hA00</span> <span style="color:#f92672">:</span> clut_colr;
    <span style="color:#66d9ef">end</span>

    <span style="color:#75715e">// VGA output
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">always_ff</span> @(<span style="color:#66d9ef">posedge</span> clk_pix) <span style="color:#66d9ef">begin</span>
        vga_hsync <span style="color:#f92672">&lt;=</span> hsync;
        vga_vsync <span style="color:#f92672">&lt;=</span> vsync;
        vga_r <span style="color:#f92672">&lt;=</span> de <span style="color:#f92672">?</span> lb_out_2 <span style="color:#f92672">:</span> <span style="color:#ae81ff">4&#39;h0</span>;
        vga_g <span style="color:#f92672">&lt;=</span> de <span style="color:#f92672">?</span> lb_out_1 <span style="color:#f92672">:</span> <span style="color:#ae81ff">4&#39;h0</span>;
        vga_b <span style="color:#f92672">&lt;=</span> de <span style="color:#f92672">?</span> lb_out_0 <span style="color:#f92672">:</span> <span style="color:#ae81ff">4&#39;h0</span>;
    <span style="color:#66d9ef">end</span>
<span style="color:#66d9ef">endmodule</span>
</code></pre></div><p>You may have noticed that the top-left pixel doesn&rsquo;t change; this is because the LFSR produces every value except zero. To fix this, add some logic to specifically update the pixel at address zero when fading.</p>
<h2 id="explore">Explore</h2>
<p>I hope you enjoyed this instalment of <em>Exploring FPGA Graphics</em>, but nothing beats creating your own designs. Here are a few suggestions to get you started:</p>
<ul>
<li>Load your own picture into the framebuffer using img2mem</li>
<li>Cross-fade between two images</li>
<li>Fade an image by adjusting the intensity of the palette entries</li>
<li><a href="https://en.wikipedia.org/wiki/Edge_detection">Detect edges</a> and highlight them in another colour</li>
</ul>
<h2 id="next-time">Next Time</h2>
<p>In the next part, we&rsquo;ll implement Conway&rsquo;s Game of Life in <a href="/posts/life-on-screen/">Life on Screen</a>.</p>

      
      <div class="related">

<h3>Similar articles:</h3>
<ul>
	
	<li><a href="/posts/hardware-sprites/">Hardware Sprites</a></li>
	
	<li><a href="/posts/life-on-screen/">Life on Screen</a></li>
	
	<li><a href="/posts/fpga-pong/">FPGA Pong</a></li>
	
	<li><a href="/posts/fpga-ad-astra/">FPGA Ad Astra</a></li>
	
	<li><a href="/posts/fpga-graphics/">Exploring FPGA Graphics</a></li>
	
</ul>
</div>
      
    </div>
    
  </div>
</section>

    <script src="/js/copycode.js"></script>



<section class="section">
  <div class="container has-text-centered">
    <p>©2021 Will Green, Project F</p>
    
  </div>
</section>


<script src="https://narwhal.projectf.io/script.js" site="EVCGKVDN" defer></script>
</body>
</html>

