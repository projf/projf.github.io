<!doctype html><html class="not-ready lg:text-base" style=--bg:#fff lang=en-gb><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Framebuffers - Project F</title>
<meta name=theme-color><meta name=description content="Welcome back to Exploring FPGA Graphics. In the previous part, we worked with sprites, but another approach is needed as graphics become more complex. Instead of drawing directly to the screen, we draw to a bitmap, which is read out to the screen. This post provides an introduction to framebuffers and how to scale them up. We&rsquo;ll also learn how to fizzlefade graphics Wolfenstein 3D style.
In this series, we learn about graphics at the hardware level and get a feel for the power of FPGAs."><meta name=author content="Will Green"><link rel="preload stylesheet" as=style href=https://projectf.io/main.min.css><link rel=preload as=image href=https://projectf.io/theme.png><link rel=preload as=image href=https://projectf.io/twitter.svg><link rel=preload as=image href=https://projectf.io/github.svg><link rel=preload as=image href=https://projectf.io/mastodon.svg><link rel=preload as=image href=https://projectf.io/rss.svg><script defer src=https://projectf.io/highlight.min.js onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://projectf.io/favicon.ico><link rel=apple-touch-icon href=https://projectf.io/apple-touch-icon.png><meta name=generator content="Hugo 0.121.2"><script src=https://cdn-eu.usefathom.com/script.js data-site=EVCGKVDN defer></script><meta itemprop=name content="Framebuffers"><meta itemprop=description content="Welcome back to Exploring FPGA Graphics. In the previous part, we worked with sprites, but another approach is needed as graphics become more complex. Instead of drawing directly to the screen, we draw to a bitmap, which is read out to the screen. This post provides an introduction to framebuffers and how to scale them up. We&rsquo;ll also learn how to fizzlefade graphics Wolfenstein 3D style.
In this series, we learn about graphics at the hardware level and get a feel for the power of FPGAs."><meta itemprop=datePublished content="2020-10-30T00:00:00+00:00"><meta itemprop=dateModified content="2023-07-14T00:00:00+00:00"><meta itemprop=wordCount content="4859"><meta itemprop=image content="https://projectf.io/img/posts/framebuffers/social-card.png"><meta itemprop=keywords content="graphics,arty-a7,icebreaker,verilator,"><meta property="og:title" content="Framebuffers"><meta property="og:description" content="Welcome back to Exploring FPGA Graphics. In the previous part, we worked with sprites, but another approach is needed as graphics become more complex. Instead of drawing directly to the screen, we draw to a bitmap, which is read out to the screen. This post provides an introduction to framebuffers and how to scale them up. We&rsquo;ll also learn how to fizzlefade graphics Wolfenstein 3D style.
In this series, we learn about graphics at the hardware level and get a feel for the power of FPGAs."><meta property="og:type" content="article"><meta property="og:url" content="https://projectf.io/posts/framebuffers/"><meta property="og:image" content="https://projectf.io/img/posts/framebuffers/social-card.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-10-30T00:00:00+00:00"><meta property="article:modified_time" content="2023-07-14T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://projectf.io/img/posts/framebuffers/social-card.png"><meta name=twitter:title content="Framebuffers"><meta name=twitter:description content="Welcome back to Exploring FPGA Graphics. In the previous part, we worked with sprites, but another approach is needed as graphics become more complex. Instead of drawing directly to the screen, we draw to a bitmap, which is read out to the screen. This post provides an introduction to framebuffers and how to scale them up. We&rsquo;ll also learn how to fizzlefade graphics Wolfenstein 3D style.
In this series, we learn about graphics at the hardware level and get a feel for the power of FPGAs."><link rel=canonical href=https://projectf.io/posts/framebuffers/></head><body class="text-black duration-200 ease-out dark:text-white"><header class="mx-auto flex h-[4.5rem] max-w-4xl px-8 lg:justify-center"><div class="relative z-50 mr-auto flex items-center"><a class="-translate-x-[1px] -translate-y-[1px] text-2xl font-semibold" href=https://projectf.io>Project F</a><div class="btn-dark text-[0] ml-4 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.png)_left_center/_auto_theme('spacing.6')_no-repeat] [transition:_background-position_0.4s_steps(5)] dark:[background-position:right]" role=button aria-label=Dark></div></div><div class="btn-menu relative z-50 -mr-8 flex h-[4.5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden" role=button aria-label=Menu></div><script>const htmlClass=document.documentElement.classList;setTimeout(()=>{htmlClass.remove("not-ready")},10);const btnMenu=document.querySelector(".btn-menu");btnMenu.addEventListener("click",()=>{htmlClass.toggle("open")});const metaTheme=document.querySelector('meta[name="theme-color"]'),lightBg="#fff".replace(/"/g,""),setDark=e=>{metaTheme.setAttribute("content",e?"#000":lightBg),htmlClass[e?"add":"remove"]("dark"),localStorage.setItem("dark",e)},darkScheme=window.matchMedia("(prefers-color-scheme: dark)");if(htmlClass.contains("dark"))setDark(!0);else{const e=localStorage.getItem("dark");setDark(e?e==="true":darkScheme.matches)}darkScheme.addEventListener("change",e=>{setDark(e.matches)});const btnDark=document.querySelector(".btn-dark");btnDark.addEventListener("click",()=>{setDark(localStorage.getItem("dark")!=="true")})</script><div class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full select-none flex-col justify-center pb-16 duration-200 dark:bg-black lg:static lg:h-auto lg:flex-row lg:!bg-transparent lg:pb-0 lg:transition-none"><nav class="lg:ml-12 lg:flex lg:flex-row lg:items-center lg:space-x-6"><a class="block text-center text-2xl leading-[5rem] lg:text-base lg:font-normal" href=/about/>About</a>
<a class="block text-center text-2xl leading-[5rem] lg:text-base lg:font-normal" href=/demos/>Demos</a>
<a class="block text-center text-2xl leading-[5rem] lg:text-base lg:font-normal" href=/verilog-lib/>Lib</a>
<a class="block text-center text-2xl leading-[5rem] lg:text-base lg:font-normal" href=/tools/>Tools</a>
<a class="block text-center text-2xl leading-[5rem] lg:text-base lg:font-normal" href=/tutorials/>Tutorials</a></nav><nav class="mt-12 flex justify-center space-x-10 dark:invert lg:ml-12 lg:mt-0 lg:items-center lg:space-x-6"><a class="h-8 w-8 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./twitter.svg) href=https://twitter.com/@WillFlux target=_blank rel=me>twitter
</a><a class="h-8 w-8 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./github.svg) href=https://github.com/projf target=_blank rel=me>github
</a><a class="h-8 w-8 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./mastodon.svg) href=https://mastodon.social/@WillFlux target=_blank rel=me>mastodon
</a><a class="h-8 w-8 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./rss.svg) href=https://projectf.io/index.xml target=_blank rel=alternate>rss</a></nav></div></header><main class="prose prose-neutral relative mx-auto min-h-[calc(100%-9rem)] max-w-4xl px-8 pb-4 pt-4 dark:prose-invert"><article><header class=mb-4><h1 class="!my-0 pb-2.5">Framebuffers</h1><div class="text-sm antialiased opacity-60">Published
<time>30 Oct 2020</time>
<span class=mx-1>&#183;</span>
<span>Updated
<time>14 Jul 2023</time></span></div></header><section><p>Welcome back to <em>Exploring FPGA Graphics</em>. In the previous part, we worked with sprites, but another approach is needed as graphics become more complex. Instead of drawing directly to the screen, we draw to a bitmap, which is read out to the screen. This post provides an introduction to framebuffers and how to scale them up. We&rsquo;ll also learn how to fizzlefade graphics Wolfenstein 3D style.</p><p>In this series, we learn about graphics at the hardware level and get a feel for the power of FPGAs. We&rsquo;ll learn how screens work, play Pong, create starfields and sprites, paint Michelangelo&rsquo;s David, draw lines and triangles, and animate characters and shapes. New to the series? Start with <a href=/posts/fpga-graphics/>Beginning FPGA Graphics</a>.</p><p>Share your thoughts with @WillFlux on <a href=https://mastodon.social/@WillFlux>Mastodon</a> or <a href=https://twitter.com/WillFlux>Twitter</a>. If you like what I do, <a href=https://github.com/sponsors/WillGreen>sponsor me</a>. üôè</p><p><img src=/img/posts/framebuffers/banner.png alt title></p><h3 id=series-outline>Series Outline</h3><ul><li><a href=/posts/fpga-graphics/>Beginning FPGA Graphics</a> - video signals and basic graphics</li><li><a href=/posts/racing-the-beam/>Racing the Beam</a> - simple demo effects with minimal logic</li><li><a href=/posts/fpga-pong/>FPGA Pong</a> - recreate the classic arcade on an FPGA</li><li><a href=/posts/display-signals/>Display Signals</a> - revisit display signals and meet colour palettes</li><li><a href=/posts/hardware-sprites/>Hardware Sprites</a> - fast, colourful graphics for games</li><li>Framebuffers (this post) - bitmap graphics featuring Michelangelo&rsquo;s David</li><li><a href=/posts/lines-and-triangles/>Lines and Triangles</a> - drawing lines and triangles</li><li><a href=/posts/fpga-shapes/>2D Shapes</a> - filled shapes and simple pictures</li><li><a href=/posts/animated-shapes/>Animated Shapes</a> - animation and double-buffering</li></ul><h3 id=requirements>Requirements</h3><p>You should be to run these designs on any recent FPGA board. I include everything you need for the <a href=https://docs.icebreaker-fpga.org/hardware/icebreaker/>iCEBreaker</a> with <a href=https://docs.icebreaker-fpga.org/hardware/pmod/dvi/>12-Bit DVI Pmod</a>, <a href=https://digilent.com/reference/programmable-logic/arty-a7/reference-manual>Digilent Arty A7-35T</a> with <a href=https://digilent.com/reference/pmod/pmodvga/reference-manual>Pmod VGA</a>, <a href=https://digilent.com/reference/programmable-logic/nexys-video/reference-manual>Digilent Nexys Video</a> with on-board HDMI output, and <a href=/posts/verilog-sim-verilator-sdl/>Verilator Simulation with SDL</a>. See <a href=/posts/fpga-graphics/#requirements>requirements</a> from <em>Beginning FPGA Graphics</em> for more details.</p><h2 id=framebuffer>Framebuffer</h2><p>A framebuffer is an in-memory bitmap that drives pixels on the screen. When you write to a memory location within the framebuffer, the corresponding pixel will change on the screen. Using a framebuffer provides two big benefits: we&rsquo;re free to create sophisticated graphics using whatever technique we like, and the setting of pixel colour is separated from the process of driving the screen. The flexibility of a framebuffer comes at the cost of increased memory use.</p><h3 id=a-little-buffer>A Little Buffer</h3><p>A framebuffer requires enough memory to hold the complete frame. To keep things simple, we&rsquo;ll store our framebuffer in internal FPGA block memory (BRAM). The iCEBreaker&rsquo;s iCE40 FPGA is the smallest, with 120 kb of BRAM, so that&rsquo;s what we&rsquo;ll target.</p><p>If we divide our 640x480 screen by four, we get 160x120 (19,200 pixels):</p><ul><li>2 colours need one bit per pixel - buffer size 19,200 bits (18.75 kb)</li><li>16 colours need four bits per pixel - buffer size 76,800 bits (75 kb)</li></ul><h3 id=a-little-bitmap>A Little Bitmap</h3><p><img src=/img/posts/framebuffers/david-comparison.png alt="Michelangelo&rsquo;s David" title="David is a masterpiece of Renaissance sculpture created in marble between 1501 and 1504 by the Italian artist Michelangelo."></p><p>A small monochrome framebuffer calls for a striking image: I&rsquo;ve chosen <a href=https://en.wikipedia.org/wiki/David_(Michelangelo)>David by Michelangelo</a>.</p><p>The version on the right is the <a href=https://commons.wikimedia.org/wiki/File:Michelangelo%27s_David_-_63_grijswaarden.png>original from Wikipedia</a>; it has 64 shades of grey. I created the middle image by reducing the original to 16 colours using <code>img2fmem</code> with no dithering (we&rsquo;ll discuss this tool later). The monochrome image on the left was created by <a href=https://commons.wikimedia.org/wiki/User:Gerbrant/Dithering_algorithms>Gerbrant</a> using <a href=https://en.wikipedia.org/wiki/Floyd%E2%80%93Steinberg_dithering>Floyd-Steinberg dithering</a>.</p><h2 id=david-mono>David Mono</h2><p>Our first example loads a monochrome image of David into the framebuffer and displays it on screen. We use the same display signal and video output design from previous posts.</p><ul><li>iCEBreaker (iCE40): <strong><a href=https://github.com/projf/projf-explore/blob/main/graphics/framebuffers/ice40/top_david_mono.sv>ice40/top_david_mono.sv</a></strong></li><li>Arty (XC7): <strong><a href=https://github.com/projf/projf-explore/blob/main/graphics/framebuffers/xc7/top_david_mono.sv>xc7/top_david_mono.sv</a></strong></li><li>Nexys Video (XC7): <strong><a href=https://github.com/projf/projf-explore/blob/main/graphics/framebuffers/xc7-dvi/top_david_mono.sv>xc7-dvi/top_david_mono.sv</a></strong></li><li>Verilator Sim: <strong><a href=https://github.com/projf/projf-explore/blob/main/graphics/framebuffers/sim/top_david_mono.sv>sim/top_david_mono.sv</a></strong></li></ul><p>Arty version:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-verilog data-lang=verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_david_mono (
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span>  <span style=color:#66d9ef>wire</span> <span style=color:#66d9ef>logic</span> clk_100m,     <span style=color:#75715e>// 100 MHz clock
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>input</span>  <span style=color:#66d9ef>wire</span> <span style=color:#66d9ef>logic</span> btn_rst_n,    <span style=color:#75715e>// reset button
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>output</span>      <span style=color:#66d9ef>logic</span> vga_hsync,    <span style=color:#75715e>// horizontal sync
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>output</span>      <span style=color:#66d9ef>logic</span> vga_vsync,    <span style=color:#75715e>// vertical sync
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>output</span>      <span style=color:#66d9ef>logic</span> [<span style=color:#ae81ff>3</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] vga_r,  <span style=color:#75715e>// 4-bit VGA red
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>output</span>      <span style=color:#66d9ef>logic</span> [<span style=color:#ae81ff>3</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] vga_g,  <span style=color:#75715e>// 4-bit VGA green
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>output</span>      <span style=color:#66d9ef>logic</span> [<span style=color:#ae81ff>3</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] vga_b   <span style=color:#75715e>// 4-bit VGA blue
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// generate pixel clock
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>logic</span> clk_pix;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>logic</span> clk_pix_locked;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>logic</span> rst_pix;
</span></span><span style=display:flex><span>    clock_480p clock_pix_inst (
</span></span><span style=display:flex><span>       .clk_100m,
</span></span><span style=display:flex><span>       .rst(<span style=color:#f92672>!</span>btn_rst_n),  <span style=color:#75715e>// reset button is active low
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>       .clk_pix,
</span></span><span style=display:flex><span>       .clk_pix_5x(),  <span style=color:#75715e>// not used for VGA output
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>       .clk_pix_locked
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>always_ff</span> @(<span style=color:#66d9ef>posedge</span> clk_pix) rst_pix <span style=color:#f92672>&lt;=</span> <span style=color:#f92672>!</span>clk_pix_locked;  <span style=color:#75715e>// wait for clock lock
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// display sync signals and coordinates
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>localparam</span> CORDW <span style=color:#f92672>=</span> <span style=color:#ae81ff>16</span>;  <span style=color:#75715e>// signed coordinate width (bits)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>logic</span> <span style=color:#66d9ef>signed</span> [CORDW<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] sx, sy;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>logic</span> hsync, vsync;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>logic</span> de, frame;
</span></span><span style=display:flex><span>    display_480p #(.CORDW(CORDW)) display_inst (
</span></span><span style=display:flex><span>        .clk_pix,
</span></span><span style=display:flex><span>        .rst_pix,
</span></span><span style=display:flex><span>        .sx,
</span></span><span style=display:flex><span>        .sy,
</span></span><span style=display:flex><span>        .hsync,
</span></span><span style=display:flex><span>        .vsync,
</span></span><span style=display:flex><span>        .de,
</span></span><span style=display:flex><span>        .frame,
</span></span><span style=display:flex><span>        .line()
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// colour parameters
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>localparam</span> CHANW <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>;        <span style=color:#75715e>// colour channel width (bits)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>localparam</span> COLRW <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span><span style=color:#f92672>*</span>CHANW;  <span style=color:#75715e>// colour width: three channels (bits)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>localparam</span> BG_COLR <span style=color:#f92672>=</span> <span style=color:#ae81ff>&#39;h137</span>;  <span style=color:#75715e>// background colour
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// framebuffer (FB)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>localparam</span> FB_WIDTH  <span style=color:#f92672>=</span> <span style=color:#ae81ff>160</span>;  <span style=color:#75715e>// framebuffer width in pixels
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>localparam</span> FB_HEIGHT <span style=color:#f92672>=</span> <span style=color:#ae81ff>120</span>;  <span style=color:#75715e>// framebuffer width in pixels
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>localparam</span> FB_PIXELS <span style=color:#f92672>=</span> FB_WIDTH <span style=color:#f92672>*</span> FB_HEIGHT;  <span style=color:#75715e>// total pixels in buffer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>localparam</span> FB_ADDRW  <span style=color:#f92672>=</span> $clog2(FB_PIXELS);  <span style=color:#75715e>// address width
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>localparam</span> FB_DATAW  <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;  <span style=color:#75715e>// colour bits per pixel
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>localparam</span> FB_IMAGE  <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;david_1bit.mem&#34;</span>;  <span style=color:#75715e>// bitmap file
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// localparam FB_IMAGE  = &#34;test_box_mono_160x120.mem&#34;;  // bitmap file
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// pixel read address and colour
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>logic</span> [FB_ADDRW<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] fb_addr_read;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>logic</span> [FB_DATAW<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] fb_colr_read;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// framebuffer memory
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    bram_sdp #(
</span></span><span style=display:flex><span>        .WIDTH(FB_DATAW),
</span></span><span style=display:flex><span>        .DEPTH(FB_PIXELS),
</span></span><span style=display:flex><span>        .INIT_F(FB_IMAGE)
</span></span><span style=display:flex><span>    ) bram_inst (
</span></span><span style=display:flex><span>        .clk_write(clk_pix),
</span></span><span style=display:flex><span>        .clk_read(clk_pix),
</span></span><span style=display:flex><span>        .we(),
</span></span><span style=display:flex><span>        .addr_write(),
</span></span><span style=display:flex><span>        .addr_read(fb_addr_read),
</span></span><span style=display:flex><span>        .data_in(),
</span></span><span style=display:flex><span>        .data_out(fb_colr_read)
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// calculate framebuffer read address for display output
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>localparam</span> LAT <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;  <span style=color:#75715e>// read_fb+1, BRAM+1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>logic</span> read_fb;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>always_ff</span> @(<span style=color:#66d9ef>posedge</span> clk_pix) <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>        read_fb <span style=color:#f92672>&lt;=</span> (sy <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> sy <span style=color:#f92672>&lt;</span> FB_HEIGHT <span style=color:#f92672>&amp;&amp;</span> sx <span style=color:#f92672>&gt;=</span> <span style=color:#f92672>-</span>LAT <span style=color:#f92672>&amp;&amp;</span> sx <span style=color:#f92672>&lt;</span> FB_WIDTH<span style=color:#f92672>-</span>LAT);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (frame) <span style=color:#66d9ef>begin</span>  <span style=color:#75715e>// reset address at start of frame
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            fb_addr_read <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>end</span> <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (read_fb) <span style=color:#66d9ef>begin</span>  <span style=color:#75715e>// increment address in painting area
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            fb_addr_read <span style=color:#f92672>&lt;=</span> fb_addr_read <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// paint screen
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>logic</span> paint_area;  <span style=color:#75715e>// area of framebuffer to paint
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>logic</span> [CHANW<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] paint_r, paint_g, paint_b;  <span style=color:#75715e>// colour channels
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>always_comb</span> <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>        paint_area <span style=color:#f92672>=</span> (sy <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> sy <span style=color:#f92672>&lt;</span> FB_HEIGHT <span style=color:#f92672>&amp;&amp;</span> sx <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> sx <span style=color:#f92672>&lt;</span> FB_WIDTH);
</span></span><span style=display:flex><span>        {paint_r, paint_g, paint_b} <span style=color:#f92672>=</span> paint_area <span style=color:#f92672>?</span> {COLRW{fb_colr_read}} <span style=color:#f92672>:</span> BG_COLR;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// display colour: paint colour but black in blanking interval
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>logic</span> [CHANW<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] display_r, display_g, display_b;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>always_comb</span> {display_r, display_g, display_b} <span style=color:#f92672>=</span> (de) <span style=color:#f92672>?</span> {paint_r, paint_g, paint_b} <span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// VGA Pmod output
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>always_ff</span> @(<span style=color:#66d9ef>posedge</span> clk_pix) <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>        vga_hsync <span style=color:#f92672>&lt;=</span> hsync;
</span></span><span style=display:flex><span>        vga_vsync <span style=color:#f92672>&lt;=</span> vsync;
</span></span><span style=display:flex><span>        vga_r <span style=color:#f92672>&lt;=</span> display_r;
</span></span><span style=display:flex><span>        vga_g <span style=color:#f92672>&lt;=</span> display_g;
</span></span><span style=display:flex><span>        vga_b <span style=color:#f92672>&lt;=</span> display_b;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><blockquote><p><strong>Building the Designs</strong><br>In the <a href=https://github.com/projf/projf-explore/tree/main/graphics/framebuffers>Framebuffers</a> section of the git repo, you&rsquo;ll find the design files, a makefile for iCEBreaker and Verilator, and a Vivado project for Xilinx-based boards. There are also build instructions for boards and simulations.</p></blockquote><p>Build mono David for your board or the Verilator sim. You should see a small dithered David looking at you from the top-left of the screen.</p><p><em>NB. You can safely ignore Vivado get/set clock warnings. The XDC constraints file contains settings for designs we&rsquo;ll discuss later in this post.</em></p><p>The Verilator sim looks like this:</p><p><img src=/img/posts/framebuffers/david_mono.png alt="Dithered David - Verilator/SDL simulation on macOS" title="David is a masterpiece of Renaissance sculpture, created in marble between 1501 and 1504 by the Italian artist Michelangelo."></p><h3 id=framebuffer-memory>Framebuffer Memory</h3><p>The core of the framebuffer design is the memory. We use parameters to set the bitmap dimensions and colour bits, determining our buffer&rsquo;s depth and address width.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-verilog data-lang=verilog><span style=display:flex><span>    <span style=color:#75715e>// framebuffer (FB)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>localparam</span> FB_WIDTH  <span style=color:#f92672>=</span> <span style=color:#ae81ff>160</span>;  <span style=color:#75715e>// framebuffer width in pixels
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>localparam</span> FB_HEIGHT <span style=color:#f92672>=</span> <span style=color:#ae81ff>120</span>;  <span style=color:#75715e>// framebuffer width in pixels
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>localparam</span> FB_PIXELS <span style=color:#f92672>=</span> FB_WIDTH <span style=color:#f92672>*</span> FB_HEIGHT;  <span style=color:#75715e>// total pixels in buffer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>localparam</span> FB_ADDRW  <span style=color:#f92672>=</span> $clog2(FB_PIXELS);  <span style=color:#75715e>// address width
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>localparam</span> FB_DATAW  <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;  <span style=color:#75715e>// colour bits per pixel
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>localparam</span> FB_IMAGE  <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;david_1bit.mem&#34;</span>;  <span style=color:#75715e>// bitmap file
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// localparam FB_IMAGE  = &#34;test_box_mono_160x120.mem&#34;;  // bitmap file
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// pixel read address and colour
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>logic</span> [FB_ADDRW<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] fb_addr_read;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>logic</span> [FB_DATAW<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] fb_colr_read;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// framebuffer memory
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    bram_sdp #(
</span></span><span style=display:flex><span>        .WIDTH(FB_DATAW),
</span></span><span style=display:flex><span>        .DEPTH(FB_PIXELS),
</span></span><span style=display:flex><span>        .INIT_F(FB_IMAGE)
</span></span><span style=display:flex><span>    ) bram_inst (
</span></span><span style=display:flex><span>        .clk_write(clk_pix),
</span></span><span style=display:flex><span>        .clk_read(clk_pix),
</span></span><span style=display:flex><span>        .we(),
</span></span><span style=display:flex><span>        .addr_write(),
</span></span><span style=display:flex><span>        .addr_read(fb_addr_read),
</span></span><span style=display:flex><span>        .data_in(),
</span></span><span style=display:flex><span>        .data_out(fb_colr_read)
</span></span><span style=display:flex><span>    );
</span></span></code></pre></div><p>You can find the BRAM module in the Verilog library: <strong>[<a href=https://github.com/projf/projf-explore/blob/main/lib/memory/bram_sdp.sv>lib/memory/bram_sdp.sv</a>]</strong>. This simple module <em>infers</em> block ram without you having to worry about the low-level implementation details.</p><p>The memory design has read and write ports, but we only read for mono David. The bitmap image of David is loaded into BRAM as part of the initial FPGA device configuration.</p><p>We store the bitmap in a text file <strong>[<a href=https://github.com/projf/projf-explore/blob/main/graphics/framebuffers/res/david/david_1bit.mem>res/david/david_1bit.mem</a>]</strong>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-verilog data-lang=verilog><span style=display:flex><span><span style=color:#75715e>// Project F: Framebuffers - David 160x120 Image (Monochrome)
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Learn more at https://projectf.io/posts/framebuffers/
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>....
</span></span></code></pre></div><h3 id=time-to-read>Time to Read</h3><p>We have our image in memory; we just need to know <em>when</em> to read and display each pixel.</p><p>Your first thought might be to calculate the memory address directly from the screen coordinates, such as: <code>fb_addr_read = sy * FB_WIDTH + sx</code>. While superficially appealing, this approach ties the memory clock directly to the pixel clock, limiting our flexibility and efficiency. How would we handle memory latency? How would we share memory access with a CPU?</p><p>A better approach is to increment the memory address every time we need to read a pixel. No multiplication is required, and we can easily compensate for any latency:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-verilog data-lang=verilog><span style=display:flex><span>    <span style=color:#75715e>// calculate framebuffer read address for display output
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>localparam</span> LAT <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;  <span style=color:#75715e>// read_fb+1, BRAM+1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>logic</span> read_fb;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>always_ff</span> @(<span style=color:#66d9ef>posedge</span> clk_pix) <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>        read_fb <span style=color:#f92672>&lt;=</span> (sy <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> sy <span style=color:#f92672>&lt;</span> FB_HEIGHT <span style=color:#f92672>&amp;&amp;</span> sx <span style=color:#f92672>&gt;=</span> <span style=color:#f92672>-</span>LAT <span style=color:#f92672>&amp;&amp;</span> sx <span style=color:#f92672>&lt;</span> FB_WIDTH<span style=color:#f92672>-</span>LAT);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (frame) <span style=color:#66d9ef>begin</span>  <span style=color:#75715e>// reset address at start of frame
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            fb_addr_read <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>end</span> <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (read_fb) <span style=color:#66d9ef>begin</span>  <span style=color:#75715e>// increment address in painting area
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            fb_addr_read <span style=color:#f92672>&lt;=</span> fb_addr_read <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>We define the screen area we want to paint using the screen position <code>(sx,sy)</code> and the framebuffer height <code>FB_HEIGHT</code> and width <code>FB_WIDTH</code>. But we subtract the latency <code>LAT</code> from the horizontal position: one cycle allows for the calculation of <code>read_fb</code> and one cycle for the BRAM to return the data.</p><p>In this example, with <code>LAT = 2</code>, the comparisons are <code>sx >= -2</code> and <code>sx &lt; 158</code>.</p><h4 id=latency-testing>Latency Testing</h4><p>It&rsquo;s easy to overlook latency in your design, rendering your framebuffer off by one or two pixels. To get the design right, I&rsquo;ve created a test image, <code>test_box_mono_160x120.mem</code>. The test image draws a single pixel around the edge of the framebuffer, making it straightforward to spot errors.</p><p>Try <code>test_box_mono</code> with different values for <code>LAT</code>; notice how the rendering of the box changes. If the image is too small to see clearly, don&rsquo;t worry, we&rsquo;ll be scaling it up shortly.</p><h3 id=painting-the-screen>Painting the Screen</h3><p>Using the pixel data from the framebuffer, we can decide when to draw a white pixel <code>12'hFFF</code> and when to draw black <code>12'h000</code>. Feel free to try your own colours.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-verilog data-lang=verilog><span style=display:flex><span>    <span style=color:#75715e>// paint screen
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>logic</span> paint_area;  <span style=color:#75715e>// area of framebuffer to paint
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>logic</span> [CHANW<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] paint_r, paint_g, paint_b;  <span style=color:#75715e>// colour channels
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>always_comb</span> <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>        paint_area <span style=color:#f92672>=</span> (sy <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> sy <span style=color:#f92672>&lt;</span> FB_HEIGHT <span style=color:#f92672>&amp;&amp;</span> sx <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> sx <span style=color:#f92672>&lt;</span> FB_WIDTH);
</span></span><span style=display:flex><span>        {paint_r, paint_g, paint_b} <span style=color:#f92672>=</span> paint_area <span style=color:#f92672>?</span> {COLRW{fb_colr_read}} <span style=color:#f92672>:</span> BG_COLR;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span></code></pre></div><blockquote><p><strong>Combinational Painting?</strong><br>We use combinational logic here to avoid latency correction on the display signals, such as <code>h_sync</code>. The design still easily passes timing, so I think this simplification is worthwhile.</p></blockquote><h2 id=david-grey>David Grey</h2><p>If we increase the number of bits per pixel to four, we can have 16 colours (or shades of grey). We store the colour index for each pixel and then look the colour up in a colour lookup table. We previously discussed colour lookup tables and indexed colour in <a href=/posts/display-signals/#a-refined-palette>Display Signals</a>.</p><ul><li>iCEBreaker (iCE40): <strong><a href=https://github.com/projf/projf-explore/blob/main/graphics/framebuffers/ice40/top_david_16colr.sv>ice40/top_david_16colr.sv</a></strong></li><li>Arty (XC7): <strong><a href=https://github.com/projf/projf-explore/blob/main/graphics/framebuffers/xc7/top_david_16colr.sv>xc7/top_david_16colr.sv</a></strong></li><li>Nexys Video (XC7): <strong><a href=https://github.com/projf/projf-explore/blob/main/graphics/framebuffers/xc7-dvi/top_david_16colr.sv>xc7-dvi/top_david_16colr.sv</a></strong></li><li>Verilator Sim: <strong><a href=https://github.com/projf/projf-explore/blob/main/graphics/framebuffers/sim/top_david_16colr.sv>sim/top_david_16colr.sv</a></strong></li></ul><p>The changed part of the design is shown below for Arty (other boards are very similar):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-verilog data-lang=verilog><span style=display:flex><span>    <span style=color:#75715e>// bitmap images
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>localparam</span> BMAP_IMAGE <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;david.mem&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// localparam BMAP_IMAGE = &#34;test_box_160x120.mem&#34;;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// colour palettes
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>localparam</span> PAL_FILE <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;grey16_4b.mem&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// localparam PAL_FILE = &#34;greyinvert16_4b.mem&#34;;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// localparam PAL_FILE = &#34;sepia16_4b.mem&#34;;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// localparam PAL_FILE = &#34;sweetie16_4b.mem&#34;;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// colour parameters
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>localparam</span> CHANW <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>;        <span style=color:#75715e>// colour channel width (bits)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>localparam</span> COLRW <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span><span style=color:#f92672>*</span>CHANW;  <span style=color:#75715e>// colour width: three channels (bits)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>localparam</span> CIDXW <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>;        <span style=color:#75715e>// colour index width (bits)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>localparam</span> BG_COLR <span style=color:#f92672>=</span> <span style=color:#ae81ff>&#39;h137</span>;  <span style=color:#75715e>// background colour
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// framebuffer (FB)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>localparam</span> FB_WIDTH  <span style=color:#f92672>=</span> <span style=color:#ae81ff>160</span>;  <span style=color:#75715e>// framebuffer width in pixels
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>localparam</span> FB_HEIGHT <span style=color:#f92672>=</span> <span style=color:#ae81ff>120</span>;  <span style=color:#75715e>// framebuffer width in pixels
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>localparam</span> FB_PIXELS <span style=color:#f92672>=</span> FB_WIDTH <span style=color:#f92672>*</span> FB_HEIGHT;  <span style=color:#75715e>// total pixels in buffer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>localparam</span> FB_ADDRW  <span style=color:#f92672>=</span> $clog2(FB_PIXELS);  <span style=color:#75715e>// address width
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>localparam</span> FB_DATAW  <span style=color:#f92672>=</span> CIDXW;  <span style=color:#75715e>// colour bits per pixel
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// pixel read address and colour
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>logic</span> [FB_ADDRW<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] fb_addr_read;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>logic</span> [FB_DATAW<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] fb_colr_read;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// framebuffer memory
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    bram_sdp #(
</span></span><span style=display:flex><span>        .WIDTH(FB_DATAW),
</span></span><span style=display:flex><span>        .DEPTH(FB_PIXELS),
</span></span><span style=display:flex><span>        .INIT_F(BMAP_IMAGE)
</span></span><span style=display:flex><span>    ) bram_inst (
</span></span><span style=display:flex><span>        .clk_write(clk_pix),
</span></span><span style=display:flex><span>        .clk_read(clk_pix),
</span></span><span style=display:flex><span>        .we(),
</span></span><span style=display:flex><span>        .addr_write(),
</span></span><span style=display:flex><span>        .addr_read(fb_addr_read),
</span></span><span style=display:flex><span>        .data_in(),
</span></span><span style=display:flex><span>        .data_out(fb_colr_read)
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// calculate framebuffer read address for display output
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>localparam</span> LAT <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>;  <span style=color:#75715e>// read_fb+1, BRAM+1, CLUT+1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>logic</span> read_fb;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>always_ff</span> @(<span style=color:#66d9ef>posedge</span> clk_pix) <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>        read_fb <span style=color:#f92672>&lt;=</span> (sy <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> sy <span style=color:#f92672>&lt;</span> FB_HEIGHT <span style=color:#f92672>&amp;&amp;</span> sx <span style=color:#f92672>&gt;=</span> <span style=color:#f92672>-</span>LAT <span style=color:#f92672>&amp;&amp;</span> sx <span style=color:#f92672>&lt;</span> FB_WIDTH<span style=color:#f92672>-</span>LAT);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (frame) <span style=color:#66d9ef>begin</span>  <span style=color:#75715e>// reset address at start of frame
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            fb_addr_read <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>end</span> <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (read_fb) <span style=color:#66d9ef>begin</span>  <span style=color:#75715e>// increment address in painting area
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            fb_addr_read <span style=color:#f92672>&lt;=</span> fb_addr_read <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// colour lookup table
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>logic</span> [COLRW<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] fb_pix_colr;
</span></span><span style=display:flex><span>    clut_simple #(
</span></span><span style=display:flex><span>        .COLRW(COLRW),
</span></span><span style=display:flex><span>        .CIDXW(CIDXW),
</span></span><span style=display:flex><span>        .F_PAL(PAL_FILE)
</span></span><span style=display:flex><span>        ) clut_instance (
</span></span><span style=display:flex><span>        .clk_write(clk_pix),
</span></span><span style=display:flex><span>        .clk_read(clk_pix),
</span></span><span style=display:flex><span>        .we(<span style=color:#ae81ff>0</span>),
</span></span><span style=display:flex><span>        .cidx_write(<span style=color:#ae81ff>0</span>),
</span></span><span style=display:flex><span>        .cidx_read(fb_colr_read),
</span></span><span style=display:flex><span>        .colr_in(<span style=color:#ae81ff>0</span>),
</span></span><span style=display:flex><span>        .colr_out(fb_pix_colr)
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// paint screen
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>logic</span> paint_area;  <span style=color:#75715e>// area of framebuffer to paint
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>logic</span> [CHANW<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] paint_r, paint_g, paint_b;  <span style=color:#75715e>// colour channels
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>always_comb</span> <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>        paint_area <span style=color:#f92672>=</span> (sy <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> sy <span style=color:#f92672>&lt;</span> FB_HEIGHT <span style=color:#f92672>&amp;&amp;</span> sx <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> sx <span style=color:#f92672>&lt;</span> FB_WIDTH);
</span></span><span style=display:flex><span>        {paint_r, paint_g, paint_b} <span style=color:#f92672>=</span> paint_area <span style=color:#f92672>?</span> fb_pix_colr <span style=color:#f92672>:</span> BG_COLR;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>Looking up a colour in the colour lookup table takes a clock cycle, so we compensate by increasing the latency <code>LAT</code> to three cycles.</p><p>You can use the coloured test image <code>test_box_160x120.mem</code> to check for latency issues; it works best with the <code>sweetie16_4b.mem</code> colour palette.</p><h3 id=colour-me-in>Colour Me In</h3><p>Try changing <code>PAL_FILE</code> to select one of the other palettes: I&rsquo;ve included four in the design.</p><p>With the <code>sepia16_4b</code> palette, the simulation looks like this:</p><p><img src=/img/posts/framebuffers/david_sepia.png alt="Sepia David - Verilator/SDL simulation on macOS" title="David with squid ink?"></p><h2 id=scaling>Scaling</h2><p>Our David is disappointingly small: we want him to fill the screen. Not only that, but we want to scale him up while retaining our efficient memory access. To accomplish this, we&rsquo;ll introduce a linebuffer <em>and</em> cross clock domains.</p><p><img src=/img/posts/framebuffers/david_scale.png alt="Scaled David - Verilator/SDL simulation on macOS" title="Filling ur screen"></p><h2 id=linebuffer>Linebuffer</h2><p>Scaling our 160x120 framebuffer up to 640x480 renders each pixel 16 times. Scaling up repeats pixels, but we don&rsquo;t want to repeat memory access.</p><p>Instead of sending pixels directly from the framebuffer to the screen, we load each line into a linebuffer. Each pixel is read into the linebuffer once per frame but displayed as many times as needed. The linebuffer memory is read many times for each pixel, but it&rsquo;s small and dedicated to the task.</p><p>The linebuffer provides a second valuable service: using a dual-port BRAM, we can support two clocks: system and pixel. We read data into the linebuffer at the system clock but output for display at the pixel clock. Separate clocks improve performance and allow the system clock to remain constant when we change the display resolution. We discuss the clocks in more detail below.</p><p><img src=/img/posts/framebuffers/framebuffer-arch.png alt="Framebuffer Architecture" title="Two domains bridged two ways."></p><h3 id=linebuffer-module>Linebuffer Module</h3><p>The linebuffer module is based on a simple dual-port BRAM <strong>[<a href=https://github.com/projf/projf-explore/blob/main/lib/display/linebuffer_simple.sv>linebuffer_simple.sv</a>]</strong>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-verilog data-lang=verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> linebuffer_simple #(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>parameter</span> DATAW<span style=color:#f92672>=</span><span style=color:#ae81ff>4</span>,  <span style=color:#75715e>// data width of each channel
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>parameter</span> LEN<span style=color:#f92672>=</span><span style=color:#ae81ff>640</span>,  <span style=color:#75715e>// length of line
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>parameter</span> SCALEW<span style=color:#f92672>=</span><span style=color:#ae81ff>6</span>  <span style=color:#75715e>// scale width (max scale == 2^SCALEW-1)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    ) (
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span>  <span style=color:#66d9ef>wire</span> <span style=color:#66d9ef>logic</span> clk_sys,   <span style=color:#75715e>// input clock
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>input</span>  <span style=color:#66d9ef>wire</span> <span style=color:#66d9ef>logic</span> clk_pix,   <span style=color:#75715e>// output clock
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>input</span>  <span style=color:#66d9ef>wire</span> <span style=color:#66d9ef>logic</span> line,      <span style=color:#75715e>// line start (clk_pix)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>input</span>  <span style=color:#66d9ef>wire</span> <span style=color:#66d9ef>logic</span> line_sys,  <span style=color:#75715e>// line start (clk_sys)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>input</span>  <span style=color:#66d9ef>wire</span> <span style=color:#66d9ef>logic</span> en_in,     <span style=color:#75715e>// enable input (clk_sys)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>input</span>  <span style=color:#66d9ef>wire</span> <span style=color:#66d9ef>logic</span> en_out,    <span style=color:#75715e>// enable output (clk_pix)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>input</span>  <span style=color:#66d9ef>wire</span> <span style=color:#66d9ef>logic</span> [SCALEW<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] scale,   <span style=color:#75715e>// scale factor (&gt;=1)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>input</span>  <span style=color:#66d9ef>wire</span> <span style=color:#66d9ef>logic</span> [DATAW<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] data_in,  <span style=color:#75715e>// data in (clk_sys)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>output</span>      <span style=color:#66d9ef>logic</span> [DATAW<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] data_out  <span style=color:#75715e>// data out (clk_pix)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// output data
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>logic</span> [$clog2(LEN)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] addr_out;  <span style=color:#75715e>// output address (pixel counter)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>logic</span> [SCALEW<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] cnt_h;  <span style=color:#75715e>// horizontal scale counter
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>always_ff</span> @(<span style=color:#66d9ef>posedge</span> clk_pix) <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (en_out) <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (cnt_h <span style=color:#f92672>==</span> scale<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>                cnt_h <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (addr_out <span style=color:#f92672>!=</span> LEN<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) addr_out <span style=color:#f92672>&lt;=</span> addr_out <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>end</span> <span style=color:#66d9ef>else</span> cnt_h <span style=color:#f92672>&lt;=</span> cnt_h <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (line) <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>            addr_out <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>            cnt_h <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// read data in
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>logic</span> [$clog2(LEN)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] addr_in;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>logic</span> we;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>always_ff</span> @(<span style=color:#66d9ef>posedge</span> clk_sys) <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (en_in) we <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (addr_in <span style=color:#f92672>==</span> LEN<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) we <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (we) addr_in <span style=color:#f92672>&lt;=</span> addr_in <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (line_sys) <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>            we <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>            addr_in <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    bram_sdp #(
</span></span><span style=display:flex><span>        .WIDTH(DATAW),
</span></span><span style=display:flex><span>        .DEPTH(LEN)
</span></span><span style=display:flex><span>        ) bram_lb (
</span></span><span style=display:flex><span>        .clk_write(clk_sys),
</span></span><span style=display:flex><span>        .clk_read(clk_pix),
</span></span><span style=display:flex><span>        .we,
</span></span><span style=display:flex><span>        .addr_write(addr_in),
</span></span><span style=display:flex><span>        .addr_read(addr_out),
</span></span><span style=display:flex><span>        .data_in,
</span></span><span style=display:flex><span>        .data_out
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><p>The linebuffer doesn&rsquo;t know anything about the source or destination of the data. When <code>en_in</code> is high, it reads from <code>data_in</code>. When <code>en_out</code> is high, it writes to data_out. The <code>line</code> and <code>line_sys</code> signals reset the internal BRAM read and write addresses, respectively.</p><p>The linebuffer handles horizontal scaling by repeating an output pixel <code>scale</code> times. Vertical scaling is handled by the driving top module, discussed below.</p><h2 id=clocks>Clocks</h2><p>For the Arty board, we can run most of the scaled design (including the framebuffer) at 125 MHz while the display output continues at 25.2 MHz. To generate a 125 MHz system clock we use another clock generation module: <strong>[<a href=https://github.com/projf/projf-explore/blob/main/lib/clock/xc7/clock_sys.sv>xc7/clock_sys.sv</a>]</strong>.</p><p>The system clock instance in the top module looks like this (complete with reset signal):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-verilog data-lang=verilog><span style=display:flex><span><span style=color:#75715e>// generate system clock
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>logic</span> clk_sys;
</span></span><span style=display:flex><span><span style=color:#66d9ef>logic</span> clk_sys_locked;
</span></span><span style=display:flex><span><span style=color:#66d9ef>logic</span> rst_sys;
</span></span><span style=display:flex><span>clock_sys clock_sys_inst (
</span></span><span style=display:flex><span>    .clk_100m,
</span></span><span style=display:flex><span>    .rst(<span style=color:#f92672>!</span>btn_rst_n),  <span style=color:#75715e>// reset button is active low
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    .clk_sys,
</span></span><span style=display:flex><span>    .clk_sys_locked
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>always_ff</span> @(<span style=color:#66d9ef>posedge</span> clk_sys) rst_sys <span style=color:#f92672>&lt;=</span> <span style=color:#f92672>!</span>clk_sys_locked;  <span style=color:#75715e>// wait for clock lock
</span></span></span></code></pre></div><p>The iCEBreaker has only one PLL, so we make the system clock the same as the pixel clock:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-verilog data-lang=verilog><span style=display:flex><span><span style=color:#75715e>// system clock is the same as pixel clock on iCE40
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>logic</span> clk_sys, rst_sys;
</span></span><span style=display:flex><span><span style=color:#66d9ef>always_comb</span> <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>    clk_sys <span style=color:#f92672>=</span> clk_pix;
</span></span><span style=display:flex><span>    rst_sys <span style=color:#f92672>=</span> rst_pix;
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>Keeping the system clock around makes it simpler to share designs between boards.</p><h3 id=crossing-clock-domains>Crossing Clock Domains</h3><p>The linebuffer handles the pixels, but we also need display signals in the system clock domain, such as frame start. The display signals are isolated single pulses, so we can send them across domains with the <strong>xd</strong> module. See the <a href=/posts/lib-clock-xd/>library post on xd</a> for details of this module.</p><p>The display module generates the <code>frame</code> signal in the pixel clock domain <code>clk_pix</code>.</p><p>We make it available in the system clock domain <code>clk_sys</code> like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-verilog data-lang=verilog><span style=display:flex><span><span style=color:#66d9ef>logic</span> frame_sys;
</span></span><span style=display:flex><span>xd xd_frame (.clk_src(clk_pix),.clk_dst(clk_sys), .flag_src(frame), .flag_dst(frame_sys));
</span></span></code></pre></div><h2 id=scaled-design>Scaled Design</h2><p>Adding the linebuffer with scaling gives us a full-screen David:</p><ul><li>iCEBreaker (iCE40): <strong><a href=https://github.com/projf/projf-explore/blob/main/graphics/framebuffers/ice40/top_david_scale.sv>ice40/top_david_scale.sv</a></strong></li><li>Arty (XC7): <strong><a href=https://github.com/projf/projf-explore/blob/main/graphics/framebuffers/xc7/top_david_scale.sv>xc7/top_david_scale.sv</a></strong></li><li>Nexys Video (XC7): <strong><a href=https://github.com/projf/projf-explore/blob/main/graphics/framebuffers/xc7-dvi/top_david_scale.sv>xc7-dvi/top_david_scale.sv</a></strong></li><li>Verilator Sim: <strong><a href=https://github.com/projf/projf-explore/blob/main/graphics/framebuffers/sim/top_david_scale.sv>sim/top_david_scale.sv</a></strong></li></ul><p>Arty version:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-verilog data-lang=verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_david_scale (
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span>  <span style=color:#66d9ef>wire</span> <span style=color:#66d9ef>logic</span> clk_100m,     <span style=color:#75715e>// 100 MHz clock
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>input</span>  <span style=color:#66d9ef>wire</span> <span style=color:#66d9ef>logic</span> btn_rst_n,    <span style=color:#75715e>// reset button
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>output</span>      <span style=color:#66d9ef>logic</span> vga_hsync,    <span style=color:#75715e>// horizontal sync
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>output</span>      <span style=color:#66d9ef>logic</span> vga_vsync,    <span style=color:#75715e>// vertical sync
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>output</span>      <span style=color:#66d9ef>logic</span> [<span style=color:#ae81ff>3</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] vga_r,  <span style=color:#75715e>// 4-bit VGA red
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>output</span>      <span style=color:#66d9ef>logic</span> [<span style=color:#ae81ff>3</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] vga_g,  <span style=color:#75715e>// 4-bit VGA green
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>output</span>      <span style=color:#66d9ef>logic</span> [<span style=color:#ae81ff>3</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] vga_b   <span style=color:#75715e>// 4-bit VGA blue
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// generate system clock
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>logic</span> clk_sys;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>logic</span> clk_sys_locked;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>logic</span> rst_sys;
</span></span><span style=display:flex><span>    clock_sys clock_sys_inst (
</span></span><span style=display:flex><span>       .clk_100m,
</span></span><span style=display:flex><span>       .rst(<span style=color:#f92672>!</span>btn_rst_n),  <span style=color:#75715e>// reset button is active low
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>       .clk_sys,
</span></span><span style=display:flex><span>       .clk_sys_locked
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>always_ff</span> @(<span style=color:#66d9ef>posedge</span> clk_sys) rst_sys <span style=color:#f92672>&lt;=</span> <span style=color:#f92672>!</span>clk_sys_locked;  <span style=color:#75715e>// wait for clock lock
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// generate pixel clock
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>logic</span> clk_pix;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>logic</span> clk_pix_locked;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>logic</span> rst_pix;
</span></span><span style=display:flex><span>    clock_480p clock_pix_inst (
</span></span><span style=display:flex><span>       .clk_100m,
</span></span><span style=display:flex><span>       .rst(<span style=color:#f92672>!</span>btn_rst_n),  <span style=color:#75715e>// reset button is active low
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>       .clk_pix,
</span></span><span style=display:flex><span>       .clk_pix_5x(),  <span style=color:#75715e>// not used for VGA output
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>       .clk_pix_locked
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>always_ff</span> @(<span style=color:#66d9ef>posedge</span> clk_pix) rst_pix <span style=color:#f92672>&lt;=</span> <span style=color:#f92672>!</span>clk_pix_locked;  <span style=color:#75715e>// wait for clock lock
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// display sync signals and coordinates
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>localparam</span> CORDW <span style=color:#f92672>=</span> <span style=color:#ae81ff>16</span>;  <span style=color:#75715e>// signed coordinate width (bits)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>logic</span> <span style=color:#66d9ef>signed</span> [CORDW<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] sx, sy;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>logic</span> hsync, vsync;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>logic</span> de, frame, line;
</span></span><span style=display:flex><span>    display_480p #(.CORDW(CORDW)) display_inst (
</span></span><span style=display:flex><span>        .clk_pix,
</span></span><span style=display:flex><span>        .rst_pix,
</span></span><span style=display:flex><span>        .sx,
</span></span><span style=display:flex><span>        .sy,
</span></span><span style=display:flex><span>        .hsync,
</span></span><span style=display:flex><span>        .vsync,
</span></span><span style=display:flex><span>        .de,
</span></span><span style=display:flex><span>        .frame,
</span></span><span style=display:flex><span>        .line
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// bitmap images
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>localparam</span> BMAP_IMAGE <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;david.mem&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// localparam BMAP_IMAGE = &#34;test_box_160x120.mem&#34;;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// colour palettes
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>localparam</span> PAL_FILE <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;grey16_4b.mem&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// localparam PAL_FILE = &#34;greyinvert16_4b.mem&#34;;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// localparam PAL_FILE = &#34;sepia16_4b.mem&#34;;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// localparam PAL_FILE = &#34;sweetie16_4b.mem&#34;;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// colour parameters
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>localparam</span> CHANW <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>;        <span style=color:#75715e>// colour channel width (bits)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>localparam</span> COLRW <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span><span style=color:#f92672>*</span>CHANW;  <span style=color:#75715e>// colour width: three channels (bits)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>localparam</span> CIDXW <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>;        <span style=color:#75715e>// colour index width (bits)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>localparam</span> BG_COLR <span style=color:#f92672>=</span> <span style=color:#ae81ff>&#39;h137</span>;  <span style=color:#75715e>// background colour
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// framebuffer (FB)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>localparam</span> FB_WIDTH  <span style=color:#f92672>=</span> <span style=color:#ae81ff>160</span>;  <span style=color:#75715e>// framebuffer width in pixels
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>localparam</span> FB_HEIGHT <span style=color:#f92672>=</span> <span style=color:#ae81ff>120</span>;  <span style=color:#75715e>// framebuffer height in pixels
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>localparam</span> FB_SCALE  <span style=color:#f92672>=</span>   <span style=color:#ae81ff>4</span>;  <span style=color:#75715e>// framebuffer display scale (1-63)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>localparam</span> FB_PIXELS <span style=color:#f92672>=</span> FB_WIDTH <span style=color:#f92672>*</span> FB_HEIGHT;  <span style=color:#75715e>// total pixels in buffer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>localparam</span> FB_ADDRW  <span style=color:#f92672>=</span> $clog2(FB_PIXELS);  <span style=color:#75715e>// address width
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>localparam</span> FB_DATAW  <span style=color:#f92672>=</span> CIDXW;  <span style=color:#75715e>// colour bits per pixel
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// pixel read address and colour
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>logic</span> [FB_ADDRW<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] fb_addr_read;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>logic</span> [FB_DATAW<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] fb_colr_read;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// framebuffer memory
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    bram_sdp #(
</span></span><span style=display:flex><span>        .WIDTH(FB_DATAW),
</span></span><span style=display:flex><span>        .DEPTH(FB_PIXELS),
</span></span><span style=display:flex><span>        .INIT_F(BMAP_IMAGE)
</span></span><span style=display:flex><span>    ) bram_inst (
</span></span><span style=display:flex><span>        .clk_write(clk_sys),
</span></span><span style=display:flex><span>        .clk_read(clk_sys),
</span></span><span style=display:flex><span>        .we(),
</span></span><span style=display:flex><span>        .addr_write(),
</span></span><span style=display:flex><span>        .addr_read(fb_addr_read),
</span></span><span style=display:flex><span>        .data_in(),
</span></span><span style=display:flex><span>        .data_out(fb_colr_read)
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// display flags in system clock domain
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>logic</span> frame_sys, line_sys, line0_sys;
</span></span><span style=display:flex><span>    xd xd_frame (.clk_src(clk_pix), .clk_dst(clk_sys),
</span></span><span style=display:flex><span>        .flag_src(frame), .flag_dst(frame_sys));
</span></span><span style=display:flex><span>    xd xd_line  (.clk_src(clk_pix), .clk_dst(clk_sys),
</span></span><span style=display:flex><span>        .flag_src(line),  .flag_dst(line_sys));
</span></span><span style=display:flex><span>    xd xd_line0 (.clk_src(clk_pix), .clk_dst(clk_sys),
</span></span><span style=display:flex><span>        .flag_src(line <span style=color:#f92672>&amp;&amp;</span> sy<span style=color:#f92672>==</span><span style=color:#ae81ff>0</span>), .flag_dst(line0_sys));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// count lines for scaling via linebuffer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>logic</span> [$clog2(FB_SCALE)<span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] cnt_lb_line;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>always_ff</span> @(<span style=color:#66d9ef>posedge</span> clk_sys) <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (line0_sys) cnt_lb_line <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (line_sys) <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>            cnt_lb_line <span style=color:#f92672>&lt;=</span> (cnt_lb_line <span style=color:#f92672>==</span> FB_SCALE<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) <span style=color:#f92672>?</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>:</span> cnt_lb_line <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// which screen lines need linebuffer?
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>logic</span> lb_line;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>always_ff</span> @(<span style=color:#66d9ef>posedge</span> clk_sys) <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (line0_sys) lb_line <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>1</span>;  <span style=color:#75715e>// enable from sy==0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (frame_sys) lb_line <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span>;  <span style=color:#75715e>// disable at frame start
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// enable linebuffer input
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>logic</span> lb_en_in;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>logic</span> [$clog2(FB_WIDTH)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] cnt_lbx;  <span style=color:#75715e>// horizontal pixel counter
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>always_comb</span> lb_en_in <span style=color:#f92672>=</span> (lb_line <span style=color:#f92672>&amp;&amp;</span> cnt_lb_line <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> cnt_lbx <span style=color:#f92672>&lt;</span> FB_WIDTH);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// calculate framebuffer read address for linebuffer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>always_ff</span> @(<span style=color:#66d9ef>posedge</span> clk_sys) <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (line_sys) <span style=color:#66d9ef>begin</span>  <span style=color:#75715e>// reset horizontal counter at start of line
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            cnt_lbx <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>end</span> <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (lb_en_in) <span style=color:#66d9ef>begin</span>  <span style=color:#75715e>// increment address when LB enabled
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            fb_addr_read <span style=color:#f92672>&lt;=</span> fb_addr_read <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            cnt_lbx <span style=color:#f92672>&lt;=</span> cnt_lbx <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (frame_sys) fb_addr_read <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span>;  <span style=color:#75715e>// reset address at frame start
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// enable linebuffer output
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>logic</span> lb_en_out;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>localparam</span> LAT_LB <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>;  <span style=color:#75715e>// output latency compensation: lb_en_out+1, LB+1, CLUT+1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>always_ff</span> @(<span style=color:#66d9ef>posedge</span> clk_pix) <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>        lb_en_out <span style=color:#f92672>&lt;=</span> (sy <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> sy <span style=color:#f92672>&lt;</span> (FB_HEIGHT <span style=color:#f92672>*</span> FB_SCALE)
</span></span><span style=display:flex><span>            <span style=color:#f92672>&amp;&amp;</span> sx <span style=color:#f92672>&gt;=</span> <span style=color:#f92672>-</span>LAT_LB <span style=color:#f92672>&amp;&amp;</span> sx <span style=color:#f92672>&lt;</span> (FB_WIDTH <span style=color:#f92672>*</span> FB_SCALE) <span style=color:#f92672>-</span> LAT_LB);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// display linebuffer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>logic</span> [FB_DATAW<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] lb_colr_out;
</span></span><span style=display:flex><span>    linebuffer_simple #(
</span></span><span style=display:flex><span>        .DATAW(FB_DATAW),
</span></span><span style=display:flex><span>        .LEN(FB_WIDTH)
</span></span><span style=display:flex><span>    ) linebuffer_instance (
</span></span><span style=display:flex><span>        .clk_sys,
</span></span><span style=display:flex><span>        .clk_pix,
</span></span><span style=display:flex><span>        .line,
</span></span><span style=display:flex><span>        .line_sys,
</span></span><span style=display:flex><span>        .en_in(lb_en_in),
</span></span><span style=display:flex><span>        .en_out(lb_en_out),
</span></span><span style=display:flex><span>        .scale(FB_SCALE),
</span></span><span style=display:flex><span>        .data_in(fb_colr_read),
</span></span><span style=display:flex><span>        .data_out(lb_colr_out)
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// colour lookup table (CLUT)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>logic</span> [COLRW<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] fb_pix_colr;
</span></span><span style=display:flex><span>    clut_simple #(
</span></span><span style=display:flex><span>        .COLRW(COLRW),
</span></span><span style=display:flex><span>        .CIDXW(CIDXW),
</span></span><span style=display:flex><span>        .F_PAL(PAL_FILE)
</span></span><span style=display:flex><span>        ) clut_instance (
</span></span><span style=display:flex><span>        .clk_write(clk_pix),
</span></span><span style=display:flex><span>        .clk_read(clk_pix),
</span></span><span style=display:flex><span>        .we(<span style=color:#ae81ff>0</span>),
</span></span><span style=display:flex><span>        .cidx_write(<span style=color:#ae81ff>0</span>),
</span></span><span style=display:flex><span>        .cidx_read(lb_colr_out),
</span></span><span style=display:flex><span>        .colr_in(<span style=color:#ae81ff>0</span>),
</span></span><span style=display:flex><span>        .colr_out(fb_pix_colr)
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// paint screen
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>logic</span> paint_area;  <span style=color:#75715e>// area of screen to paint
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>logic</span> [CHANW<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] paint_r, paint_g, paint_b;  <span style=color:#75715e>// colour channels
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>always_comb</span> <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>        paint_area <span style=color:#f92672>=</span> (sy <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> sy <span style=color:#f92672>&lt;</span> (FB_HEIGHT <span style=color:#f92672>*</span> FB_SCALE)
</span></span><span style=display:flex><span>            <span style=color:#f92672>&amp;&amp;</span> sx <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> sx <span style=color:#f92672>&lt;</span> FB_WIDTH <span style=color:#f92672>*</span> FB_SCALE);
</span></span><span style=display:flex><span>        {paint_r, paint_g, paint_b} <span style=color:#f92672>=</span> paint_area <span style=color:#f92672>?</span> fb_pix_colr <span style=color:#f92672>:</span> BG_COLR;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// display colour: paint colour but black in blanking interval
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>logic</span> [CHANW<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] display_r, display_g, display_b;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>always_comb</span> {display_r, display_g, display_b} <span style=color:#f92672>=</span> (de) <span style=color:#f92672>?</span> {paint_r, paint_g, paint_b} <span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// VGA Pmod output
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>always_ff</span> @(<span style=color:#66d9ef>posedge</span> clk_pix) <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>        vga_hsync <span style=color:#f92672>&lt;=</span> hsync;
</span></span><span style=display:flex><span>        vga_vsync <span style=color:#f92672>&lt;=</span> vsync;
</span></span><span style=display:flex><span>        vga_r <span style=color:#f92672>&lt;=</span> display_r;
</span></span><span style=display:flex><span>        vga_g <span style=color:#f92672>&lt;=</span> display_g;
</span></span><span style=display:flex><span>        vga_b <span style=color:#f92672>&lt;=</span> display_b;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><p>The linebuffer handles horizontal scaling for us, but we need to keep track of the vertical lines for vertical scaling. For every <code>FB_SCALE</code> lines in the visible part of the frame, we load a fresh line of pixels from the framebuffer into the linebuffer. <code>line0_sys</code> is the first visible line in the frame.</p><h2 id=fade-away>Fade Away</h2><p>So far, we&rsquo;ve only read our image: we&rsquo;ve not made any changes to it. If we randomly write to every pixel, the image of David will fade away. We use a linear-feedback shift register (LFSR) to select the random pixels. You can learn about linear-feedback shift registers from my demo <a href=/posts/fpga-ad-astra/#linear-feedback-shift-register>Ad Astra</a>, where they&rsquo;re used to generate animated starfields.</p><p>This effect is known as fizzlefade in Wolfenstein 3D. Fabien Sanglard discusses the original id Software implementation in <a href=https://fabiensanglard.net/fizzlefade/index.php>Fizzlefade</a>.</p><p><img src=/img/posts/framebuffers/david_fizzle.png alt="Fizzled David - Verilator/SDL simulation on macOS" title="Never fade away..."></p><ul><li>iCEBreaker (iCE40): <strong><a href=https://github.com/projf/projf-explore/blob/main/graphics/framebuffers/ice40/top_david_fizzle.sv>ice40/top_david_fizzle.sv</a></strong></li><li>Arty (XC7): <strong><a href=https://github.com/projf/projf-explore/blob/main/graphics/framebuffers/xc7/top_david_fizzle.sv>xc7/top_david_fizzle.sv</a></strong></li><li>Nexys Video (XC7): <strong><a href=https://github.com/projf/projf-explore/blob/main/graphics/framebuffers/xc7-dvi/top_david_fizzle.sv>xc7-dvi/top_david_fizzle.sv</a></strong></li><li>Verilator Sim: <strong><a href=https://github.com/projf/projf-explore/blob/main/graphics/framebuffers/sim/top_david_fizzle.sv>sim/top_david_fizzle.sv</a></strong></li></ul><p>The iCEBreaker version looks like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-verilog data-lang=verilog><span style=display:flex><span><span style=color:#66d9ef>module</span> top_david_fizzle (
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>input</span>  <span style=color:#66d9ef>wire</span> <span style=color:#66d9ef>logic</span> clk_12m,      <span style=color:#75715e>// 12 MHz clock
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>input</span>  <span style=color:#66d9ef>wire</span> <span style=color:#66d9ef>logic</span> btn_rst,      <span style=color:#75715e>// reset button
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>output</span>      <span style=color:#66d9ef>logic</span> dvi_clk,      <span style=color:#75715e>// DVI pixel clock
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>output</span>      <span style=color:#66d9ef>logic</span> dvi_hsync,    <span style=color:#75715e>// DVI horizontal sync
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>output</span>      <span style=color:#66d9ef>logic</span> dvi_vsync,    <span style=color:#75715e>// DVI vertical sync
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>output</span>      <span style=color:#66d9ef>logic</span> dvi_de,       <span style=color:#75715e>// DVI data enable
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>output</span>      <span style=color:#66d9ef>logic</span> [<span style=color:#ae81ff>3</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] dvi_r,  <span style=color:#75715e>// 4-bit DVI red
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>output</span>      <span style=color:#66d9ef>logic</span> [<span style=color:#ae81ff>3</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] dvi_g,  <span style=color:#75715e>// 4-bit DVI green
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>output</span>      <span style=color:#66d9ef>logic</span> [<span style=color:#ae81ff>3</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] dvi_b   <span style=color:#75715e>// 4-bit DVI blue
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// system clock is the same as pixel clock on iCE40
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>logic</span> clk_sys, rst_sys;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>always_comb</span> <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>        clk_sys <span style=color:#f92672>=</span> clk_pix;
</span></span><span style=display:flex><span>        rst_sys <span style=color:#f92672>=</span> rst_pix;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// generate pixel clock
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>logic</span> clk_pix;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>logic</span> clk_pix_locked;
</span></span><span style=display:flex><span>    clock_480p clock_pix_inst (
</span></span><span style=display:flex><span>       .clk_12m,
</span></span><span style=display:flex><span>       .rst(btn_rst),
</span></span><span style=display:flex><span>       .clk_pix,
</span></span><span style=display:flex><span>       .clk_pix_locked
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// reset in pixel clock domain
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>logic</span> rst_pix;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>always_comb</span> rst_pix <span style=color:#f92672>=</span> <span style=color:#f92672>!</span>clk_pix_locked;  <span style=color:#75715e>// wait for clock lock
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// display sync signals and coordinates
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>localparam</span> CORDW <span style=color:#f92672>=</span> <span style=color:#ae81ff>16</span>;  <span style=color:#75715e>// signed coordinate width (bits)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>logic</span> <span style=color:#66d9ef>signed</span> [CORDW<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] sx, sy;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>logic</span> hsync, vsync;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>logic</span> de, frame, line;
</span></span><span style=display:flex><span>    display_480p #(.CORDW(CORDW)) display_inst (
</span></span><span style=display:flex><span>        .clk_pix,
</span></span><span style=display:flex><span>        .rst_pix,
</span></span><span style=display:flex><span>        .sx,
</span></span><span style=display:flex><span>        .sy,
</span></span><span style=display:flex><span>        .hsync,
</span></span><span style=display:flex><span>        .vsync,
</span></span><span style=display:flex><span>        .de,
</span></span><span style=display:flex><span>        .frame,
</span></span><span style=display:flex><span>        .line
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// library resource path
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>localparam</span> LIB_RES <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;../../../lib/res&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// bitmap images
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>localparam</span> BMAP_IMAGE <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;../res/david/david.mem&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// localparam BMAP_IMAGE = {LIB_RES,&#34;/test/test_box_160x120.mem&#34;};
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// colour palettes
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>localparam</span> PAL_FILE <span style=color:#f92672>=</span> {LIB_RES,<span style=color:#e6db74>&#34;/palettes/grey16_4b.mem&#34;</span>};
</span></span><span style=display:flex><span>    <span style=color:#75715e>// localparam PAL_FILE = {LIB_RES,&#34;/palettes/greyinvert16_4b.mem&#34;};
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// localparam PAL_FILE = {LIB_RES,&#34;/palettes/sepia16_4b.mem&#34;};
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// localparam PAL_FILE = {LIB_RES,&#34;/palettes/sweetie16_4b.mem&#34;};
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// colour parameters
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>localparam</span> CHANW <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>;        <span style=color:#75715e>// colour channel width (bits)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>localparam</span> COLRW <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span><span style=color:#f92672>*</span>CHANW;  <span style=color:#75715e>// colour width: three channels (bits)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>localparam</span> CIDXW <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>;        <span style=color:#75715e>// colour index width (bits)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>localparam</span> BG_COLR <span style=color:#f92672>=</span> <span style=color:#ae81ff>&#39;h137</span>;  <span style=color:#75715e>// background colour
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// framebuffer (FB)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>localparam</span> FB_WIDTH  <span style=color:#f92672>=</span> <span style=color:#ae81ff>160</span>;  <span style=color:#75715e>// framebuffer width in pixels
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>localparam</span> FB_HEIGHT <span style=color:#f92672>=</span> <span style=color:#ae81ff>120</span>;  <span style=color:#75715e>// framebuffer height in pixels
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>localparam</span> FB_SCALE  <span style=color:#f92672>=</span>   <span style=color:#ae81ff>4</span>;  <span style=color:#75715e>// framebuffer display scale (1-63)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>localparam</span> FB_PIXELS <span style=color:#f92672>=</span> FB_WIDTH <span style=color:#f92672>*</span> FB_HEIGHT;  <span style=color:#75715e>// total pixels in buffer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>localparam</span> FB_ADDRW  <span style=color:#f92672>=</span> $clog2(FB_PIXELS);  <span style=color:#75715e>// address width
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>localparam</span> FB_DATAW  <span style=color:#f92672>=</span> CIDXW;  <span style=color:#75715e>// colour bits per pixel
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// pixel read and write addresses and colours
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>logic</span> fb_we;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>logic</span> [FB_ADDRW<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] fb_addr_write, fb_addr_read;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>logic</span> [FB_DATAW<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] fb_colr_write, fb_colr_read;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// framebuffer memory
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    bram_sdp #(
</span></span><span style=display:flex><span>        .WIDTH(FB_DATAW),
</span></span><span style=display:flex><span>        .DEPTH(FB_PIXELS),
</span></span><span style=display:flex><span>        .INIT_F(BMAP_IMAGE)
</span></span><span style=display:flex><span>    ) bram_inst (
</span></span><span style=display:flex><span>        .clk_write(clk_sys),
</span></span><span style=display:flex><span>        .clk_read(clk_sys),
</span></span><span style=display:flex><span>        .we(fb_we),
</span></span><span style=display:flex><span>        .addr_write(fb_addr_write),
</span></span><span style=display:flex><span>        .addr_read(fb_addr_read),
</span></span><span style=display:flex><span>        .data_in(fb_colr_write),
</span></span><span style=display:flex><span>        .data_out(fb_colr_read)
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// display flags in system clock domain
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>logic</span> frame_sys, line_sys, line0_sys;
</span></span><span style=display:flex><span>    xd xd_frame (.clk_src(clk_pix), .clk_dst(clk_sys),
</span></span><span style=display:flex><span>        .flag_src(frame), .flag_dst(frame_sys));
</span></span><span style=display:flex><span>    xd xd_line  (.clk_src(clk_pix), .clk_dst(clk_sys),
</span></span><span style=display:flex><span>        .flag_src(line),  .flag_dst(line_sys));
</span></span><span style=display:flex><span>    xd xd_line0 (.clk_src(clk_pix), .clk_dst(clk_sys),
</span></span><span style=display:flex><span>        .flag_src(line <span style=color:#f92672>&amp;&amp;</span> sy<span style=color:#f92672>==</span><span style=color:#ae81ff>0</span>), .flag_dst(line0_sys));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// fizzlefade!
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>logic</span> lfsr_en;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>logic</span> [<span style=color:#ae81ff>14</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] lfsr;
</span></span><span style=display:flex><span>    lfsr #(  <span style=color:#75715e>// 15-bit LFSR (160x120 &lt; 2^15)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        .LEN(<span style=color:#ae81ff>15</span>),
</span></span><span style=display:flex><span>        .TAPS(<span style=color:#ae81ff>15</span><span style=color:#ae81ff>&#39;b110000000000000</span>)
</span></span><span style=display:flex><span>    ) lsfr_fz (
</span></span><span style=display:flex><span>        .clk(clk_sys),
</span></span><span style=display:flex><span>        .rst(rst_sys),
</span></span><span style=display:flex><span>        .en(lfsr_en),
</span></span><span style=display:flex><span>        .seed(<span style=color:#ae81ff>0</span>),  <span style=color:#75715e>// use default seed
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        .sreg(lfsr)
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// control fade start and rate
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>localparam</span> FADE_WAIT <span style=color:#f92672>=</span> <span style=color:#ae81ff>300</span>;   <span style=color:#75715e>// wait for N frames before fading
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>localparam</span> FADE_RATE <span style=color:#f92672>=</span> <span style=color:#ae81ff>2000</span>;  <span style=color:#75715e>// every N system cycles update LFSR
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>logic</span> [$clog2(FADE_WAIT)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] cnt_wait;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>logic</span> [$clog2(FADE_RATE)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] cnt_rate;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>always_ff</span> @(<span style=color:#66d9ef>posedge</span> clk_sys) <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (frame_sys) cnt_wait <span style=color:#f92672>&lt;=</span> (cnt_wait <span style=color:#f92672>!=</span> FADE_WAIT<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) <span style=color:#f92672>?</span> cnt_wait <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>:</span> cnt_wait;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (cnt_wait <span style=color:#f92672>==</span> FADE_WAIT<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (cnt_rate <span style=color:#f92672>==</span> FADE_RATE<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>                lfsr_en <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>                fb_we <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>                fb_addr_write <span style=color:#f92672>&lt;=</span> lfsr;
</span></span><span style=display:flex><span>                cnt_rate <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>end</span> <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>                cnt_rate <span style=color:#f92672>&lt;=</span> cnt_rate <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>                lfsr_en <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>                fb_we <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>        fb_colr_write <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>4&#39;h7</span>;  <span style=color:#75715e>// fade colour
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// count lines for scaling via linebuffer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>logic</span> [$clog2(FB_SCALE)<span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] cnt_lb_line;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>always_ff</span> @(<span style=color:#66d9ef>posedge</span> clk_sys) <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (line0_sys) cnt_lb_line <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (line_sys) <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>            cnt_lb_line <span style=color:#f92672>&lt;=</span> (cnt_lb_line <span style=color:#f92672>==</span> FB_SCALE<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) <span style=color:#f92672>?</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>:</span> cnt_lb_line <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// which screen lines need linebuffer?
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>logic</span> lb_line;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>always_ff</span> @(<span style=color:#66d9ef>posedge</span> clk_sys) <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (line0_sys) lb_line <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>1</span>;  <span style=color:#75715e>// enable from sy==0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (frame_sys) lb_line <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span>;  <span style=color:#75715e>// disable at frame start
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// enable linebuffer input
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>logic</span> lb_en_in;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>logic</span> [$clog2(FB_WIDTH)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] cnt_lbx;  <span style=color:#75715e>// horizontal pixel counter
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>always_comb</span> lb_en_in <span style=color:#f92672>=</span> (lb_line <span style=color:#f92672>&amp;&amp;</span> cnt_lb_line <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> cnt_lbx <span style=color:#f92672>&lt;</span> FB_WIDTH);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// calculate framebuffer read address for linebuffer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>always_ff</span> @(<span style=color:#66d9ef>posedge</span> clk_sys) <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (line_sys) <span style=color:#66d9ef>begin</span>  <span style=color:#75715e>// reset horizontal counter at start of line
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            cnt_lbx <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>end</span> <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (lb_en_in) <span style=color:#66d9ef>begin</span>  <span style=color:#75715e>// increment address when LB enabled
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            fb_addr_read <span style=color:#f92672>&lt;=</span> fb_addr_read <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            cnt_lbx <span style=color:#f92672>&lt;=</span> cnt_lbx <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (frame_sys) fb_addr_read <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span>;  <span style=color:#75715e>// reset address at frame start
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// enable linebuffer output
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>logic</span> lb_en_out;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>localparam</span> LAT_LB <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>;  <span style=color:#75715e>// output latency compensation: lb_en_out+1, LB+1, CLUT+1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>always_ff</span> @(<span style=color:#66d9ef>posedge</span> clk_pix) <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>        lb_en_out <span style=color:#f92672>&lt;=</span> (sy <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> sy <span style=color:#f92672>&lt;</span> (FB_HEIGHT <span style=color:#f92672>*</span> FB_SCALE)
</span></span><span style=display:flex><span>            <span style=color:#f92672>&amp;&amp;</span> sx <span style=color:#f92672>&gt;=</span> <span style=color:#f92672>-</span>LAT_LB <span style=color:#f92672>&amp;&amp;</span> sx <span style=color:#f92672>&lt;</span> (FB_WIDTH <span style=color:#f92672>*</span> FB_SCALE) <span style=color:#f92672>-</span> LAT_LB);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// display linebuffer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>logic</span> [FB_DATAW<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] lb_colr_out;
</span></span><span style=display:flex><span>    linebuffer_simple #(
</span></span><span style=display:flex><span>        .DATAW(FB_DATAW),
</span></span><span style=display:flex><span>        .LEN(FB_WIDTH)
</span></span><span style=display:flex><span>    ) linebuffer_instance (
</span></span><span style=display:flex><span>        .clk_sys,
</span></span><span style=display:flex><span>        .clk_pix,
</span></span><span style=display:flex><span>        .line,
</span></span><span style=display:flex><span>        .line_sys,
</span></span><span style=display:flex><span>        .en_in(lb_en_in),
</span></span><span style=display:flex><span>        .en_out(lb_en_out),
</span></span><span style=display:flex><span>        .scale(FB_SCALE),
</span></span><span style=display:flex><span>        .data_in(fb_colr_read),
</span></span><span style=display:flex><span>        .data_out(lb_colr_out)
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// colour lookup table (CLUT)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>logic</span> [COLRW<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] fb_pix_colr;
</span></span><span style=display:flex><span>    clut_simple #(
</span></span><span style=display:flex><span>        .COLRW(COLRW),
</span></span><span style=display:flex><span>        .CIDXW(CIDXW),
</span></span><span style=display:flex><span>        .F_PAL(PAL_FILE)
</span></span><span style=display:flex><span>        ) clut_instance (
</span></span><span style=display:flex><span>        .clk_write(clk_pix),
</span></span><span style=display:flex><span>        .clk_read(clk_pix),
</span></span><span style=display:flex><span>        .we(<span style=color:#ae81ff>0</span>),
</span></span><span style=display:flex><span>        .cidx_write(<span style=color:#ae81ff>0</span>),
</span></span><span style=display:flex><span>        .cidx_read(lb_colr_out),
</span></span><span style=display:flex><span>        .colr_in(<span style=color:#ae81ff>0</span>),
</span></span><span style=display:flex><span>        .colr_out(fb_pix_colr)
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// paint screen
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>logic</span> paint_area;  <span style=color:#75715e>// area of screen to paint
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>logic</span> [CHANW<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] paint_r, paint_g, paint_b;  <span style=color:#75715e>// colour channels
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>always_comb</span> <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>        paint_area <span style=color:#f92672>=</span> (sy <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> sy <span style=color:#f92672>&lt;</span> (FB_HEIGHT <span style=color:#f92672>*</span> FB_SCALE)
</span></span><span style=display:flex><span>            <span style=color:#f92672>&amp;&amp;</span> sx <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> sx <span style=color:#f92672>&lt;</span> FB_WIDTH <span style=color:#f92672>*</span> FB_SCALE);
</span></span><span style=display:flex><span>        {paint_r, paint_g, paint_b} <span style=color:#f92672>=</span> paint_area <span style=color:#f92672>?</span> fb_pix_colr <span style=color:#f92672>:</span> BG_COLR;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// display colour: paint colour but black in blanking interval
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>logic</span> [CHANW<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] display_r, display_g, display_b;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>always_comb</span> {display_r, display_g, display_b} <span style=color:#f92672>=</span> (de) <span style=color:#f92672>?</span> {paint_r, paint_g, paint_b} <span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// DVI Pmod output
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    SB_IO #(
</span></span><span style=display:flex><span>        .PIN_TYPE(<span style=color:#ae81ff>6</span><span style=color:#ae81ff>&#39;b010100</span>)  <span style=color:#75715e>// PIN_OUTPUT_REGISTERED
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    ) dvi_signal_io [<span style=color:#ae81ff>14</span><span style=color:#f92672>:</span><span style=color:#ae81ff>0</span>] (
</span></span><span style=display:flex><span>        .PACKAGE_PIN({dvi_hsync, dvi_vsync, dvi_de, dvi_r, dvi_g, dvi_b}),
</span></span><span style=display:flex><span>        .OUTPUT_CLK(clk_pix),
</span></span><span style=display:flex><span>        .D_OUT_0({hsync, vsync, de, display_r, display_g, display_b}),
</span></span><span style=display:flex><span>        .D_OUT_1()
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// DVI Pmod clock output: 180¬∞ out of phase with other DVI signals
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    SB_IO #(
</span></span><span style=display:flex><span>        .PIN_TYPE(<span style=color:#ae81ff>6</span><span style=color:#ae81ff>&#39;b010000</span>)  <span style=color:#75715e>// PIN_OUTPUT_DDR
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    ) dvi_clk_io (
</span></span><span style=display:flex><span>        .PACKAGE_PIN(dvi_clk),
</span></span><span style=display:flex><span>        .OUTPUT_CLK(clk_pix),
</span></span><span style=display:flex><span>        .D_OUT_0(<span style=color:#ae81ff>1</span><span style=color:#ae81ff>&#39;b0</span>),
</span></span><span style=display:flex><span>        .D_OUT_1(<span style=color:#ae81ff>1</span><span style=color:#ae81ff>&#39;b1</span>)
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span><span style=color:#66d9ef>endmodule</span>
</span></span></code></pre></div><p>NB. The LFSR never generates a zero value, so the first pixel never fades.</p><h2 id=creating-your-own-images>Creating Your Own Images</h2><p>You can easily create your own images using <strong>img2fmem</strong>. The script is written in Python and uses the Pillow image library to perform the conversion. You can find it in the Project F <a href=https://github.com/projf/fpgatools>FPGA Tools</a> repo. Make sure your images are the same dimensions as the framebuffer you&rsquo;re using.</p><p>To convert an image called <code>acme.png</code> to 4-bit colour with a 12-bit palette for use with <code>$readmemh</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>img2fmem.py acme.png <span style=color:#ae81ff>4</span> mem <span style=color:#ae81ff>12</span>
</span></span></code></pre></div><p>For details on installation and command-line options, see the <a href=https://github.com/projf/fpgatools/tree/master/img2fmem>img2fmem README</a>.</p><h2 id=explore>Explore</h2><p>I hope you enjoyed this instalment of <em>Exploring FPGA Graphics</em>, but nothing beats creating your own designs. Here are a few suggestions to get you started:</p><ul><li>Create your own picture with <a href=https://github.com/projf/fpgatools>img2fmem</a></li><li>Update the fizzle design to handle the first pixel (address zero)</li><li>How much memory does a 320x240 framebuffer with 16 colours require?<ul><li>Does it fit into BRAM on your FPGA board?</li></ul></li><li>If you have an Arty board, try increasing the system clock to 200 MHz<ul><li>Does the design still pass timing?</li></ul></li></ul><h2 id=whats-next>What&rsquo;s Next?</h2><p>In <a href=/posts/lines-and-triangles/>lines and triangles</a>, we&rsquo;ll implement Bresenham&rsquo;s line algorithm in Verilog and create lines, triangles, and even a cube (our first sort-of 3D). Check out <a href=/demos/>demos</a> and <a href=/tutorials/>tutorials</a> for more FPGA projects.</p></section><footer class="mt-12 flex flex-wrap"><a class="mb-1.5 mr-1.5 rounded-lg bg-black/[3%] px-5 py-1.5 no-underline dark:bg-white/[8%]" href=https://projectf.io/tags/graphics>graphics</a>
<a class="mb-1.5 mr-1.5 rounded-lg bg-black/[3%] px-5 py-1.5 no-underline dark:bg-white/[8%]" href=https://projectf.io/tags/arty-a7>arty-a7</a>
<a class="mb-1.5 mr-1.5 rounded-lg bg-black/[3%] px-5 py-1.5 no-underline dark:bg-white/[8%]" href=https://projectf.io/tags/icebreaker>icebreaker</a>
<a class="mb-1.5 mr-1.5 rounded-lg bg-black/[3%] px-5 py-1.5 no-underline dark:bg-white/[8%]" href=https://projectf.io/tags/verilator>verilator</a></footer></article></main><footer class="opaco mx-auto flex h-[4.5rem] max-w-4xl items-center px-8 text-[0.9em] opacity-60"><div class=mr-auto><a class=link href=https://projectf.io>Project F</a>: A little oasis for FPGA and RISC-V design.
&copy; 2024 Will Green.</div></footer></body></html>