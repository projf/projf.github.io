<!doctype html><html class="not-ready lg:text-base" style=--bg:#fff lang=en-gb><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>RISC-V Assembler: Arithmetic - Project F</title>
<meta name=theme-color><meta name=description content="This new mini-series provides a handy guide to RISC-V for assembly programmers. This first part covers addition, subtraction, bitwise logical operations, shifts, and the often overlooked set instructions.
Share your thoughts with @WillFlux@mastodon.social or @WillFlux on Twitter.
Arithmetic Instructions This post covers arithmetic instructions using registers (R-type). All the arguments for these instructions are in registers. A forthcoming post will cover immediate instructions, such as addi and ori.
RISC-V arithmetic instructions have three register operands:"><meta name=author content="Will Green"><link rel="preload stylesheet" as=style href=https://projectf.io/main.min.css><link rel=preload as=image href=https://projectf.io/theme.png><link rel=preload as=image href=https://projectf.io/twitter.svg><link rel=preload as=image href=https://projectf.io/github.svg><link rel=preload as=image href=https://projectf.io/mastodon.svg><link rel=preload as=image href=https://projectf.io/rss.svg><script defer src=https://projectf.io/highlight.min.js onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://projectf.io/favicon.ico><link rel=apple-touch-icon href=https://projectf.io/apple-touch-icon.png><meta name=generator content="Hugo 0.121.2"><script src=https://cdn-eu.usefathom.com/script.js data-site=EVCGKVDN defer></script><meta itemprop=name content="RISC-V Assembler: Arithmetic"><meta itemprop=description content="This new mini-series provides a handy guide to RISC-V for assembly programmers. This first part covers addition, subtraction, bitwise logical operations, shifts, and the often overlooked set instructions.
Share your thoughts with @WillFlux@mastodon.social or @WillFlux on Twitter.
Arithmetic Instructions This post covers arithmetic instructions using registers (R-type). All the arguments for these instructions are in registers. A forthcoming post will cover immediate instructions, such as addi and ori.
RISC-V arithmetic instructions have three register operands:"><meta itemprop=datePublished content="2024-01-10T00:00:00+00:00"><meta itemprop=dateModified content="2024-01-11T00:00:00+00:00"><meta itemprop=wordCount content="1029"><meta itemprop=image content="https://projectf.io/posts/riscv-arithmetic/img/social/risc-arithmetic.png"><meta itemprop=keywords content><meta property="og:title" content="RISC-V Assembler: Arithmetic"><meta property="og:description" content="This new mini-series provides a handy guide to RISC-V for assembly programmers. This first part covers addition, subtraction, bitwise logical operations, shifts, and the often overlooked set instructions.
Share your thoughts with @WillFlux@mastodon.social or @WillFlux on Twitter.
Arithmetic Instructions This post covers arithmetic instructions using registers (R-type). All the arguments for these instructions are in registers. A forthcoming post will cover immediate instructions, such as addi and ori.
RISC-V arithmetic instructions have three register operands:"><meta property="og:type" content="article"><meta property="og:url" content="https://projectf.io/posts/riscv-arithmetic/"><meta property="og:image" content="https://projectf.io/posts/riscv-arithmetic/img/social/risc-arithmetic.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-01-10T00:00:00+00:00"><meta property="article:modified_time" content="2024-01-11T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://projectf.io/posts/riscv-arithmetic/img/social/risc-arithmetic.png"><meta name=twitter:title content="RISC-V Assembler: Arithmetic"><meta name=twitter:description content="This new mini-series provides a handy guide to RISC-V for assembly programmers. This first part covers addition, subtraction, bitwise logical operations, shifts, and the often overlooked set instructions.
Share your thoughts with @WillFlux@mastodon.social or @WillFlux on Twitter.
Arithmetic Instructions This post covers arithmetic instructions using registers (R-type). All the arguments for these instructions are in registers. A forthcoming post will cover immediate instructions, such as addi and ori.
RISC-V arithmetic instructions have three register operands:"><link rel=canonical href=https://projectf.io/posts/riscv-arithmetic/></head><body class="text-black duration-200 ease-out dark:text-white"><header class="mx-auto flex h-[4.5rem] max-w-4xl px-8 lg:justify-center"><div class="relative z-50 mr-auto flex items-center"><a class="-translate-x-[1px] -translate-y-[1px] text-2xl font-semibold" href=https://projectf.io>Project F</a><div class="btn-dark text-[0] ml-4 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.png)_left_center/_auto_theme('spacing.6')_no-repeat] [transition:_background-position_0.4s_steps(5)] dark:[background-position:right]" role=button aria-label=Dark></div></div><div class="btn-menu relative z-50 -mr-8 flex h-[4.5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden" role=button aria-label=Menu></div><script>const htmlClass=document.documentElement.classList;setTimeout(()=>{htmlClass.remove("not-ready")},10);const btnMenu=document.querySelector(".btn-menu");btnMenu.addEventListener("click",()=>{htmlClass.toggle("open")});const metaTheme=document.querySelector('meta[name="theme-color"]'),lightBg="#fff".replace(/"/g,""),setDark=e=>{metaTheme.setAttribute("content",e?"#000":lightBg),htmlClass[e?"add":"remove"]("dark"),localStorage.setItem("dark",e)},darkScheme=window.matchMedia("(prefers-color-scheme: dark)");if(htmlClass.contains("dark"))setDark(!0);else{const e=localStorage.getItem("dark");setDark(e?e==="true":darkScheme.matches)}darkScheme.addEventListener("change",e=>{setDark(e.matches)});const btnDark=document.querySelector(".btn-dark");btnDark.addEventListener("click",()=>{setDark(localStorage.getItem("dark")!=="true")})</script><div class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full select-none flex-col justify-center pb-16 duration-200 dark:bg-black lg:static lg:h-auto lg:flex-row lg:!bg-transparent lg:pb-0 lg:transition-none"><nav class="lg:ml-12 lg:flex lg:flex-row lg:items-center lg:space-x-6"><a class="block text-center text-2xl leading-[5rem] lg:text-base lg:font-normal" href=/about/>About</a>
<a class="block text-center text-2xl leading-[5rem] lg:text-base lg:font-normal" href=/demos/>Demos</a>
<a class="block text-center text-2xl leading-[5rem] lg:text-base lg:font-normal" href=/verilog-lib/>Lib</a>
<a class="block text-center text-2xl leading-[5rem] lg:text-base lg:font-normal" href=/tools/>Tools</a>
<a class="block text-center text-2xl leading-[5rem] lg:text-base lg:font-normal" href=/tutorials/>Tutorials</a></nav><nav class="mt-12 flex justify-center space-x-10 dark:invert lg:ml-12 lg:mt-0 lg:items-center lg:space-x-6"><a class="h-8 w-8 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./twitter.svg) href=https://twitter.com/@WillFlux target=_blank rel=me>twitter
</a><a class="h-8 w-8 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./github.svg) href=https://github.com/projf target=_blank rel=me>github
</a><a class="h-8 w-8 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./mastodon.svg) href=https://mastodon.social/@WillFlux target=_blank rel=me>mastodon
</a><a class="h-8 w-8 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./rss.svg) href=https://projectf.io/index.xml target=_blank rel=alternate>rss</a></nav></div></header><main class="prose prose-neutral relative mx-auto min-h-[calc(100%-9rem)] max-w-4xl px-8 pb-4 pt-4 dark:prose-invert"><article><header class=mb-4><h1 class="!my-0 pb-2.5">RISC-V Assembler: Arithmetic</h1><div class="text-sm antialiased opacity-60">Published
<time>10 Jan 2024</time>
<span class=mx-1>&#183;</span>
<span>Updated
<time>11 Jan 2024</time></span></div></header><section><p>This new mini-series provides a handy guide to RISC-V for assembly programmers. This first part covers addition, subtraction, bitwise logical operations, shifts, and the often overlooked set instructions.</p><p>Share your thoughts with <a href=https://mastodon.social/@WillFlux>@WillFlux@mastodon.social</a> or <a href=https://twitter.com/WillFlux>@WillFlux</a> on Twitter.</p><h2 id=arithmetic-instructions>Arithmetic Instructions</h2><p>This post covers arithmetic instructions using registers (R-type). All the arguments for these instructions are in registers. A forthcoming post will cover immediate instructions, such as <strong>addi</strong> and <strong>ori</strong>.</p><p>RISC-V arithmetic instructions have three register operands:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>NAME</span> <span style=color:#66d9ef>rd</span>, <span style=color:#66d9ef>rs1</span>, <span style=color:#66d9ef>rs2</span>
</span></span></code></pre></div><ul><li><code>rd</code> - destination register</li><li><code>rs1</code> - first source register</li><li><code>rs2</code> - second source register</li></ul><p>For example, addition:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>add</span> <span style=color:#66d9ef>rd</span>, <span style=color:#66d9ef>rs1</span>, <span style=color:#66d9ef>rs2</span>  <span style=color:#75715e># rd = rs1 + rs2
</span></span></span></code></pre></div><p>With three register operands, you can <em>choose</em> whether to overwrite one of the source registers (see examples below). In x86 and 68K CPUs, the add instruction overwrites the first source register.</p><h2 id=addition-and-subtraction>Addition and Subtraction</h2><p>Addition and subtraction are cornerstones of any assembly programming.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>add</span> <span style=color:#66d9ef>rd</span>, <span style=color:#66d9ef>rs1</span>, <span style=color:#66d9ef>rs2</span>  <span style=color:#75715e># add:      rd = rs1 + rs2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>sub</span> <span style=color:#66d9ef>rd</span>, <span style=color:#66d9ef>rs1</span>, <span style=color:#66d9ef>rs2</span>  <span style=color:#75715e># subtract: rd = rs1 - rs2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>neg</span> <span style=color:#66d9ef>rd</span>, <span style=color:#66d9ef>rs2</span>       <span style=color:#75715e># negate:   rd = -rs2 (pseudoinstruction)
</span></span></span></code></pre></div><p>The <code>neg</code> pseudoinstruction negates a register value: positive numbers become negative and vice-versa. Negate only takes one source register because it uses <code>sub</code> with the zero register <code>x0</code> as the other source.</p><p>Pseudoinstructions are syntactic sugar that makes assembly code easier to write <em>and</em> easier to understand. Pseudoinstructions are translated into real instructions by the assembler. We&rsquo;ll see many examples in this series.</p><p>Addition and subtraction examples:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>li</span>  <span style=color:#66d9ef>t0</span>, <span style=color:#ae81ff>48</span>      <span style=color:#75715e># t0 = 48
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>li</span>  <span style=color:#66d9ef>t1</span>, <span style=color:#ae81ff>12</span>      <span style=color:#75715e># t1 = 12
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>add</span> <span style=color:#66d9ef>t3</span>, <span style=color:#66d9ef>t0</span>, <span style=color:#66d9ef>t1</span>  <span style=color:#75715e># t3 = 48 + 12 = 60  ; t0 and t1 are unchanged
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>sub</span> <span style=color:#66d9ef>t4</span>, <span style=color:#66d9ef>t0</span>, <span style=color:#66d9ef>t1</span>  <span style=color:#75715e># t4 = 48 - 12 = 36
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>add</span> <span style=color:#66d9ef>t4</span>, <span style=color:#66d9ef>t4</span>, <span style=color:#66d9ef>t0</span>  <span style=color:#75715e># t4 = 36 + 48 = 84  ; using a source register as a destination
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e># The next two examples generate the same machine code
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>neg</span> <span style=color:#66d9ef>t6</span>, <span style=color:#66d9ef>t0</span>      <span style=color:#75715e># t6 = -48
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>sub</span> <span style=color:#66d9ef>t6</span>, <span style=color:#66d9ef>x0</span>, <span style=color:#66d9ef>t0</span>  <span style=color:#75715e># t6 = 0 - 48 = -48  ; The x0 register is always zero
</span></span></span></code></pre></div><p>These examples use load immediate <code>li</code> to set the value of a register from an immediate value. I&rsquo;ll explain <code>li</code> in a forthcoming post.</p><p>Multiplication and division are in the RISC-V &lsquo;M&rsquo; extension, which I will cover in a separate post.</p><h2 id=logical>Logical</h2><p>Bitwise logical operations. The operation is applied to each pair of bits in the two source registers. Exclusive OR (XOR) is true if the input bits differ. I&rsquo;ll cover logical NOT in the immediate instructions post.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>and</span> <span style=color:#66d9ef>rd</span>, <span style=color:#66d9ef>rs1</span>, <span style=color:#66d9ef>rs2</span>  <span style=color:#75715e># AND: rd = rs1 AND rs2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>or</span>  <span style=color:#66d9ef>rd</span>, <span style=color:#66d9ef>rs1</span>, <span style=color:#66d9ef>rs2</span>  <span style=color:#75715e># OR:  rd = rs1 OR  rs2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>xor</span> <span style=color:#66d9ef>rd</span>, <span style=color:#66d9ef>rs2</span>       <span style=color:#75715e># XOR: rd = rs1 XOR rs2
</span></span></span></code></pre></div><p>Logical instruction examples:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>li</span>  <span style=color:#66d9ef>t0</span>, <span style=color:#ae81ff>42</span>      <span style=color:#75715e># t0 = 42 (101010)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>li</span>  <span style=color:#66d9ef>t1</span>, <span style=color:#ae81ff>15</span>      <span style=color:#75715e># t1 = 15 (001111)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>and</span> <span style=color:#66d9ef>t4</span>, <span style=color:#66d9ef>t0</span>, <span style=color:#66d9ef>t1</span>  <span style=color:#75715e># t4 = 42 (101010) AND 15 (001111) = 10 (001010)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>or</span>  <span style=color:#66d9ef>t5</span>, <span style=color:#66d9ef>t0</span>, <span style=color:#66d9ef>t1</span>  <span style=color:#75715e># t5 = 42 (101010) OR  15 (001111) = 47 (101111)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>xor</span> <span style=color:#66d9ef>t6</span>, <span style=color:#66d9ef>t0</span>, <span style=color:#66d9ef>t1</span>  <span style=color:#75715e># t6 = 42 (101010) XOR 15 (001111) = 37 (100101)
</span></span></span></code></pre></div><p><em>The above examples show the binary values in brackets. Leading zeros are omitted.</em></p><h2 id=shift>Shift</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>sll</span> <span style=color:#66d9ef>rd</span>, <span style=color:#66d9ef>rs1</span>, <span style=color:#66d9ef>rs2</span>  <span style=color:#75715e># shift left logical:     rd = rs1 &lt;&lt; rs2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>srl</span> <span style=color:#66d9ef>rd</span>, <span style=color:#66d9ef>rs1</span>, <span style=color:#66d9ef>rs2</span>  <span style=color:#75715e># shift right logical:    rd = rs1 &gt;&gt; rs2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>sra</span> <span style=color:#66d9ef>rd</span>, <span style=color:#66d9ef>rs1</span>, <span style=color:#66d9ef>rs2</span>  <span style=color:#75715e># shift right arithmetic: rd = rs1 &gt;&gt;&gt; rs2
</span></span></span></code></pre></div><p>The shift instructions are best remembered as initialisms: <code>sll</code> is <strong>s</strong>hift <strong>l</strong>eft <strong>l</strong>ogical.</p><p>Logical shifts fill vacated bits with zero. Arithmetic shifts fill vacated bits with the most significant bit, which is usually what you want with signed numbers. This is best seen with examples:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>li</span>  <span style=color:#66d9ef>t0</span>, <span style=color:#ae81ff>42</span>      <span style=color:#75715e># t0 = (0000 0000 0000 0000 0000 0000 0010 1010)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>li</span>  <span style=color:#66d9ef>t1</span>, -<span style=color:#ae81ff>2</span>      <span style=color:#75715e># t1 = (1111 1111 1111 1111 1111 1111 1111 1110)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>li</span>  <span style=color:#66d9ef>t2</span>, <span style=color:#ae81ff>2</span>       <span style=color:#75715e># t2 = (0000 0000 0000 0000 0000 0000 0000 0010)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e># left shift by t2 bits
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>sll</span> <span style=color:#66d9ef>t3</span>, <span style=color:#66d9ef>t0</span>, <span style=color:#66d9ef>t2</span>  <span style=color:#75715e># t3 = (0000 0000 0000 0000 0000 0000 1010 1000)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e># right shift by t2 bits (MSB=0)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>srl</span> <span style=color:#66d9ef>t4</span>, <span style=color:#66d9ef>t0</span>, <span style=color:#66d9ef>t2</span>  <span style=color:#75715e># t4 = (0000 0000 0000 0000 0000 0000 0000 1010)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>sra</span> <span style=color:#66d9ef>t4</span>, <span style=color:#66d9ef>t0</span>, <span style=color:#66d9ef>t2</span>  <span style=color:#75715e># t4 = (0000 0000 0000 0000 0000 0000 0000 1010)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e># right shift by t2 bits (MSB=1)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>srl</span> <span style=color:#66d9ef>t5</span>, <span style=color:#66d9ef>t1</span>, <span style=color:#66d9ef>t2</span>  <span style=color:#75715e># t5 = (0011 1111 1111 1111 1111 1111 1111 1111)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>sra</span> <span style=color:#66d9ef>t6</span>, <span style=color:#66d9ef>t1</span>, <span style=color:#66d9ef>t2</span>  <span style=color:#75715e># t6 = (1111 1111 1111 1111 1111 1111 1111 1111)
</span></span></span></code></pre></div><p>When the MSB (most significant bit) is 0, both right shifts produce the same result.</p><p>When the MSB is 1, the results are dramatically different!</p><ul><li><code>t5 = 1,073,741,823 = 2^30-1</code></li><li><code>t6 = -1</code></li></ul><p>Check whether your numbers are signed before using right shifts, or you&rsquo;ll get nasty bugs.</p><h3 id=set>Set</h3><p>The set instructions compare two registers and write <code>1</code> to the destination register if true.</p><p>Set instructions are helpful when handling conditional tests involving multiple registers. This will become clearer when we cover branch instructions (future post).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>slt</span>  <span style=color:#66d9ef>rd</span>, <span style=color:#66d9ef>rs1</span>, <span style=color:#66d9ef>rs2</span>  <span style=color:#75715e># set (if) less than:          rd = rs1 &lt; rs2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>sltu</span> <span style=color:#66d9ef>rd</span>, <span style=color:#66d9ef>rs1</span>, <span style=color:#66d9ef>rs2</span>  <span style=color:#75715e># set (if) less than unsigned: rd = rs1 &lt; rs2 (unsigned comparison)
</span></span></span></code></pre></div><p>Set instruction examples:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>li</span>   <span style=color:#66d9ef>t0</span>, <span style=color:#ae81ff>2</span>       <span style=color:#75715e># t0 =  2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>li</span>   <span style=color:#66d9ef>t1</span>, -<span style=color:#ae81ff>2</span>      <span style=color:#75715e># t1 = -2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>li</span>   <span style=color:#66d9ef>t2</span>, <span style=color:#ae81ff>42</span>      <span style=color:#75715e># t2 = 42
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>slt</span>  <span style=color:#66d9ef>t3</span>, <span style=color:#66d9ef>t0</span>, <span style=color:#66d9ef>t2</span>  <span style=color:#75715e># t3 = 1 because 2 &lt; 42
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>sltu</span> <span style=color:#66d9ef>t4</span>, <span style=color:#66d9ef>t0</span>, <span style=color:#66d9ef>t2</span>  <span style=color:#75715e># t4 = 1 because 2 &lt; 42
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>slt</span>  <span style=color:#66d9ef>t5</span>, <span style=color:#66d9ef>t1</span>, <span style=color:#66d9ef>t2</span>  <span style=color:#75715e># t5 = 1 because -2 &lt; 42
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>sltu</span> <span style=color:#66d9ef>t6</span>, <span style=color:#66d9ef>t1</span>, <span style=color:#66d9ef>t2</span>  <span style=color:#75715e># t6 = 0 because 1073741823 &gt; 42
</span></span></span></code></pre></div><p>As with right shifts, when the MSB (most significant bit) is 0, both set instructions produce the same result. When the MSB is 1, the results are very different.</p><p>Protip: It&rsquo;s easy to confuse <em>set</em> and <em>shift</em> instruction names. If the instruction name includes a &rsquo;t&rsquo; it&rsquo;s seT.</p><h2 id=whats-next>What&rsquo;s Next?</h2><p>The next instalment of RISC-V programming will arrive soon. In the meantime, why not check out my <a href=/tutorials/>FPGA Tutorials</a> or <a href=https://systemtalk.org/post/macintosh-history-8510/>Macintosh History Series</a>.</p><p>If you like what I do, consider <a href=https://github.com/sponsors/WillGreen>sponsoring me</a>. Thank you.</p></section></article></main><footer class="opaco mx-auto flex h-[4.5rem] max-w-4xl items-center px-8 text-[0.9em] opacity-60"><div class=mr-auto><a class=link href=https://projectf.io>Project F</a>
&copy; 2024 Will Green.</div></footer></body></html>