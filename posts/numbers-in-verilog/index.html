<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"  lang="en-gb">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1"/>

<title>Numbers in Verilog | Project F - FPGA Development</title>

<meta property='og:title' content='Numbers in Verilog - Project F - FPGA Development'>
<meta property='og:description' content='Welcome to my new series covering mathematics and algorithms with FPGAs. Whatever hardware you&rsquo;re designing, you&rsquo;re likely to be working with numbers. This series begins with the basics of Verilog numbers, covers simple mathematics, including division and CORDIC, before looking at more complex algorithms, such as data compression.
In this first post, we examine how integers (whole numbers) are represented and dig into the challenges of signed numbers in Verilog.'>
<meta property='og:url' content='https://projectf.io/posts/numbers-in-verilog/'>
<meta property='og:site_name' content='Project F - FPGA Development'>
<meta property='og:type' content='article'><meta property='og:image' content='https://projectf.io/img/posts/numbers-in-verilog/social-card.png'><meta property='article:published_time' content='2021-09-30T00:00:00Z'/><meta property='article:modified_time' content='2021-10-26T00:00:00Z'/><meta name='twitter:card' content='summary_large_image'><meta name='twitter:site' content='@WillFlux'><meta name='twitter:creator' content='@WillFlux'>


<link href="https://projectf.io/index.xml" rel="alternate" type="application/rss+xml" title="Project F - FPGA Development" />

<link rel="stylesheet" href="/css/style.css"/><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
<link rel="canonical" href="https://projectf.io/posts/numbers-in-verilog/">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff">
<meta name="referrer" content="no-referrer, same-origin">
</head>
<body>
<section class="section">
  <div class="container">
    <nav id="nav-main" class="nav">
      <div id="nav-name" class="nav-left">
        <a id="nav-anchor" class="nav-item" href="https://projectf.io">
          <h1 id="nav-heading" class="title is-4">Project F - FPGA Development</h1>
        </a>
      </div>
      <div class="nav-right">
        <nav id="nav-items" class="nav-item level is-mobile"><a class="level-item" aria-label="github" href='https://github.com/projf/projf-explore'
            target='_blank' rel='noopener'>
            <span class="icon">
              <i class><svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
    
    <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"/>
    
  </svg></i>
            </span>
          </a><a class="level-item" aria-label="twitter" href='https://twitter.com/WillFlux'
            target='_blank' rel='noopener'>
            <span class="icon">
              <i class><svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
    
    <path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"/>
    
  </svg></i>
            </span>
          </a><a class="level-item" aria-label="youtube" href='https://youtube.com/channel/UCaT0lvfWo1GStbp0neg8weg'
            target='_blank' rel='noopener'>
            <span class="icon">
              <i class><svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
    
    <path d="M22.54 6.42a2.78 2.78 0 0 0-1.94-2C18.88 4 12 4 12 4s-6.88 0-8.6.46a2.78 2.78 0 0 0-1.94 2A29 29 0 0 0 1 11.75a29 29 0 0 0 .46 5.33A2.78 2.78 0 0 0 3.4 19c1.72.46 8.6.46 8.6.46s6.88 0 8.6-.46a2.78 2.78 0 0 0 1.94-2 29 29 0 0 0 .46-5.25 29 29 0 0 0-.46-5.33z"/>
    <polygon points="9.75 15.02 15.5 11.75 9.75 8.48 9.75 15.02"/>
    
  </svg></i>
            </span>
          </a><a class="level-item" aria-label="rss" href='/index.xml'
            target='_blank' rel='noopener'>
            <span class="icon">
              <i class><svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
    
    <path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle>
    
  </svg></i>
            </span>
          </a></nav>
      </div>
    </nav>

    <nav class="nav">
      
      <div class="nav-left"><a class="nav-item" href="/about">
          <h2 class="title is-5">About</h2>
        </a><a class="nav-item" href="/sitemap">
          <h2 class="title is-5">Site Map</h2>
        </a><a class="nav-item" href="/tags/cookbook">
          <h2 class="title is-5">Cookbook</h2>
        </a><a class="nav-item" href="/tags/graphics">
          <h2 class="title is-5">Graphics</h2>
        </a><a class="nav-item" href="/tags/maths">
          <h2 class="title is-5">Maths</h2>
        </a><a class="nav-item" href="/tags/tools">
          <h2 class="title is-5">Tools</h2>
        </a></div>
      

      
    </nav>

  </div>
  <script src="/js/navicon-shift.js"></script>
</section>
<section class="section">
  <div class="container">
    <div class="subtitle tags is-6 is-pulled-right">
      
      
<a class="subtitle is-6" href="/tags/explore/">#explore</a>



  
  | <a class="subtitle is-6" href="/tags/maths/">#maths</a>
  


      
    </div>
    <h2 class="subtitle is-6">30 September 2021</h2>
    <h1 class="title">Numbers in Verilog</h1>
    
    <div class="content">
      <p>Welcome to my new series covering mathematics and algorithms with FPGAs. Whatever hardware you&rsquo;re designing, you&rsquo;re likely to be working with numbers. This series begins with the basics of Verilog numbers, covers simple mathematics, including division and CORDIC, before looking at more complex algorithms, such as data compression.</p>
<p>In this first post, we examine how integers (whole numbers) are represented and dig into the challenges of signed numbers in Verilog.</p>
<p><em>Updated 2021-10-26. Share your thoughts with <a href="https://twitter.com/WillFlux">@WillFlux</a> or find me on <a href="https://1bitsquared.com/pages/chat">1BitSquared Discord</a>.</em></p>
<h2 id="representing-numbers">Representing Numbers</h2>
<p>We&rsquo;re so familair with different representations of numbers we hardly give them a second thought. For example, the following are all forty-two: XLII, 101010<sub>2</sub>, 42, 0x2A, 52<sub>8</sub>, 4.2x10<sup>1</sup>, zweiundvierzig.</p>
<p>Different representations express (almost) the same thing but work better (or worse) in different circumstances: hexadecimal is suitable for a memory address, while scientific notation compactly expresses vast and tiny numbers alike.</p>
<p>Hardware designers face similar choices and trade-offs. Do I need signed numbers? Will BCD make my design simpler? Is fixed-point accurate enough, or must I use floating point?</p>
<blockquote>
<p><strong>Cistercian Numerals</strong><br>
For something a bit less ordinary, try <a href="https://en.wikipedia.org/wiki/Cistercian_numerals">Cistercian numerals</a> (Wikipedia).</p>
</blockquote>
<h2 id="binary">Binary</h2>
<p>Computers famously &ldquo;think&rdquo; in binary, and the same is true for most electronics. Off and on, high and low. Simple, right?</p>
<p>For positive integers, things are pretty straightforward. Let&rsquo;s take a look at 42 in binary:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-plaintext" data-lang="plaintext">32   16    8    4    2    1
 ^    ^    ^    ^    ^    ^
 1    0    1    0    1    0
</code></pre></div><p><code>32 + 8 + 2 = 42</code></p>
<p>Each binary digit is twice the previous one: 1, 2, 4, 8, 16, 32, etc.</p>
<p>Forty-two requires at least six binary digits to represent in this way.</p>
<h3 id="binary-coded-decimal">Binary Coded Decimal</h3>
<p>But this is not the only possible representation: some systems use <strong>binary coded decimal</strong> (BCD). Packed<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup> BCD uses a nibble (4-bit) value to represent each decimal digit.</p>
<p>To get the packed BCD representation, convert each decimal digit into a 4-bit binary value:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-plaintext" data-lang="plaintext">Decimal          4    2
BCD           0100 0010

Decimal     1    0    1
BCD      0001 0000 0001

Decimal     9    8    7
BCD      1001 1000 0111
</code></pre></div><p>The BCD representation requires eight bits to represent 42, two more than the plain old binary version. However, there are advantages, including the ease of display (each nibble is one character) and the ability to accurately represent decimal numbers (such as 10.1).</p>
<p>On typical binary computers, BCD adds overhead for arithmetic operations. However, when designing your own hardware, you can support BCD directly in logic, making it an attractive option for straightforward numerical designs.</p>
<p>Wikipedia&rsquo;s <a href="https://en.wikipedia.org/wiki/Binary-coded_decimal">binary-coded decimal</a> article covers different BCD variants and sign encoding.</p>
<h3 id="bit-width">Bit Width</h3>
<p>By default, a register or wire is 1 bit wide. This is a <strong>scalar</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-verilog" data-lang="verilog"><span style="color:#66d9ef">wire</span>  x;  <span style="color:#75715e">// 1 bit wire
</span><span style="color:#75715e"></span><span style="color:#66d9ef">reg</span>   y;  <span style="color:#75715e">// also 1 bit
</span><span style="color:#75715e"></span><span style="color:#66d9ef">logic</span> z;  <span style="color:#75715e">// me too! 
</span></code></pre></div><p>A scalar can only hold 0 or 1 (but see <em>Four State Data Types</em>, below).</p>
<p>We need a vector to hold values other than 0 and 1.</p>
<p>A <strong>vector</strong> is declared like this: <code>type [upper:lower] name;</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-verilog" data-lang="verilog"><span style="color:#66d9ef">wire</span>   [<span style="color:#ae81ff">5</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] a;  <span style="color:#75715e">// 6-bit wire
</span><span style="color:#75715e"></span><span style="color:#66d9ef">logic</span> [<span style="color:#ae81ff">11</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] b;  <span style="color:#75715e">// 12-bit logic
</span></code></pre></div><p>Both <code>a</code> and <code>b</code> are vectors:</p>
<ul>
<li>Wire <strong>a</strong> handles 0-63 inclusive (2<sup>6</sup> is 64).</li>
<li>Logic <strong>b</strong> handles 0-4095 inclusive (2<sup>12</sup> is 4096).</li>
</ul>
<p>You need to ensure your vector is large enough to handle the full range of values your design requires. Synthesis tools are good at discarding unused bits, so it&rsquo;s better to err on the side of too large rather than too small.</p>
<p>Deciding the appropriate size for an algorithm requires an understanding of that algorithm. For example, I&rsquo;ve worked with an ellipse drawing algorithm that required much wider internal vectors: if you had 16 bits coordinates, you needed 48 bits for internal error calculations.</p>
<p>It&rsquo;s easy to miss the width off a signal and create a scalar by mistake:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-verilog" data-lang="verilog"><span style="color:#66d9ef">reg</span> [<span style="color:#ae81ff">11</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] x;  <span style="color:#75715e">// 12 bit (vector)
</span><span style="color:#75715e"></span><span style="color:#66d9ef">reg</span> x1;        <span style="color:#75715e">// 1 bit (scalar)
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">always_comb</span> x1 <span style="color:#f92672">=</span> x;  <span style="color:#75715e">// discards 11 bits!
</span></code></pre></div><p>Alas, many tools provide no warning on bit mismatches. To catch issues with bit widths, I strongly recommend you <a href="/posts/verilog-lint-with-verilator/">lint your designs with Verilator</a>.</p>
<blockquote>
<p><strong>Four State Data Types</strong><br>
The logic, reg, and wire data types can take one of four values: <code>0, 1, X, Z</code>, where <code>X</code> is unknown, and <code>Z</code> is high impedance. For the purposes of this introduction to numbers, we&rsquo;re going to ignore <code>X</code> and <code>Z</code>.</p>
</blockquote>
<h3 id="configurable-widths">Configurable Widths</h3>
<p>Avoid hard-coding bit widths; it limits your design flexibility.</p>
<p>Parameters provide a simple way to configure bit widths:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-verilog" data-lang="verilog"><span style="color:#66d9ef">parameter</span> ADDRW<span style="color:#f92672">=</span><span style="color:#ae81ff">16</span>;  <span style="color:#75715e">// address width: 16 bits for 2^16 memory locations
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">logic</span> [ADDRW<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] addr_read;
<span style="color:#66d9ef">logic</span> [ADDRW<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] addr_write;
</code></pre></div><p>The width of a vector often depends on another parameter, so calculating it yourself isn&rsquo;t ideal.</p>
<p>Imagine you&rsquo;re creating a game engine where the number of sprites is configurable:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-verilog" data-lang="verilog"><span style="color:#66d9ef">parameter</span> SPR_CNT<span style="color:#f92672">=</span><span style="color:#ae81ff">10</span>;   <span style="color:#75715e">// maximum number of sprites on screen
</span><span style="color:#75715e"></span><span style="color:#66d9ef">logic</span> [<span style="color:#ae81ff">3</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] sprite_id;  <span style="color:#75715e">// 4 bits is correct for a count of 10, but if SPR_CNT changes?
</span></code></pre></div><p>If we hardcode the width, then changing the sprite count will break the design.</p>
<p>Verilog 2005 introduced <code>$clog2</code> to handle this.</p>
<h3 id="calculating-widths">Calculating Widths</h3>
<p>The <code>$clog2</code> function returns the ceiling of the logarithm to base 2.</p>
<p>For example, <code>$clog2(10) = 4</code> because 2<sup>3</sup> &lt; 10 ≤ 2<sup>4</sup>.</p>
<p>If you need to handle N things (such as sprites or memory locations), then <code>$clog2(N)</code> will tell you how wide your vector needs to be:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-verilog" data-lang="verilog"><span style="color:#66d9ef">parameter</span> SPR_CNT<span style="color:#f92672">=</span><span style="color:#ae81ff">10</span>;  <span style="color:#75715e">// maximum number of sprites on screen
</span><span style="color:#75715e"></span><span style="color:#66d9ef">parameter</span> SPR_BITW<span style="color:#f92672">=</span>$clog2(SPR_CNT);  <span style="color:#75715e">// sprite ID bit width
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">logic</span> [SPR_BITW<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] sprite_id;  <span style="color:#75715e">// sprite identifier
</span></code></pre></div><p><code>$clog2</code> is handy, but you need to be careful.</p>
<p>If you&rsquo;re specifying a maximum value (rather than a count), it doesn&rsquo;t do what you want:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-verilog" data-lang="verilog"><span style="color:#66d9ef">parameter</span> MAX_VOLTAGE<span style="color:#f92672">=</span><span style="color:#ae81ff">256</span>;  <span style="color:#75715e">// maximum voltage
</span><span style="color:#75715e"></span><span style="color:#66d9ef">parameter</span> VOLTW<span style="color:#f92672">=</span>$clog2(MAX_VOLTAGE);  <span style="color:#75715e">// voltage bit width (NOT RIGHT)
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">logic</span> [VOLTW<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] volatage;  <span style="color:#75715e">// we can&#39;t handle 256!
</span></code></pre></div><p><code>$clog2</code> returns &lsquo;8&rsquo;, giving a voltage range of 0-255 inclusive. 256 is out of range.</p>
<p>If you&rsquo;re specifying a maximum value, you need to add one to the value passed to <code>$clog2</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-verilog" data-lang="verilog"><span style="color:#66d9ef">parameter</span> MAX_VOLTAGE<span style="color:#f92672">=</span><span style="color:#ae81ff">256</span>;  <span style="color:#75715e">// maximum voltage
</span><span style="color:#75715e"></span><span style="color:#66d9ef">parameter</span> VOLTW<span style="color:#f92672">=</span>$clog2(MAX_VOLTAGE<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);  <span style="color:#75715e">// voltage bit width (add one for max)
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">logic</span> [VOLTW<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] volatage;  <span style="color:#75715e">// we can now handle 256 volts :)
</span></code></pre></div><p>This problem is often hidden because it doesn&rsquo;t occur if your parameter isn&rsquo;t a power of 2. For example, if you specify &lsquo;240&rsquo; as your <code>MAX_VOLTAGE</code>, you won&rsquo;t see any issues. Later, you increase <code>MAX_VOLTAGE</code> to &lsquo;256&rsquo;, and the design has a subtle bug.</p>
<h2 id="literals">Literals</h2>
<p>Verilog gives you several options for representing literal numbers. You can use binary, decimal, octal, or hexadecimal literals and specify their width in bits.</p>
<p>I think this is easiest to understand with some examples:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-verilog" data-lang="verilog"><span style="color:#75715e">// unsigned 4-bit wide, decimal value 9
</span><span style="color:#75715e"></span><span style="color:#ae81ff">4</span><span style="color:#ae81ff">&#39;b1001</span>             <span style="color:#75715e">// binary literal
</span><span style="color:#75715e"></span><span style="color:#ae81ff">4</span><span style="color:#ae81ff">&#39;d9</span>                <span style="color:#75715e">// decimal literal
</span><span style="color:#75715e"></span><span style="color:#ae81ff">4&#39;h9</span>                <span style="color:#75715e">// hexadecimal literal
</span><span style="color:#75715e"></span><span style="color:#ae81ff">4</span><span style="color:#ae81ff">&#39;o11</span>               <span style="color:#75715e">// octal literal
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// unsigned 12-bit wide, decimal value 1024
</span><span style="color:#75715e"></span><span style="color:#ae81ff">12</span><span style="color:#ae81ff">&#39;b0100</span>_0000_0000  <span style="color:#75715e">// binary literal (underscores for readability)
</span><span style="color:#75715e"></span><span style="color:#ae81ff">12</span><span style="color:#ae81ff">&#39;d1024</span>            <span style="color:#75715e">// decimal literal
</span><span style="color:#75715e"></span><span style="color:#ae81ff">12&#39;h400</span>             <span style="color:#75715e">// hex literal
</span><span style="color:#75715e"></span><span style="color:#ae81ff">12</span><span style="color:#ae81ff">&#39;o2000</span>            <span style="color:#75715e">// octal literal
</span></code></pre></div><p>It&rsquo;s good practice to include the width and base for any literals, but they are optional.</p>
<ul>
<li>If the width is omitted, it defaults to 32-bits</li>
<li>If the base is omitted, it defaults to decimal (base 10)</li>
</ul>
<p>Here are some examples:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-verilog" data-lang="verilog"><span style="color:#75715e">// 32-bit wide
</span><span style="color:#75715e"></span><span style="color:#ae81ff">&#39;b1001</span>  <span style="color:#75715e">// unsigned binary literal
</span><span style="color:#75715e"></span><span style="color:#ae81ff">&#39;d9</span>     <span style="color:#75715e">// unsigned decimal literal
</span><span style="color:#75715e"></span><span style="color:#ae81ff">9</span>       <span style="color:#75715e">// signed decimal literal
</span><span style="color:#75715e"></span><span style="color:#ae81ff">1024</span>    <span style="color:#75715e">// signed decimal literal
</span></code></pre></div><p>NB. If you omit the base, the literal is signed! Most of the time, this isn&rsquo;t a problem, but it can lead to subtle bugs. We&rsquo;ll cover signed numbers in the next section.</p>
<h3 id="literal-tricks">Literal Tricks</h3>
<p>In SystemVerilog, you can set all the bits of a vector to &lsquo;1&rsquo;:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-verilog" data-lang="verilog"><span style="color:#75715e">// x and y have the same value:
</span><span style="color:#75715e"></span><span style="color:#66d9ef">reg</span> [<span style="color:#ae81ff">11</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] x <span style="color:#f92672">=</span> <span style="color:#ae81ff">&#39;1</span>;
<span style="color:#66d9ef">reg</span> [<span style="color:#ae81ff">11</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] y <span style="color:#f92672">=</span> <span style="color:#ae81ff">12</span><span style="color:#ae81ff">&#39;b1111</span>_1111_1111;
</code></pre></div><p>You can also use the concat operator <code>{}</code> to set specific patterns:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-verilog" data-lang="verilog"><span style="color:#66d9ef">localparam</span> COORDW <span style="color:#f92672">=</span> <span style="color:#ae81ff">12</span>;  <span style="color:#75715e">// coordinate width in bits
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">reg</span> [COORDW<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] x <span style="color:#f92672">=</span> {COORDW{<span style="color:#ae81ff">1</span><span style="color:#ae81ff">&#39;b1</span>}};  <span style="color:#75715e">// x = 1111_1111_1111
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">reg</span> [COORDW<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] y <span style="color:#f92672">=</span> { {<span style="color:#ae81ff">1</span><span style="color:#ae81ff">&#39;b1</span>}, {COORDW<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>{<span style="color:#ae81ff">1</span><span style="color:#ae81ff">&#39;b0</span>}} };  <span style="color:#75715e">// y = 1000_0000_0000
</span></code></pre></div><p>Concat allows us to set an appropriate value, however wide the vectors are.</p>
<h2 id="signed-numbers">Signed Numbers</h2>
<p>If your application requires negative values, you need to handle signed numbers. If you&rsquo;re coming at this fresh, your first instinct might be to use a sign bit. A sign bit can work but requires custom logic for arithmetic operations and leads to the thorny issue of negative zero. For regular binary numbers, the standard approach is <strong>two&rsquo;s complement</strong>.</p>
<h3 id="the-twos-complement">The Two&rsquo;s Complement</h3>
<p>With two&rsquo;s complement, addition, subtraction, and multiplication all work as they do with positive binary numbers. But what is the two&rsquo;s complement? The positive and negative two&rsquo;s complement representations of an N-bit number add up to 2<sup>N</sup>.</p>
<p>For example, with four-bit values: 7 is <code>0111</code> and -7 is <code>1001</code>, because <code>0111 + 1001 = 10000</code> (2<sup>4</sup>).</p>
<p>However, the usual way to switch the sign of a number is to invert the bits and add one:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-plaintext" data-lang="plaintext">Start:  0111    (decimal +7)
Invert: 1000
Add 1:  0001
Result: 1001    (decimal -7)

Start:  1001    (decimal -7)
Invert: 0110
Add 1:  0001
Result: 0111    (decimal +7)
</code></pre></div><p>You rarely need to determine the two&rsquo;s complement yourself; Verilog can handle it for you.</p>
<p>Let&rsquo;s look at a few simple additions to confirm things work as expected:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-plaintext" data-lang="plaintext">  0110      +6
+ 1101      -3
= 0011      +3

  1001      -7
+ 0011      +3
= 1100      -4

  1001      -7
+ 0111      +7
= 0000       0
</code></pre></div><p>The most significant bit of a signed vector is always <code>1</code> for a negative number, so it&rsquo;s easy to determine if a value is negative: we get the main benefit of a sign bit without the downsides.</p>
<p>To learn more, check out the Wikipedia article on <a href="https://en.wikipedia.org/wiki/Two's_complement">two&rsquo;s complement</a>.</p>
<h3 id="signing-your-signals">Signing Your Signals</h3>
<p>Telling Verilog that your vector is signed is easy:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-verilog" data-lang="verilog"><span style="color:#66d9ef">reg</span>        [<span style="color:#ae81ff">7</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] u;  <span style="color:#75715e">// unsigned (0..255)
</span><span style="color:#75715e"></span><span style="color:#66d9ef">reg</span> <span style="color:#66d9ef">signed</span> [<span style="color:#ae81ff">7</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] s;  <span style="color:#75715e">// signed   (-128..127)
</span></code></pre></div><p>For literals, you can add the <code>s</code> prefix to the base:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-verilog" data-lang="verilog"><span style="color:#66d9ef">reg</span> <span style="color:#66d9ef">signed</span> [<span style="color:#ae81ff">7</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] x <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">8</span>&#39;sd55;  <span style="color:#75715e">// x position: -55 (signed)
</span><span style="color:#75715e"></span><span style="color:#66d9ef">reg</span> <span style="color:#66d9ef">signed</span> [<span style="color:#ae81ff">7</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] y <span style="color:#f92672">=</span>  <span style="color:#ae81ff">8</span>&#39;sd32;  <span style="color:#75715e">// y position: +32 (signed)
</span></code></pre></div><h3 id="beware-signed-logic">Beware Signed Logic!</h3>
<p>Verilog has a nasty habit of treating things as unsigned unless all variables in an expression are signed. But you can use the <code>$signed</code> operator to force a variable to be signed if required.</p>
<p>So, if you take one thing away from this post:</p>
<p><strong>Never mix and match signed and unsigned variables!</strong></p>
<p>The following testbench shows what can happen when you mix signed and unsigned variables:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-verilog" data-lang="verilog"><span style="color:#66d9ef">module</span> signed_tb ();
    <span style="color:#66d9ef">logic</span> [<span style="color:#ae81ff">7</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] x, y;
    <span style="color:#66d9ef">logic</span> <span style="color:#66d9ef">signed</span> [<span style="color:#ae81ff">7</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] x1, y1;
    <span style="color:#66d9ef">logic</span> <span style="color:#66d9ef">signed</span> [<span style="color:#ae81ff">3</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] offset;

    <span style="color:#66d9ef">always_comb</span> <span style="color:#66d9ef">begin</span>
        x1 <span style="color:#f92672">=</span> x <span style="color:#f92672">+</span> offset;  <span style="color:#75715e">// AVOID! This probably won&#39;t work as expected!
</span><span style="color:#75715e"></span>        y1 <span style="color:#f92672">=</span> $signed(y) <span style="color:#f92672">+</span> offset;  <span style="color:#75715e">// ensure y is treated as signed
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">end</span>

    <span style="color:#66d9ef">initial</span> <span style="color:#66d9ef">begin</span>
        #<span style="color:#ae81ff">10</span>
        $display(<span style="color:#e6db74">&#34;Coordinates (7,7):&#34;</span>);
        x <span style="color:#f92672">=</span> <span style="color:#ae81ff">8</span><span style="color:#ae81ff">&#39;d7</span>;
        y <span style="color:#f92672">=</span> <span style="color:#ae81ff">8</span><span style="color:#ae81ff">&#39;d7</span>;
        #<span style="color:#ae81ff">10</span>
        $display(<span style="color:#e6db74">&#34;x : %b  %d&#34;</span>, x, x);
        $display(<span style="color:#e6db74">&#34;y : %b  %d&#34;</span>, y, y);

        #<span style="color:#ae81ff">10</span>
        $display(<span style="color:#e6db74">&#34;With offset +4:&#34;</span>);
        offset <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>&#39;sd4;
        #<span style="color:#ae81ff">10</span>
        $display(<span style="color:#e6db74">&#34;x1: %b  %d&#34;</span>, x1, x1);
        $display(<span style="color:#e6db74">&#34;y1: %b  %d&#34;</span>, y1, y1);

        #<span style="color:#ae81ff">10</span>
        $display(<span style="color:#e6db74">&#34;With offset -4:&#34;</span>);
        offset <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">4</span>&#39;sd4;
        #<span style="color:#ae81ff">10</span>
        $display(<span style="color:#e6db74">&#34;x1: %b  %d  *SURPRISE*&#34;</span>, x1, x1);
        $display(<span style="color:#e6db74">&#34;y1: %b  %d&#34;</span>, y1, y1);
    <span style="color:#66d9ef">end</span>
<span style="color:#66d9ef">endmodule</span>
</code></pre></div><p>Running this test bench gives the following output in Vivado:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-plaintext" data-lang="plaintext">Coordinates (7,7):
x : 00000111    7
y : 00000111    7
With offset +4:
x1: 00001011    11
y1: 00001011    11
With offset -4:
x1: 00010011    19  *SURPRISE*
y1: 00000011     3
</code></pre></div><h2 id="big-endian-little-endian">Big-Endian, Little-Endian</h2>
<p>Earlier, we said a vector was declared like this: <code>type [upper:lower] name;</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-verilog" data-lang="verilog"><span style="color:#66d9ef">wire</span>   [<span style="color:#ae81ff">5</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] a;  <span style="color:#75715e">// 6-bit wire (little-endian)
</span><span style="color:#75715e"></span><span style="color:#66d9ef">logic</span> [<span style="color:#ae81ff">11</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] b;  <span style="color:#75715e">// 12-bit logic (little-endian)
</span></code></pre></div><p>These vectors are <strong>little-endian</strong> because the <code>lower</code> bit is the smallest.</p>
<p>Alternatively, we could have declared the vectors like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-verilog" data-lang="verilog"><span style="color:#66d9ef">wire</span>   [<span style="color:#ae81ff">0</span><span style="color:#f92672">:</span><span style="color:#ae81ff">5</span>] a;  <span style="color:#75715e">// 6-bit wire (big-endian)
</span><span style="color:#75715e"></span><span style="color:#66d9ef">logic</span> [<span style="color:#ae81ff">0</span><span style="color:#f92672">:</span><span style="color:#ae81ff">11</span>] b;  <span style="color:#75715e">// 12-bit logic (big-endian)
</span></code></pre></div><p>These vectors are <strong>big-endian</strong> because the <code>lower</code> bit is the largest.</p>
<p>Either will work, but the convention is to use little-endian unless you need to interface with big-endian hardware. For example, I<sup>2</sup>C uses big-endian bit order.</p>
<h3 id="switching-ends">Switching Ends</h3>
<p>Say you&rsquo;ve got a bit-endian byte from I<sup>2</sup>C and want to convert it to little-endian. Alas, you can&rsquo;t mix big and little-endian vectors, so the following won&rsquo;t work:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-verilog" data-lang="verilog"><span style="color:#66d9ef">wire</span> [<span style="color:#ae81ff">0</span><span style="color:#f92672">:</span><span style="color:#ae81ff">7</span>] i2c_byte;  <span style="color:#75715e">// 8-bit wire (big-endian)
</span><span style="color:#75715e"></span><span style="color:#66d9ef">reg</span>  [<span style="color:#ae81ff">7</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] le_byte;   <span style="color:#75715e">// 8-bit reg (little-endian)
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">always</span> @(<span style="color:#66d9ef">posedge</span> clk) le_byte <span style="color:#f92672">&lt;=</span> i2c_byte;  <span style="color:#75715e">// Won&#39;t work :(
</span></code></pre></div><p>Instead you need to reverse the bits explicitly. All bits are swapped in parallel:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-verilog" data-lang="verilog"><span style="color:#66d9ef">always</span> @(<span style="color:#66d9ef">posedge</span> clk) <span style="color:#66d9ef">begin</span>
    le_byte[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&lt;=</span> i2c_byte[<span style="color:#ae81ff">7</span>];
    le_byte[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">&lt;=</span> i2c_byte[<span style="color:#ae81ff">6</span>];
    le_byte[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">&lt;=</span> i2c_byte[<span style="color:#ae81ff">5</span>];
    le_byte[<span style="color:#ae81ff">3</span>] <span style="color:#f92672">&lt;=</span> i2c_byte[<span style="color:#ae81ff">4</span>];
    le_byte[<span style="color:#ae81ff">4</span>] <span style="color:#f92672">&lt;=</span> i2c_byte[<span style="color:#ae81ff">3</span>];
    le_byte[<span style="color:#ae81ff">5</span>] <span style="color:#f92672">&lt;=</span> i2c_byte[<span style="color:#ae81ff">2</span>];
    le_byte[<span style="color:#ae81ff">6</span>] <span style="color:#f92672">&lt;=</span> i2c_byte[<span style="color:#ae81ff">1</span>];
    le_byte[<span style="color:#ae81ff">7</span>] <span style="color:#f92672">&lt;=</span> i2c_byte[<span style="color:#ae81ff">0</span>];
<span style="color:#66d9ef">end</span>
</code></pre></div><p>Handling the individual bits gets tedious fast, so Verilog lets you use a <code>for</code> loop to do the same thing:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-verilog" data-lang="verilog"><span style="color:#66d9ef">always</span> @(<span style="color:#66d9ef">posedge</span> clk) <span style="color:#66d9ef">begin</span>
    <span style="color:#66d9ef">for</span> (i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">8</span>; i<span style="color:#f92672">=</span>i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>) le_byte[i] <span style="color:#f92672">&lt;=</span> i2c_byte[<span style="color:#ae81ff">7</span><span style="color:#f92672">-</span>i];
<span style="color:#66d9ef">end</span>
</code></pre></div><p>NB. Verilog <code>for</code> is NOT like a software loop. The <code>for</code> loop is unrolled by Verilog into eight parallel bit swaps.</p>
<h3 id="byte-endian">Byte Endian</h3>
<p>So far, we&rsquo;ve been talking about endianness at the bit level, but it also occurs with bytes. If you have a 32-bit word, do you store the least significant byte at the lowest address (little-endian), or the most significant byte at the lowest address (big-endian)?</p>
<p>RISC-V, x86, and ARM are little-endian, while Internet protocols (TCP/IP) and Motorola 68K are big-endian. To learn more, hop over to Wikipedia&rsquo;s entry on <a href="https://en.wikipedia.org/wiki/Endianness">Endianness</a>.</p>
<h2 id="reckoning-with-arithmetic">Reckoning with Arithmetic</h2>
<p>We&rsquo;ve talked a lot about the representation of numbers, but we&rsquo;ve not done any maths.</p>
<p>Modern FPGAs include logic to handle addition and subtraction: there&rsquo;s no need to roll your own. If you want to create an adder from scratch, there are plenty of university slide decks online. Unless you&rsquo;re working with massive vectors, you&rsquo;re unlikely to encounter problems with addition or subtraction. The usual advice to register your values between calculation steps applies, especially when using subtraction on simpler FPGAs.</p>
<p>Multiplication is more complex, but FPGAs handle it with dedicated DSP blocks. Check your datasheet for the number and capabilities of your FPGA DSPs. Small FPGAs have only a few DSPs (for example, iCE40UP5K has eight 16x16-bit DSPs); you can easily use them all with a few multiplications. However, careful design can often avoid the need for multiplication altogether.</p>
<p>What about division? I&rsquo;ve got some bad news for you: Verilog won&rsquo;t do this for you. We&rsquo;ll look into division in detail in a later post, but for now, you can use the <a href="/posts/division-in-verilog/">division</a> design from the Project F cookbook.</p>
<h2 id="next-time">Next Time</h2>
<p>Stay tuned for the next part of <em>Maths and Algorithms with FPGAs</em>, where we&rsquo;ll look at real numbers including fixed point. Until then, why not check out our existing maths posts: <a href="/posts/division-in-verilog/">division</a>, <a href="/posts/square-root-in-verilog/">square root</a>, and <a href="/posts/fpga-sine-table/">sine &amp; cosine</a>.</p>
<p><em>Constructive feedback is always welcome. Get in touch with <a href="https://twitter.com/WillFlux">@WillFlux</a> or open an <a href="https://github.com/projf/projf-explore/issues">issue on GitHub</a>.</em></p>
<blockquote>
<p><strong>Sponsor Project F</strong><br>
If you like what I do, consider <a href="https://github.com/sponsors/WillGreen">sponsoring me</a> on GitHub.
I use contributions to spend more time creating open-source FPGA designs and tutorials.</p>
</blockquote>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>Unpacked BCD uses a whole byte (8-bits) for each decimal digit.&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>

      
      <div class="related">

<h3>Similar articles:</h3>
<ul>
	
	<li><a href="/posts/animated-shapes/">Animated Shapes</a></li>
	
	<li><a href="/posts/fpga-sine-table/">FPGA Sine Lookup Table</a></li>
	
	<li><a href="/posts/hello-arty-3/">Hello Arty - Part 3</a></li>
	
	<li><a href="/posts/fpga-shapes/">2D Shapes</a></li>
	
	<li><a href="/posts/hello-nexys-2/">Hello Nexys - Part 2</a></li>
	
</ul>
</div>
      
    </div>
    
  </div>
</section>

    <script src="/js/copycode.js"></script>



<section class="section">
  <div class="container has-text-centered">
    <p>©2021 Will Green, Project F</p>
    
  </div>
</section>


<script src="https://narwhal.projectf.io/script.js" site="EVCGKVDN" defer></script>
</body>
</html>

