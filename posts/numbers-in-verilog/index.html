<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"  lang="en-gb">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<title>Numbers in Verilog | Project F: FPGA Dev</title>

<meta property='og:title' content='Numbers in Verilog - Project F: FPGA Dev'>
<meta property='og:description' content='Welcome to my new series covering mathematics and algorithms with FPGAs. Whatever hardware you&rsquo;re designing, you&rsquo;re likely to be working with numbers. This series begins with the basics of Verilog numbers, covers simple mathematics, including division and CORDIC, before looking at more complex algorithms, such as data compression. This post was last updated in August 2022.
In this first post, we examine how integers (whole numbers) are represented and dig into the challenges of signed numbers in Verilog.'>
<meta property='og:url' content='https://projectf.io/posts/numbers-in-verilog/'>
<meta property='og:site_name' content='Project F: FPGA Dev'>
<meta property='og:type' content='article'><meta property='og:image' content='https://projectf.io/img/posts/numbers-in-verilog/social-card.png'><meta property='article:published_time' content='2021-09-30T00:00:00Z'><meta property='article:modified_time' content='2022-08-18T00:00:00Z'><meta name='twitter:card' content='summary_large_image'><meta name='twitter:site' content='@WillFlux'><meta name='twitter:creator' content='@WillFlux'>


<link href="https://projectf.io/index.xml" rel="alternate" type="application/rss+xml" title="Project F: FPGA Dev">

<link rel="stylesheet" href="/css/style.css"><link rel='stylesheet' href='https://projectf.io/css/custom.css'>

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
<link rel="canonical" href="https://projectf.io/posts/numbers-in-verilog/">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff">
</head>
<body>

<section class="section">
  <div class="container">
    <nav id="nav-main" class="nav">
      <div id="nav-name" class="nav-left">
        <a id="nav-anchor" class="nav-item" href="https://projectf.io">
          <h1 id="nav-heading" class="title is-4">Project F: FPGA Dev</h1>
        </a>
      </div>
      <div class="nav-right">
        <nav id="nav-items" class="nav-item level is-mobile"><a class="level-item" aria-label="github" href='https://github.com/projf/projf-explore'
            target='_blank' rel='noopener'>
            <span class="icon">
              <i class><svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
    
    <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"/>
    
  </svg></i>
            </span>
          </a><a class="level-item" aria-label="twitter" href='https://twitter.com/WillFlux'
            target='_blank' rel='noopener'>
            <span class="icon">
              <i class><svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
    
    <path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"/>
    
  </svg></i>
            </span>
          </a><a class="level-item" aria-label="youtube" href='https://youtube.com/@projf'
            target='_blank' rel='noopener'>
            <span class="icon">
              <i class><svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
    
    <path d="M22.54 6.42a2.78 2.78 0 0 0-1.94-2C18.88 4 12 4 12 4s-6.88 0-8.6.46a2.78 2.78 0 0 0-1.94 2A29 29 0 0 0 1 11.75a29 29 0 0 0 .46 5.33A2.78 2.78 0 0 0 3.4 19c1.72.46 8.6.46 8.6.46s6.88 0 8.6-.46a2.78 2.78 0 0 0 1.94-2 29 29 0 0 0 .46-5.25 29 29 0 0 0-.46-5.33z"/>
    <polygon points="9.75 15.02 15.5 11.75 9.75 8.48 9.75 15.02"/>
    
  </svg></i>
            </span>
          </a><a class="level-item" aria-label="rss" href='/index.xml'
            target='_blank' rel='noopener'>
            <span class="icon">
              <i class><svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
    
    <path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle>
    
  </svg></i>
            </span>
          </a></nav>
      </div>
    </nav>

    <nav class="nav">
      
      <div class="nav-left"><a class="nav-item" href="/about">
          <h2 class="title is-5">About</h2>
        </a><a class="nav-item" href="/boards">
          <h2 class="title is-5">Boards</h2>
        </a><a class="nav-item" href="/demos">
          <h2 class="title is-5">Demos</h2>
        </a><a class="nav-item" href="/howto">
          <h2 class="title is-5">How To</h2>
        </a><a class="nav-item" href="/tags/news">
          <h2 class="title is-5">News</h2>
        </a><a class="nav-item" href="/tutorials">
          <h2 class="title is-5">Tutorials</h2>
        </a><a class="nav-item" href="/verilog-lib">
          <h2 class="title is-5">Verilog Lib</h2>
        </a></div>
      

      
    </nav>

  </div>
  <script src="/js/navicon-shift.js"></script>
</section>
<section class="section">
  <div class="container">
    <div class="subtitle tags is-6 is-pulled-right">
      
      
<a class="subtitle is-6" href="/tags/maths/">#maths</a>




      
    </div>
    <h2 class="subtitle is-6">30 September 2021</h2>
    <h1 class="title">Numbers in Verilog</h1>
    
    <div class="content">
      <p>Welcome to my new series covering mathematics and algorithms with FPGAs. Whatever hardware you&rsquo;re designing, you&rsquo;re likely to be working with numbers. This series begins with the basics of Verilog numbers, covers simple mathematics, including division and CORDIC, before looking at more complex algorithms, such as data compression. This post was last updated in August 2022.</p>
<p>In this first post, we examine how integers (whole numbers) are represented and dig into the challenges of signed numbers in Verilog.</p>
<p><em>Get in touch: <a href="https://github.com/projf/projf-explore/issues">GitHub Issues</a>, <a href="https://1bitsquared.com/pages/chat">1BitSquared Discord</a>, <a href="https://mastodon.social/@WillFlux">@WillFlux</a> (Mastodon), <a href="https://twitter.com/WillFlux">@WillFlux</a> (Twitter)</em></p>
<blockquote>
<p><strong>Sponsor My Work</strong><br>
If you like what I do, consider <a href="https://github.com/sponsors/WillGreen">sponsoring me</a> on GitHub.<br>
I love FPGAs and want to help more people discover and use them in their projects.<br>
My hardware designs are open source, and my blog is advert free.</p>
</blockquote>
<h2 id="representing-numbers">Representing Numbers</h2>
<p>We&rsquo;re so familair with different representations of numbers we hardly give them a second thought.</p>
<p>The following are representations of forty-two:</p>
<ul>
<li><code>101010</code> (binary)</li>
<li><code>52</code> (octal)</li>
<li><code>42</code> (decimal)</li>
<li><code>0x2A</code> (hexadecimal)</li>
<li><code>4.2x10</code><sup><code>1</code></sup> (scientific notation)</li>
<li><code>XLII</code> (Roman numerals)</li>
<li><code>四二</code> (Japanese numerals)</li>
<li><code>zweiundvierzig</code> (German)</li>
</ul>
<p>Different representations express (almost) the same thing but work better (or worse) in different circumstances: hexadecimal is suitable for a memory address, while scientific notation compactly expresses vast and tiny numbers alike.</p>
<p>As a hardware designer you face similar choices and trade-offs. How many bits do I need? Do I need signed numbers? Will BCD make my design simpler? Is fixed-point accurate enough?</p>
<blockquote>
<p><strong>Cistercian Numerals</strong><br>
For something a bit less ordinary, try <a href="https://en.wikipedia.org/wiki/Cistercian_numerals">Cistercian numerals</a> (Wikipedia).</p>
</blockquote>
<h2 id="binary">Binary</h2>
<p>Computers famously &ldquo;think&rdquo; in binary, and the same is true for most electronics. Off and on, high and low. Simple, right?</p>
<p>For positive integers, things are pretty straightforward.</p>
<p>Let&rsquo;s take a look at 42 in binary: <strong>101010<sub>2</sub></strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plaintext" data-lang="plaintext"><span style="display:flex;"><span>32   16    8    4    2    1
</span></span><span style="display:flex;"><span> ^    ^    ^    ^    ^    ^
</span></span><span style="display:flex;"><span> 1    0    1    0    1    0
</span></span></code></pre></div><p>Each binary digit is twice the previous one: 1, 2, 4, 8, 16, 32&hellip;</p>
<p><code>32 + 8 + 2 = 42</code></p>
<p>Forty-two requires at least six binary digits to represent in this way.</p>
<h3 id="binary-coded-decimal">Binary Coded Decimal</h3>
<p>But this is not the only possible representation: some systems use <strong>binary coded decimal</strong> (BCD). Packed<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup> BCD uses a nibble (4-bit) value to represent each decimal digit.</p>
<p>To get the packed BCD representation, convert each decimal digit into a 4-bit binary value:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plaintext" data-lang="plaintext"><span style="display:flex;"><span>Decimal          4    2
</span></span><span style="display:flex;"><span>BCD           0100 0010
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Decimal     1    0    1
</span></span><span style="display:flex;"><span>BCD      0001 0000 0001
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Decimal     9    8    7
</span></span><span style="display:flex;"><span>BCD      1001 1000 0111
</span></span></code></pre></div><p>The BCD representation requires eight bits to represent 42, two more than the plain old binary version. However, there are advantages, including the ease of display (each nibble is one character) and the ability to accurately represent decimal numbers (such as 10.1).</p>
<p>On typical binary computers, BCD adds overhead for arithmetic operations. However, when designing your own hardware, you can support BCD directly in logic, making it an attractive option for straightforward numerical designs.</p>
<p>Wikipedia&rsquo;s <a href="https://en.wikipedia.org/wiki/Binary-coded_decimal">binary-coded decimal</a> article covers different BCD variants and sign encoding.</p>
<p>Interesting as BCD is, we&rsquo;ll be sticking with plain old binary for the rest of this document. Many of the concepts we&rsquo;ll cover also apply to BCD.</p>
<h2 id="binary-in-verilog">Binary in Verilog</h2>
<p>By default, a Verilog register or wire is 1 bit wide. This is a <strong>scalar</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#66d9ef">wire</span>  x;  <span style="color:#75715e">// 1 bit wire
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">reg</span>   y;  <span style="color:#75715e">// also 1 bit
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">logic</span> z;  <span style="color:#75715e">// me too!
</span></span></span></code></pre></div><p>A scalar can only hold 0 or 1 (but see <em>Four State Data Types</em>, below).</p>
<p>We need a <strong>vector</strong> to hold values other than 0 and 1.</p>
<p>A vector is declared like this: <code>type [upper:lower] name;</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#66d9ef">wire</span>   [<span style="color:#ae81ff">5</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] a;  <span style="color:#75715e">// 6-bit wire
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">reg</span>    [<span style="color:#ae81ff">7</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] b;  <span style="color:#75715e">// 8-bit reg
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">logic</span> [<span style="color:#ae81ff">11</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] c;  <span style="color:#75715e">// 12-bit logic
</span></span></span></code></pre></div><p><code>a</code>, <code>b</code>, and <code>c</code> are vectors:</p>
<ul>
<li>Wire <strong>a</strong> handles 0-63 inclusive (2<sup>6</sup> is 64).</li>
<li>Register <strong>b</strong> handles 0-255 inclusive (2<sup>8</sup> is 256).</li>
<li>Logic <strong>c</strong> handles 0-4095 inclusive (2<sup>12</sup> is 4096).</li>
</ul>
<p>You need to ensure your vector is large enough to handle the full range of values your design requires. Synthesis tools are good at discarding unused bits, so it&rsquo;s better to err on the side of too large rather than too small.</p>
<p>Deciding on the appropriate vector width for an algorithm requires an understanding of that algorithm. For example, I&rsquo;ve worked with an ellipse drawing algorithm that required 48-bit internal vectors when using 16-bits coordinates.</p>
<p>It&rsquo;s easy to miss the width off a signal and create a scalar by mistake:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#66d9ef">wire</span> [<span style="color:#ae81ff">11</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] x;  <span style="color:#75715e">// 12 bit (vector)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">wire</span> x1;        <span style="color:#75715e">// 1 bit (scalar)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">always_comb</span> x1 <span style="color:#f92672">=</span> x;  <span style="color:#75715e">// discards 11 bits!
</span></span></span></code></pre></div><p>Alas, many tools provide no warning on width mismatches. To catch issues with bit widths, I strongly recommend you <a href="/posts/verilog-lint-with-verilator/">lint your designs with Verilator</a>.</p>
<blockquote>
<p><strong>Four State Data Types</strong><br>
The logic, reg, and wire data types can take one of four values: <code>0, 1, X, Z</code>, where <code>X</code> is unknown, and <code>Z</code> is high impedance. For the purposes of this introduction to numbers, we&rsquo;re going to ignore <code>X</code> and <code>Z</code>.</p>
</blockquote>
<h3 id="slicing-vectors">Slicing Vectors</h3>
<p>You can select an individual vector bit with its index; for example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#66d9ef">wire</span> [<span style="color:#ae81ff">3</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] n;  <span style="color:#75715e">// 4-bit wire vector
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">wire</span> p, q;     <span style="color:#75715e">// wire scalars
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">always_comb</span> <span style="color:#66d9ef">begin</span>
</span></span><span style="display:flex;"><span>    p <span style="color:#f92672">=</span> n[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>    q <span style="color:#f92672">=</span> n[<span style="color:#ae81ff">3</span>];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span></code></pre></div><p>You select a subset by specifying the start and end bits:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#66d9ef">wire</span> [<span style="color:#ae81ff">11</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] a;       <span style="color:#75715e">// 12-bit wire vector
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">wire</span> [<span style="color:#ae81ff">3</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] x, y, z;  <span style="color:#75715e">// 4-bit wire vectors
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">always_comb</span> <span style="color:#66d9ef">begin</span>
</span></span><span style="display:flex;"><span>    x <span style="color:#f92672">=</span> a[<span style="color:#ae81ff">11</span><span style="color:#f92672">:</span><span style="color:#ae81ff">8</span>];
</span></span><span style="display:flex;"><span>    y <span style="color:#f92672">=</span> a[<span style="color:#ae81ff">7</span><span style="color:#f92672">:</span><span style="color:#ae81ff">4</span>];
</span></span><span style="display:flex;"><span>    z <span style="color:#f92672">=</span> a[<span style="color:#ae81ff">3</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span></code></pre></div><p>You can also use the concat operator <code>{}</code> to select bits from vectors. The following example is equivilent to the one above:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#66d9ef">wire</span> [<span style="color:#ae81ff">11</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] a;       <span style="color:#75715e">// 12-bit wire vector
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">wire</span> [<span style="color:#ae81ff">3</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] x, y, z;  <span style="color:#75715e">// 4-bit wire vectors
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">always_comb</span> <span style="color:#66d9ef">begin</span>
</span></span><span style="display:flex;"><span>    {x,y,z} <span style="color:#f92672">=</span> a;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span></code></pre></div><p>Rather than specify an end bit, you can specify a width with <code>-</code> and <code>+</code>.</p>
<p>These three assignments all select the same four bits:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#66d9ef">wire</span> [<span style="color:#ae81ff">11</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] a;       <span style="color:#75715e">// 12-bit wire vector
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">wire</span> [<span style="color:#ae81ff">3</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] x, y, z;  <span style="color:#75715e">// 4-bit wire vectors
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">always_comb</span> <span style="color:#66d9ef">begin</span>
</span></span><span style="display:flex;"><span>    x <span style="color:#f92672">=</span> a[<span style="color:#ae81ff">11</span><span style="color:#f92672">:</span><span style="color:#ae81ff">8</span>];   <span style="color:#75715e">// 11:8
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    y <span style="color:#f92672">=</span> a[<span style="color:#ae81ff">11</span><span style="color:#f92672">-:</span><span style="color:#ae81ff">4</span>];  <span style="color:#75715e">// also 11:8
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    z <span style="color:#f92672">=</span> a[<span style="color:#ae81ff">8</span><span style="color:#f92672">+:</span><span style="color:#ae81ff">4</span>];   <span style="color:#75715e">// also 11:8
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">end</span>
</span></span></code></pre></div><p><em>ProTip: The start bit can be a variable, but not the width.</em></p>
<h3 id="configurable-widths">Configurable Widths</h3>
<p>Avoid hard-coding bit widths; it limits your design flexibility.</p>
<p>Parameters provide a simple way to configure bit widths:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#66d9ef">parameter</span> ADDRW<span style="color:#f92672">=</span><span style="color:#ae81ff">16</span>;  <span style="color:#75715e">// address width: 16 bits for 2^16 memory locations
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">logic</span> [ADDRW<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] addr_read;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">logic</span> [ADDRW<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] addr_write;
</span></span></code></pre></div><p>The width of a vector often depends on another parameter, so calculating it yourself isn&rsquo;t ideal.</p>
<p>Imagine you&rsquo;re creating a game engine where the number of sprites is configurable:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#66d9ef">parameter</span> SPR_CNT<span style="color:#f92672">=</span><span style="color:#ae81ff">10</span>;   <span style="color:#75715e">// maximum number of sprites on screen
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">logic</span> [<span style="color:#ae81ff">3</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] sprite_id;  <span style="color:#75715e">// 4 bits is correct for a count of 10, but if SPR_CNT changes?
</span></span></span></code></pre></div><p>If we hardcode the width, changing the sprite count will break the design.</p>
<p>Verilog 2005 introduced <code>$clog2</code> to handle this.</p>
<h3 id="calculating-widths">Calculating Widths</h3>
<p>The <code>$clog2</code> function returns the ceiling of the logarithm to base 2.</p>
<p>For example, <code>$clog2(10) = 4</code> because 2<sup>3</sup> &lt; 10 ≤ 2<sup>4</sup>.</p>
<p>If you need to handle N things (such as sprites or memory locations), then <code>$clog2(N)</code> will tell you how wide your vector needs to be:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#66d9ef">parameter</span> SPR_CNT<span style="color:#f92672">=</span><span style="color:#ae81ff">10</span>;  <span style="color:#75715e">// maximum number of sprites on screen
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">parameter</span> SPR_BITW<span style="color:#f92672">=</span>$clog2(SPR_CNT);  <span style="color:#75715e">// sprite ID bit width
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">logic</span> [SPR_BITW<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] sprite_id;  <span style="color:#75715e">// sprite identifier
</span></span></span></code></pre></div><p><code>$clog2</code> is handy, but you need to be careful.</p>
<p>If you&rsquo;re specifying a maximum value (rather than a count), it doesn&rsquo;t do what you want:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#66d9ef">parameter</span> MAX_VOLTAGE<span style="color:#f92672">=</span><span style="color:#ae81ff">256</span>;  <span style="color:#75715e">// maximum voltage
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">parameter</span> VOLTW<span style="color:#f92672">=</span>$clog2(MAX_VOLTAGE);  <span style="color:#75715e">// voltage bit width (INCORRECT!)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">logic</span> [VOLTW<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] volatage;  <span style="color:#75715e">// we can&#39;t handle 256!
</span></span></span></code></pre></div><p><code>$clog2</code> returns &lsquo;8&rsquo;, giving a voltage range of 0-255 inclusive. 256 is out of range.</p>
<p>If you&rsquo;re specifying a maximum value, you need to add one to the value passed to <code>$clog2</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#66d9ef">parameter</span> MAX_VOLTAGE<span style="color:#f92672">=</span><span style="color:#ae81ff">256</span>;  <span style="color:#75715e">// maximum voltage
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">parameter</span> VOLTW<span style="color:#f92672">=</span>$clog2(MAX_VOLTAGE<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);  <span style="color:#75715e">// voltage bit width (add one for max)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">logic</span> [VOLTW<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] volatage;  <span style="color:#75715e">// we can now handle 256 volts :)
</span></span></span></code></pre></div><p>This problem is often hidden because it doesn&rsquo;t occur if your parameter isn&rsquo;t a power of 2. For example, if you specify &lsquo;240&rsquo; as your <code>MAX_VOLTAGE</code>, you won&rsquo;t see any issues. Later, you increase <code>MAX_VOLTAGE</code> to &lsquo;256&rsquo;, and the design has a subtle bug.</p>
<h2 id="literals">Literals</h2>
<p>Verilog gives you several options for representing literal numbers. You can use binary, decimal, octal, or hexadecimal literals and specify their width in bits.</p>
<p>I think this is easiest to understand with some examples:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#75715e">// unsigned 4-bit wide, decimal value 9
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">4</span><span style="color:#ae81ff">&#39;b1001</span>             <span style="color:#75715e">// binary literal
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">4</span><span style="color:#ae81ff">&#39;d9</span>                <span style="color:#75715e">// decimal literal
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">4&#39;h9</span>                <span style="color:#75715e">// hexadecimal literal
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">4</span><span style="color:#ae81ff">&#39;o11</span>               <span style="color:#75715e">// octal literal
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// unsigned 12-bit wide, decimal value 1024
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">12</span><span style="color:#ae81ff">&#39;b0100</span>_0000_0000  <span style="color:#75715e">// binary literal (underscores for readability)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">12</span><span style="color:#ae81ff">&#39;d1024</span>            <span style="color:#75715e">// decimal literal
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">12&#39;h400</span>             <span style="color:#75715e">// hex literal
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">12</span><span style="color:#ae81ff">&#39;o2000</span>            <span style="color:#75715e">// octal literal
</span></span></span></code></pre></div><p>It&rsquo;s good practice to include the width and base for any literal, but they are optional.</p>
<ul>
<li>If the width is omitted, it defaults to 32-bits</li>
<li>If the base is omitted, it defaults to decimal (base 10)</li>
</ul>
<p>Here are some examples:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#75715e">// 32-bit wide
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">&#39;b1001</span>  <span style="color:#75715e">// unsigned binary literal
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">&#39;d9</span>     <span style="color:#75715e">// unsigned decimal literal
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">9</span>       <span style="color:#75715e">// signed decimal literal
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">1024</span>    <span style="color:#75715e">// signed decimal literal
</span></span></span></code></pre></div><p>NB. If you omit the base, the literal is signed! This isn&rsquo;t a problem most of the time, but it can lead to subtle bugs. We&rsquo;ll cover signed numbers in the next section.</p>
<h3 id="literal-tricks">Literal Tricks</h3>
<p>In SystemVerilog, you can set all the bits of a vector to &lsquo;1&rsquo;:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#75715e">// x and y have the same value:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">reg</span> [<span style="color:#ae81ff">11</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] x <span style="color:#f92672">=</span> <span style="color:#ae81ff">&#39;1</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">reg</span> [<span style="color:#ae81ff">11</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] y <span style="color:#f92672">=</span> <span style="color:#ae81ff">12</span><span style="color:#ae81ff">&#39;b1111</span>_1111_1111;
</span></span></code></pre></div><p>You can also use the concat operator <code>{}</code> to set specific patterns:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#66d9ef">localparam</span> CORDW <span style="color:#f92672">=</span> <span style="color:#ae81ff">12</span>;  <span style="color:#75715e">// coordinate width in bits
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">reg</span> [CORDW<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] x <span style="color:#f92672">=</span> {CORDW{<span style="color:#ae81ff">1</span><span style="color:#ae81ff">&#39;b1</span>}};  <span style="color:#75715e">// x = 1111_1111_1111
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">reg</span> [CORDW<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] y <span style="color:#f92672">=</span> { {<span style="color:#ae81ff">1</span><span style="color:#ae81ff">&#39;b1</span>}, {CORDW<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>{<span style="color:#ae81ff">1</span><span style="color:#ae81ff">&#39;b0</span>}} };  <span style="color:#75715e">// y = 1000_0000_0000
</span></span></span></code></pre></div><p>Concat allows us to set an appropriate value, however wide the vectors are.</p>
<h2 id="signed-numbers">Signed Numbers</h2>
<p>If your application requires negative values, you need to handle signed numbers. The standard approach is <strong>two&rsquo;s complement</strong>, as with most software development.</p>
<h3 id="the-twos-complement">The Two&rsquo;s Complement</h3>
<p>With two&rsquo;s complement, addition, subtraction, and multiplication all work as they do with positive binary numbers. But what is the two&rsquo;s complement? The positive and negative two&rsquo;s complement representations of an N-bit number add up to 2<sup>N</sup>.</p>
<p>For example, with four-bit values: 7 is <code>0111</code> and -7 is <code>1001</code>, because <code>0111 + 1001 = 10000</code> (2<sup>4</sup>).</p>
<p>The usual way to switch the sign of a two&rsquo;s complement number is to invert the bits and add one:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plaintext" data-lang="plaintext"><span style="display:flex;"><span>Start:  0111    (decimal +7)
</span></span><span style="display:flex;"><span>Invert: 1000
</span></span><span style="display:flex;"><span>Add 1:  0001
</span></span><span style="display:flex;"><span>Result: 1001    (decimal -7)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Start:  1001    (decimal -7)
</span></span><span style="display:flex;"><span>Invert: 0110
</span></span><span style="display:flex;"><span>Add 1:  0001
</span></span><span style="display:flex;"><span>Result: 0111    (decimal +7)
</span></span></code></pre></div><p>You rarely need to determine the two&rsquo;s complement yourself; Verilog can handle it for you.</p>
<p>Let&rsquo;s look at a few simple additions to confirm things work as expected:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plaintext" data-lang="plaintext"><span style="display:flex;"><span>  0110      +6
</span></span><span style="display:flex;"><span>+ 1101      -3
</span></span><span style="display:flex;"><span>= 0011      +3
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  1001      -7
</span></span><span style="display:flex;"><span>+ 0011      +3
</span></span><span style="display:flex;"><span>= 1100      -4
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  1001      -7
</span></span><span style="display:flex;"><span>+ 0111      +7
</span></span><span style="display:flex;"><span>= 0000       0
</span></span></code></pre></div><p>The most significant bit of a signed vector is always <code>1</code> for a negative number, so it&rsquo;s easy to determine if a value is negative: we get the main benefit of a sign bit without the downsides.</p>
<p>To learn more, check out the Wikipedia article on <a href="https://en.wikipedia.org/wiki/Two's_complement">two&rsquo;s complement</a>.</p>
<h3 id="signing-your-signals">Signing Your Signals</h3>
<p>Telling Verilog that your vector is signed is easy:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#66d9ef">reg</span>        [<span style="color:#ae81ff">7</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] u;  <span style="color:#75715e">// unsigned (0..255)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">reg</span> <span style="color:#66d9ef">signed</span> [<span style="color:#ae81ff">7</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] s;  <span style="color:#75715e">// signed   (-128..127)
</span></span></span></code></pre></div><p>For literals, you can add the <code>s</code> prefix to the base:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#66d9ef">reg</span> <span style="color:#66d9ef">signed</span> [<span style="color:#ae81ff">7</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] x <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">8</span>&#39;sd55;  <span style="color:#75715e">// x position: -55 (signed)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">reg</span> <span style="color:#66d9ef">signed</span> [<span style="color:#ae81ff">7</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] y <span style="color:#f92672">=</span>  <span style="color:#ae81ff">8</span>&#39;sd32;  <span style="color:#75715e">// y position: +32 (signed)
</span></span></span></code></pre></div><h3 id="beware-signed-logic">Beware Signed Logic!</h3>
<p>Verilog has a nasty habit of treating something as unsigned unless all variables in an expression are signed. But you can use the <code>$signed</code> operator to force a variable to be signed if required.</p>
<p>So, if you take one thing away from this post:</p>
<p><strong>Never mix and match signed and unsigned variables!</strong></p>
<p>The following testbench shows what can happen when you mix signed and unsigned variables:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#66d9ef">module</span> signed_tb ();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">logic</span> [<span style="color:#ae81ff">7</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] x, y;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">logic</span> <span style="color:#66d9ef">signed</span> [<span style="color:#ae81ff">7</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] x1, y1;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">logic</span> <span style="color:#66d9ef">signed</span> [<span style="color:#ae81ff">3</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] offset;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">always_comb</span> <span style="color:#66d9ef">begin</span>
</span></span><span style="display:flex;"><span>        x1 <span style="color:#f92672">=</span> x <span style="color:#f92672">+</span> offset;  <span style="color:#75715e">// AVOID! This probably won&#39;t work as expected!
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        y1 <span style="color:#f92672">=</span> $signed(y) <span style="color:#f92672">+</span> offset;  <span style="color:#75715e">// ensure y is treated as signed
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">initial</span> <span style="color:#66d9ef">begin</span>
</span></span><span style="display:flex;"><span>        #<span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span>        $display(<span style="color:#e6db74">&#34;Coordinates (7,7):&#34;</span>);
</span></span><span style="display:flex;"><span>        x <span style="color:#f92672">=</span> <span style="color:#ae81ff">8</span><span style="color:#ae81ff">&#39;d7</span>;
</span></span><span style="display:flex;"><span>        y <span style="color:#f92672">=</span> <span style="color:#ae81ff">8</span><span style="color:#ae81ff">&#39;d7</span>;
</span></span><span style="display:flex;"><span>        #<span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span>        $display(<span style="color:#e6db74">&#34;x : %b  %d&#34;</span>, x, x);
</span></span><span style="display:flex;"><span>        $display(<span style="color:#e6db74">&#34;y : %b  %d&#34;</span>, y, y);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        #<span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span>        $display(<span style="color:#e6db74">&#34;With offset +4:&#34;</span>);
</span></span><span style="display:flex;"><span>        offset <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>&#39;sd4;
</span></span><span style="display:flex;"><span>        #<span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span>        $display(<span style="color:#e6db74">&#34;x1: %b  %d&#34;</span>, x1, x1);
</span></span><span style="display:flex;"><span>        $display(<span style="color:#e6db74">&#34;y1: %b  %d&#34;</span>, y1, y1);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        #<span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span>        $display(<span style="color:#e6db74">&#34;With offset -4:&#34;</span>);
</span></span><span style="display:flex;"><span>        offset <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">4</span>&#39;sd4;
</span></span><span style="display:flex;"><span>        #<span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span>        $display(<span style="color:#e6db74">&#34;x1: %b  %d  *SURPRISE*&#34;</span>, x1, x1);
</span></span><span style="display:flex;"><span>        $display(<span style="color:#e6db74">&#34;y1: %b  %d&#34;</span>, y1, y1);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">endmodule</span>
</span></span></code></pre></div><p>Running this test bench gives the following output in Vivado:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plaintext" data-lang="plaintext"><span style="display:flex;"><span>Coordinates (7,7):
</span></span><span style="display:flex;"><span>x : 00000111    7
</span></span><span style="display:flex;"><span>y : 00000111    7
</span></span><span style="display:flex;"><span>With offset +4:
</span></span><span style="display:flex;"><span>x1: 00001011    11
</span></span><span style="display:flex;"><span>y1: 00001011    11
</span></span><span style="display:flex;"><span>With offset -4:
</span></span><span style="display:flex;"><span>x1: 00010011    19  *SURPRISE*
</span></span><span style="display:flex;"><span>y1: 00000011     3
</span></span></code></pre></div><h2 id="big-endian-little-endian">Big-Endian, Little-Endian</h2>
<p>Earlier, we said a vector was declared like this: <code>type [upper:lower] name;</code></p>
<p>A more general definition is: <code>type [msb_index:lsb_index] name;</code><br>
Where <em>msb_index</em> is the most significant bit index and <em>lsb_index</em> is the least.</p>
<p>The usual way of declaring vectors has the least significant bit at the lowest index. These are <strong>little-endian</strong> (LE) vectors:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#66d9ef">wire</span>   [<span style="color:#ae81ff">5</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] a;  <span style="color:#75715e">// 6-bit wire (little-endian)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">reg</span>   [<span style="color:#ae81ff">11</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] b;  <span style="color:#75715e">// 12-bit reg (little-endian)
</span></span></span></code></pre></div><p>Alternatively, we can declare vectors like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#66d9ef">wire</span>   [<span style="color:#ae81ff">0</span><span style="color:#f92672">:</span><span style="color:#ae81ff">5</span>] a;  <span style="color:#75715e">// 6-bit wire (big-endian)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">reg</span>   [<span style="color:#ae81ff">0</span><span style="color:#f92672">:</span><span style="color:#ae81ff">11</span>] b;  <span style="color:#75715e">// 12-bit reg (big-endian)
</span></span></span></code></pre></div><p>These vectors have the most significant bit at the lowest index; they&rsquo;re <strong>big-endian</strong> (BE) vectors.</p>
<p>Either will work, but the convention is to use little-endian unless you need to interface with big-endian hardware. For example, I<sup>2</sup>C uses big-endian bit order.</p>
<h3 id="switching-ends">Switching Ends</h3>
<p>Say you&rsquo;ve got a bit-endian byte from I<sup>2</sup>C and want to convert it to little-endian. Alas, you can&rsquo;t mix big and little-endian vectors, so the following won&rsquo;t work (in most tools):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#66d9ef">wire</span> [<span style="color:#ae81ff">0</span><span style="color:#f92672">:</span><span style="color:#ae81ff">7</span>] i2c_byte;  <span style="color:#75715e">// 8-bit wire (big-endian)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">reg</span>  [<span style="color:#ae81ff">7</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] le_byte;   <span style="color:#75715e">// 8-bit reg (little-endian)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">always_ff</span> @(<span style="color:#66d9ef">posedge</span> clk) le_byte <span style="color:#f92672">&lt;=</span> i2c_byte;  <span style="color:#75715e">// Won&#39;t work :(
</span></span></span></code></pre></div><p>Instead you need to reverse the bits explicitly. All bits are swapped in parallel:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#66d9ef">always_ff</span> @(<span style="color:#66d9ef">posedge</span> clk) <span style="color:#66d9ef">begin</span>
</span></span><span style="display:flex;"><span>    le_byte[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&lt;=</span> i2c_byte[<span style="color:#ae81ff">7</span>];
</span></span><span style="display:flex;"><span>    le_byte[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">&lt;=</span> i2c_byte[<span style="color:#ae81ff">6</span>];
</span></span><span style="display:flex;"><span>    le_byte[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">&lt;=</span> i2c_byte[<span style="color:#ae81ff">5</span>];
</span></span><span style="display:flex;"><span>    le_byte[<span style="color:#ae81ff">3</span>] <span style="color:#f92672">&lt;=</span> i2c_byte[<span style="color:#ae81ff">4</span>];
</span></span><span style="display:flex;"><span>    le_byte[<span style="color:#ae81ff">4</span>] <span style="color:#f92672">&lt;=</span> i2c_byte[<span style="color:#ae81ff">3</span>];
</span></span><span style="display:flex;"><span>    le_byte[<span style="color:#ae81ff">5</span>] <span style="color:#f92672">&lt;=</span> i2c_byte[<span style="color:#ae81ff">2</span>];
</span></span><span style="display:flex;"><span>    le_byte[<span style="color:#ae81ff">6</span>] <span style="color:#f92672">&lt;=</span> i2c_byte[<span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>    le_byte[<span style="color:#ae81ff">7</span>] <span style="color:#f92672">&lt;=</span> i2c_byte[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span></code></pre></div><p>Updating each individual bit is tedious, but a <code>for</code> loop can handle this for us:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#66d9ef">always_ff</span> @(<span style="color:#66d9ef">posedge</span> clk) <span style="color:#66d9ef">begin</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">8</span>; i<span style="color:#f92672">=</span>i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>) le_byte[i] <span style="color:#f92672">&lt;=</span> i2c_byte[<span style="color:#ae81ff">7</span><span style="color:#f92672">-</span>i];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span></code></pre></div><p>Verilog <code>for</code> is NOT like a software loop: this <code>for</code> loop is unrolled into parallel bit swaps.</p>
<h3 id="byte-endian">Byte Endian</h3>
<p>So far, we&rsquo;ve been talking about endianness at the bit level, but it most commonly occurs in the context of bytes. If you have a 32-bit word, do you store the least significant byte at the lowest address (little-endian) or the most significant byte at the lowest address (big-endian)?</p>
<p>RISC-V, x86, and ARM are little-endian, while Internet protocols (TCP/IP) and Motorola 68K are big-endian. This isn&rsquo;t particularly relevant to what we&rsquo;re looking at, so I won&rsquo;t go into this further. If you&rsquo;re interested in learning more, check out <a href="https://en.wikipedia.org/wiki/Endianness">Endianness</a> on Wikipedia.</p>
<h2 id="reckoning-with-arithmetic">Reckoning with Arithmetic</h2>
<p>We&rsquo;ve talked a lot about the representation of numbers, but we&rsquo;ve not done any maths.</p>
<p>Modern FPGAs include logic to handle addition and subtraction: there&rsquo;s no need to roll your own. If you want to create an adder from scratch, there are plenty of university slide decks online. Unless you&rsquo;re working with massive vectors, you&rsquo;re unlikely to encounter problems with addition or subtraction. The usual advice to register your values between calculation steps applies, especially to subtraction on simpler FPGAs.</p>
<p>Multiplication is more complex, but FPGAs can handle it with dedicated DSP blocks. We&rsquo;ll be covering multiplication in the next part of this series: <a href="/posts/multiplication-fpga-dsps">Multiplication with FPGA DSPs</a>.</p>
<p>What about division? I&rsquo;ve got some bad news for you: Verilog won&rsquo;t do this for you. We&rsquo;ll look into division in detail in a later post, but for now, you can use the <a href="/posts/division-in-verilog/">division</a> design from the Project F cookbook.</p>
<h2 id="next-time">Next Time</h2>
<p>In the second part of this series, we look at <a href="/posts/multiplication-fpga-dsps">Multiplication with FPGA DSPs</a>.</p>
<p>You can also check out our other maths posts: <a href="/posts/division-in-verilog/">division</a>, <a href="/posts/square-root-in-verilog/">square root</a>, and <a href="/posts/fpga-sine-table/">sine &amp; cosine</a>.</p>
<p><em>Get in touch: <a href="https://github.com/projf/projf-explore/issues">GitHub Issues</a>, <a href="https://1bitsquared.com/pages/chat">1BitSquared Discord</a>, <a href="https://mastodon.social/@WillFlux">@WillFlux</a> (Mastodon), <a href="https://twitter.com/WillFlux">@WillFlux</a> (Twitter)</em></p>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>Unpacked BCD uses a whole byte (8-bits) for each decimal digit.&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>

      
    </div>
    
  </div>
</section>

    <script src="/js/copycode.js"></script>



<section class="section">
  <div class="container has-text-centered">
    <p>©2022 Will Green, Project F</p>
    
  </div>
</section>


<script src="https://badgers.projectf.io/script.js" data-site="EVCGKVDN" defer></script>



</body>
</html>

