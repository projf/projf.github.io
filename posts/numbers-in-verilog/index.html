<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"  lang="en-gb">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<title>Numbers in Verilog | Project F: FPGA Dev</title>

<meta property='og:title' content='Numbers in Verilog - Project F: FPGA Dev'>
<meta property='og:description' content='Welcome to my ongoing series covering mathematics and algorithms with FPGAs. This series begins with the basics of Verilog numbers, then considers fixed-point, division, square roots and CORDIC before covering more complex algorithms, such as data compression. This post was last updated in February 2022.
In this first post, we consider integers, dig into the challenges of signed numbers and expressions, and then finish with a bit of arithmetic.
This post was completely revised in November 2022.'>
<meta property='og:url' content='https://projectf.io/posts/numbers-in-verilog/'>
<meta property='og:site_name' content='Project F: FPGA Dev'>
<meta property='og:type' content='article'><meta property='og:image' content='https://projectf.io/img/posts/numbers-in-verilog/social-card.png'><meta property='article:published_time' content='2021-09-30T00:00:00Z'><meta property='article:modified_time' content='2023-02-02T00:00:00Z'><meta name='twitter:card' content='summary_large_image'><meta name='twitter:site' content='@WillFlux'><meta name='twitter:creator' content='@WillFlux'>


<link href="https://projectf.io/index.xml" rel="alternate" type="application/rss+xml" title="Project F: FPGA Dev">

<link rel="stylesheet" href="/css/style.css"><link rel='stylesheet' href='https://projectf.io/css/custom.css'>

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
<link rel="canonical" href="https://projectf.io/posts/numbers-in-verilog/">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff">
</head>
<body>

<section class="section">
  <div class="container">
    <nav id="nav-main" class="nav">
      <div id="nav-name" class="nav-left">
        <a id="nav-anchor" class="nav-item" href="https://projectf.io">
          <h1 id="nav-heading" class="title is-4">Project F: FPGA Dev</h1>
        </a>
      </div>
      <div class="nav-right">
        <nav id="nav-items" class="nav-item level is-mobile"><a class="level-item" aria-label="github" href='https://github.com/projf/projf-explore'
            target='_blank' rel='me noopener'>
            <span class="icon">
              <i class><svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
    
    <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"/>
    
  </svg>
</i>
            </span>
          </a><a class="level-item" aria-label="mastodon" href='https://mastodon.social/@WillFlux'
            target='_blank' rel='me noopener'>
            <span class="icon">
              <i class><svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
    
    <path d="M 11.966876,0.80329086 C 9.1123466,0.82665791 6.3664935,1.1367094 4.7662978,1.8737549 c 0,0 -3.1736685,1.4237835 -3.1736685,6.2815982 0,1.1123884 -0.021554,2.4424309 0.013571,3.8529439 0.1152443,4.750677 0.8683725,9.432704 5.2479219,10.595273 2.0193066,0.53604 3.7531218,0.648348 5.1494078,0.571373 2.532141,-0.140797 3.953603,-0.906282 3.953603,-0.906282 l -0.08353,-1.842608 c 0,0 -1.809527,0.572181 -3.841713,0.50245 -2.013417,-0.06922 -4.138986,-0.217713 -4.4646269,-2.696937 -0.030082,-0.217772 -0.045075,-0.450712 -0.045075,-0.695267 0,0 1.9765387,0.484554 4.4813709,0.599656 1.531629,0.07049 2.9679,-0.08996 4.426746,-0.264563 2.797636,-0.335045 5.233581,-2.063856 5.539741,-3.643517 0.482392,-2.488386 0.442651,-6.0725219 0.442651,-6.0725219 0,-4.8578147 -3.173492,-6.2815982 -3.173492,-6.2815982 C 17.639136,1.1367094 14.891579,0.82669685 12.03704,0.80329086 Z"/>
  <path d="M 6.4286668,14.016701 V 9.1034254 c 0,-1.0041614 0.2549569,-1.8022059 0.7670342,-2.3925638 0.5280486,-0.590366 1.2196579,-0.8929946 2.0781049,-0.8929946 0.9931961,0 1.7452181,0.3828583 2.2425191,1.1486808 L 11.999859,7.7793695 12,11.451148 11.999859,7.7793695 12.483392,6.9665478 C 12.980596,6.2007253 13.732618,5.817867 14.72592,5.817867 c 0.858341,0 1.549951,0.3026286 2.078097,0.8929946 0.511971,0.5903579 0.766887,1.3884024 0.766887,2.3925638 v 4.9132756" />
    
  </svg>
</i>
            </span>
          </a><a class="level-item" aria-label="youtube" href='https://youtube.com/@projf'
            target='_blank' rel='me noopener'>
            <span class="icon">
              <i class><svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
    
    <path d="M22.54 6.42a2.78 2.78 0 0 0-1.94-2C18.88 4 12 4 12 4s-6.88 0-8.6.46a2.78 2.78 0 0 0-1.94 2A29 29 0 0 0 1 11.75a29 29 0 0 0 .46 5.33A2.78 2.78 0 0 0 3.4 19c1.72.46 8.6.46 8.6.46s6.88 0 8.6-.46a2.78 2.78 0 0 0 1.94-2 29 29 0 0 0 .46-5.25 29 29 0 0 0-.46-5.33z"/>
    <polygon points="9.75 15.02 15.5 11.75 9.75 8.48 9.75 15.02"/>
    
  </svg>
</i>
            </span>
          </a><a class="level-item" aria-label="rss" href='/index.xml'
            target='_blank' rel='me noopener'>
            <span class="icon">
              <i class><svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
    
    <path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle>
    
  </svg>
</i>
            </span>
          </a></nav>
      </div>
    </nav>

    <nav class="nav">
      
      <div class="nav-left"><a class="nav-item" href="/about">
          <h2 class="title is-5">About</h2>
        </a><a class="nav-item" href="/demos">
          <h2 class="title is-5">Demos</h2>
        </a><a class="nav-item" href="/howto">
          <h2 class="title is-5">How To</h2>
        </a><a class="nav-item" href="/tags/news">
          <h2 class="title is-5">News</h2>
        </a><a class="nav-item" href="/tutorials">
          <h2 class="title is-5">Tutorials</h2>
        </a><a class="nav-item" href="/verilog-lib">
          <h2 class="title is-5">Verilog Lib</h2>
        </a></div>
      

      
    </nav>

  </div>
  <script src="/js/navicon-shift.js"></script>
</section>

<section class="section">
  <div class="container">
    <div class="subtitle tags is-6 is-pulled-right">
      
      
<a class="subtitle is-6" href="/tags/maths/">#maths</a>




      
    </div>
    <h2 class="subtitle is-6">30 September 2021</h2>
    <h1 class="title">Numbers in Verilog</h1>
    
    <div class="content">
      <p>Welcome to my ongoing series covering mathematics and algorithms with FPGAs. This series begins with the basics of Verilog numbers, then considers fixed-point, division, square roots and CORDIC before covering more complex algorithms, such as data compression. This post was last updated in February 2022.</p>
<p>In this first post, we consider integers, dig into the challenges of signed numbers and expressions, and then finish with a bit of arithmetic.</p>
<p><strong>This post was completely revised in November 2022.</strong></p>
<p><em>Get in touch with <a href="https://mastodon.social/@WillFlux">@WillFlux</a> or join me on <a href="https://github.com/projf/projf-explore/discussions">GitHub Discussions</a> and <a href="https://discord.gg/cf869yDbXf">1BitSquared Discord</a>.</em></p>
<h3 id="series-outline">Series Outline</h3>
<ul>
<li>Numbers in Verilog (this post) - introduction to numbers in Verilog</li>
<li><a href="/posts/verilog-vectors-arrays">Vectors and Arrays</a> - working with Verilog vectors and arrays</li>
<li><a href="/posts/multiplication-fpga-dsps">Multiplication with DSPs</a> - efficient FPGA multiplication</li>
<li><a href="/posts/fixed-point-numbers-in-verilog/">Fixed-Point Numbers</a> - precision without complexity</li>
<li><a href="/posts/division-in-verilog">Division in Verilog</a> - divided we stand</li>
<li><em>More maths throughout 2023</em></li>
</ul>
<blockquote>
<p><strong>Sponsor My Work</strong><br>
If you like what I do, consider <a href="https://github.com/sponsors/WillGreen">sponsoring me</a> on GitHub.<br>
I love FPGAs and want to help more people discover and use them in their projects.<br>
My hardware designs are open source, and my blog is advert free.</p>
</blockquote>
<h2 id="representing-numbers">Representing Numbers</h2>
<p>We&rsquo;re so familiar with different representations of numbers we hardly give them a second thought.</p>
<p>Some representations of forty-two:</p>
<ul>
<li><code>101010</code> (binary)</li>
<li><code>52</code> (octal)</li>
<li><code>42</code> (decimal)</li>
<li><code>0x2A</code> (hexadecimal)</li>
<li><code>4.2x10</code><sup><code>1</code></sup> (scientific notation)</li>
<li><code>XLII</code> (Roman numerals)</li>
<li><code>四二</code> (Japanese numerals)</li>
<li><code>zweiundvierzig</code> (German)</li>
</ul>
<p>Different representations express (almost) the same thing but work better (or worse) in different circumstances: hexadecimal is suitable for a memory address, while scientific notation compactly expresses vast and tiny numbers alike.</p>
<p>As a hardware designer, you need to consider how you represent numbers. How many bits do I need? Do I need signed numbers? Will BCD make my design simpler? Is fixed-point accurate enough? What happens when I mix different widths in one expression?</p>
<blockquote>
<p><strong>Cistercian Numerals</strong><br>
For something a bit less ordinary, try <a href="https://en.wikipedia.org/wiki/Cistercian_numerals">Cistercian numerals</a> (Wikipedia).</p>
</blockquote>
<h2 id="binary">Binary</h2>
<p>Computers famously &ldquo;think&rdquo; in binary, and the same is true for most electronics. Off and on, high and low. Simple, right?</p>
<p>For positive integers, things are pretty straightforward.</p>
<p>Let&rsquo;s take a look at 42 in binary: <strong>101010<sub>2</sub></strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plaintext" data-lang="plaintext"><span style="display:flex;"><span>32   16    8    4    2    1
</span></span><span style="display:flex;"><span> ^    ^    ^    ^    ^    ^
</span></span><span style="display:flex;"><span> 1    0    1    0    1    0
</span></span></code></pre></div><p>Each binary digit is twice the previous one: 1, 2, 4, 8, 16, 32&hellip;</p>
<p><code>32 + 8 + 2 = 42</code></p>
<p>Forty-two requires at least six binary digits to represent in this way.</p>
<h3 id="binary-coded-decimal">Binary Coded Decimal</h3>
<p>But there are other possible representations: some systems use <strong>binary coded decimal</strong> (BCD). Packed<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup> BCD uses a nibble (4-bit) value to represent each decimal digit.</p>
<p>To get the packed BCD representation, convert each decimal digit into a 4-bit binary value:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plaintext" data-lang="plaintext"><span style="display:flex;"><span>Decimal          4    2
</span></span><span style="display:flex;"><span>BCD           0100 0010
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Decimal     1    0    1
</span></span><span style="display:flex;"><span>BCD      0001 0000 0001
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Decimal     9    8    7
</span></span><span style="display:flex;"><span>BCD      1001 1000 0111
</span></span></code></pre></div><p>The BCD representation requires eight bits to represent 42, two more than the plain old binary version. However, there are advantages, including the ease of display (each nibble is one character) and the ability to accurately represent decimal numbers (such as 10.1).</p>
<p>On typical binary computers, BCD adds overhead for arithmetic operations. However, when designing your own hardware, you can support BCD directly in logic, making it an attractive option for straightforward numerical designs.</p>
<p>Wikipedia&rsquo;s <a href="https://en.wikipedia.org/wiki/Binary-coded_decimal">binary-coded decimal</a> article covers different BCD variants and sign encoding.</p>
<p>Interesting as BCD is, we&rsquo;ll be sticking with plain old binary for the rest of this document. Many of the concepts we&rsquo;ll cover also apply to BCD.</p>
<h2 id="binary-in-verilog">Binary in Verilog</h2>
<p>By default, a Verilog reg or wire is 1 bit wide. This is a <strong>scalar</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#66d9ef">wire</span>  x;  <span style="color:#75715e">// 1 bit wire
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">reg</span>   y;  <span style="color:#75715e">// also 1 bit
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">logic</span> z;  <span style="color:#75715e">// me too!
</span></span></span></code></pre></div><p>A scalar can only hold 0 or 1 (but see <em>Four State Data Types</em> below).</p>
<p>We need a <strong>vector</strong> to hold values other than 0 and 1.</p>
<p>A vector is declared like this: <code>type [upper:lower] name;</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#66d9ef">wire</span>   [<span style="color:#ae81ff">5</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] a;  <span style="color:#75715e">// 6-bit wire
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">reg</span>    [<span style="color:#ae81ff">7</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] b;  <span style="color:#75715e">// 8-bit reg
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">logic</span> [<span style="color:#ae81ff">11</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] c;  <span style="color:#75715e">// 12-bit logic
</span></span></span></code></pre></div><p><code>a</code>, <code>b</code>, and <code>c</code> are vectors:</p>
<ul>
<li>Wire <strong>a</strong> handles 0-63 inclusive (2<sup>6</sup> is 64).</li>
<li>Reg <strong>b</strong> handles 0-255 inclusive (2<sup>8</sup> is 256).</li>
<li>Logic <strong>c</strong> handles 0-4095 inclusive (2<sup>12</sup> is 4096).</li>
</ul>
<p>You need to ensure your vector is large enough to handle the full range of values your design requires. Synthesis tools are good at discarding unused bits, so it&rsquo;s better to err on the side of too large rather than too small.</p>
<p>Deciding on the appropriate vector width for an algorithm requires an understanding of that algorithm. For example, I&rsquo;ve worked with an ellipse drawing algorithm that required 48-bit internal vectors when using 16-bit coordinates.</p>
<p>It&rsquo;s easy to miss the width from a signal declaration and create a scalar by mistake:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#66d9ef">wire</span> [<span style="color:#ae81ff">11</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] x;  <span style="color:#75715e">// 12 bit (vector)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">wire</span> x1;        <span style="color:#75715e">// 1 bit (scalar)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">always_comb</span> x1 <span style="color:#f92672">=</span> x;  <span style="color:#75715e">// discards 11 bits!
</span></span></span></code></pre></div><p>Alas, many tools provide no warning on width mismatches. To catch issues with bit widths, I strongly recommend you <a href="/posts/verilog-lint-with-verilator/">lint your designs with Verilator</a>.</p>
<blockquote>
<p><strong>Four State Data Types</strong><br>
The logic, reg, and wire data types can take one of four values: <code>0, 1, X, Z</code>, where <code>X</code> is unknown, and <code>Z</code> is high impedance. For this introduction to numbers, we&rsquo;re going to ignore <code>X</code> and <code>Z</code>.</p>
</blockquote>
<p>We cover vectors in detail in the next part of the series: <a href="/posts/verilog-vectors-arrays">Vectors and Arrays</a>.</p>
<h2 id="literals">Literals</h2>
<p>Verilog has several options for interpreting literal numbers.</p>
<p>A lone unadorned number, such as <code>42</code> is interpreted as a <strong>signed 32-bit decimal</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#75715e">// signed 32-bit decimal literals
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">42</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">123</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">7</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">65536</span>
</span></span></code></pre></div><p>The default interpretation seems reasonable, but sometimes it&rsquo;s easier to work in another base, and Verilog gives you the option of binary, octal and hexadecimal as well as decimal.</p>
<p>You specify the base (radix) using a single quote followed by a letter:</p>
<ul>
<li><strong>b</strong> - binary</li>
<li><strong>o</strong> - octal</li>
<li><strong>d</strong> - decimal</li>
<li><strong>h</strong> - hexadecimal</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#75715e">// 32-bit wide literals with decimal value 9
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">&#39;b1001</span>  <span style="color:#75715e">// unsigned binary
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">&#39;d9</span>     <span style="color:#75715e">// unsigned decimal
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">&#39;h9</span>     <span style="color:#75715e">// unsigned hexadecimal
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">&#39;o11</span>    <span style="color:#75715e">// unsigned octal
</span></span></span></code></pre></div><p>With hexadecimal, you can use the letters <code>a-f</code> and <code>A-F</code> as well as the usual digits:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#75715e">// 32-bit wide hexadecimal literals
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">&#39;hA</span>       <span style="color:#75715e">// unsigned 10 in decimal
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">&#39;h3C</span>      <span style="color:#75715e">// unsigned 60 in decimal
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">&#39;hfa</span>      <span style="color:#75715e">// unsigned 250 in decimal
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">&#39;hFFCC00</span>  <span style="color:#75715e">// bright yellow hexadecimal colour
</span></span></span></code></pre></div><p>Unlike the default decimal interpretation, these literals are <em>unsigned</em>, even with a decimal base.</p>
<p>If you want a signed literal with a base, you need to add an <strong>s</strong> before the base:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#75715e">// 32-bit wide with decimal value 9
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>&#39;sb1001  <span style="color:#75715e">// signed binary
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>&#39;sd9     <span style="color:#75715e">// signed decimal
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>&#39;sh9     <span style="color:#75715e">// signed hexadecimal
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>&#39;so11    <span style="color:#75715e">// signed octal
</span></span></span></code></pre></div><p>You can use a negative sign to create a negative literal. Stick with decimal for literals with minus signs: it quickly gets confusing in other bases.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#75715e">// signed 32-bit wide decimal literals
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">-</span><span style="color:#ae81ff">42</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">-</span><span style="color:#ae81ff">65536</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">-</span><span style="color:#ae81ff">25</span>_000_000  <span style="color:#75715e">// negative 25 million (underscores for readability)
</span></span></span></code></pre></div><p>We&rsquo;ll be covering signed numbers in detail in the next section.</p>
<p>You specify a literal width in bits by putting it before the single quote:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#75715e">// 12-bit wide with decimal value 1024
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">12</span><span style="color:#ae81ff">&#39;b0100</span>_0000_0000  <span style="color:#75715e">// unsigned binary literal (underscores for readability)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">12</span><span style="color:#ae81ff">&#39;d1024</span>            <span style="color:#75715e">// unsigned decimal literal
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">12</span>&#39;sh400            <span style="color:#75715e">// signed hex literal
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">12</span><span style="color:#ae81ff">&#39;o2000</span>            <span style="color:#75715e">// unsigned octal literal
</span></span></span></code></pre></div><p><em>ProTip: You can include underscores in your literals to improve readability.</em></p>
<h3 id="zero-fill">Zero Fill</h3>
<p>What happens if you only specify some of the bits in a literal?</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#ae81ff">8</span><span style="color:#ae81ff">&#39;b00001111</span>;  <span style="color:#75715e">// unsigned 00001111 (decimal 15)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">8</span><span style="color:#ae81ff">&#39;b1111</span>;      <span style="color:#75715e">// unsigned 00001111 (decimal 15)
</span></span></span></code></pre></div><p>Verilog filled the remaining bits of <code>8'b1111</code> with zero, which is what you might expect and is how numbers usually work day-to-day.</p>
<p>It doesn&rsquo;t matter if the literal is signed or another base; the value is always filled with zeros:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#ae81ff">8&#39;hA</span>;         <span style="color:#75715e">// unsigned 00001010 (decimal 10)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">8</span>&#39;sb1010;     <span style="color:#75715e">// signed   00001010 (decimal 10)
</span></span></span></code></pre></div><p>In case you&rsquo;re wondering about sign extension, fear not we come to that later in this post.</p>
<h3 id="literal-tricks">Literal Tricks</h3>
<p>In SystemVerilog, you can set all the bits of a vector to &lsquo;1&rsquo;:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#75715e">// x and y have the same value:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">reg</span> [<span style="color:#ae81ff">11</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] x <span style="color:#f92672">=</span> <span style="color:#ae81ff">&#39;1</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">reg</span> [<span style="color:#ae81ff">11</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] y <span style="color:#f92672">=</span> <span style="color:#ae81ff">12</span><span style="color:#ae81ff">&#39;b1111</span>_1111_1111;
</span></span></code></pre></div><p>You can also use the concat operator <code>{}</code> to set specific patterns in SystemVerilog <em>and</em> Verilog:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#66d9ef">localparam</span> CORDW <span style="color:#f92672">=</span> <span style="color:#ae81ff">12</span>;  <span style="color:#75715e">// coordinate width in bits
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">reg</span> [CORDW<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] x <span style="color:#f92672">=</span> {CORDW{<span style="color:#ae81ff">1</span><span style="color:#ae81ff">&#39;b1</span>}};  <span style="color:#75715e">// x = 1111_1111_1111
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">reg</span> [CORDW<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] y <span style="color:#f92672">=</span> { {<span style="color:#ae81ff">1</span><span style="color:#ae81ff">&#39;b1</span>}, {CORDW<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>{<span style="color:#ae81ff">1</span><span style="color:#ae81ff">&#39;b0</span>}} };  <span style="color:#75715e">// y = 1000_0000_0000
</span></span></span></code></pre></div><p>You can nest concat operators, as in the final example above.</p>
<p>Concat allows us to set an appropriate value regardless of the vector width.</p>
<h2 id="signed-numbers">Signed Numbers</h2>
<p>If your design requires negative values, you need to handle signed numbers. The standard approach is <strong>two&rsquo;s complement</strong>, as with almost all CPUs and software.</p>
<h3 id="the-twos-complement">The Two&rsquo;s Complement</h3>
<p>With two&rsquo;s complement, addition, subtraction, and multiplication all work as they do with positive binary numbers. But what is the two&rsquo;s complement? The positive and negative two&rsquo;s complement representations of an N-bit number add up to 2<sup>N</sup>.</p>
<p>For example, with four-bit values: 7 is <code>0111</code> and -7 is <code>1001</code> because <code>0111 + 1001 = 10000</code> (2<sup>4</sup>).</p>
<p>Discarding the extra bit, the result of adding a number and its two&rsquo;s complement is always zero.</p>
<p>You can switch the sign of a two&rsquo;s complement number by inverting the bits and adding one:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plaintext" data-lang="plaintext"><span style="display:flex;"><span>Start:      0111    (decimal +7)
</span></span><span style="display:flex;"><span>Invert:     1000
</span></span><span style="display:flex;"><span>Add 1:      0001
</span></span><span style="display:flex;"><span>Result:     1001    (decimal -7)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Start:      1001    (decimal -7)
</span></span><span style="display:flex;"><span>Invert:     0110
</span></span><span style="display:flex;"><span>Add 1:      0001
</span></span><span style="display:flex;"><span>Result:     0111    (decimal +7)
</span></span></code></pre></div><p>You rarely need to determine the two&rsquo;s complement; Verilog can handle it for you.</p>
<p>Let&rsquo;s look at a few additions to confirm things work as expected:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plaintext" data-lang="plaintext"><span style="display:flex;"><span>  0110      +6
</span></span><span style="display:flex;"><span>+ 1101      -3
</span></span><span style="display:flex;"><span>= 0011      +3
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  1001      -7
</span></span><span style="display:flex;"><span>+ 0011      +3
</span></span><span style="display:flex;"><span>= 1100      -4
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  1001      -7
</span></span><span style="display:flex;"><span>+ 0111      +7
</span></span><span style="display:flex;"><span>= 0000       0
</span></span></code></pre></div><p>To learn more, check out the Wikipedia article on <a href="https://en.wikipedia.org/wiki/Two's_complement">two&rsquo;s complement</a>.</p>
<h3 id="range">Range</h3>
<p>The range of a two&rsquo;s complement vector of width <strong>n</strong> is:</p>
<p><strong>-2<sup>(n-1)</sup> to +2<sup>(n-1)</sup>-1</strong></p>
<p>For example, an 8-bit signed vector has the range:</p>
<p><strong>-2<sup>7</sup> to +2<sup>7</sup>-1</strong> = <strong>-128 to +127</strong></p>
<p>You can&rsquo;t represent +128 with an 8-bit signed vector.</p>
<p>Try to take the two&rsquo;s complement of -128:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plaintext" data-lang="plaintext"><span style="display:flex;"><span>Start:      1000_0000   (decimal -128)
</span></span><span style="display:flex;"><span>Invert:     0111_1111
</span></span><span style="display:flex;"><span>Add 1:      0000_0001
</span></span><span style="display:flex;"><span>Result:     1000_0000   (decimal -128)
</span></span></code></pre></div><p>You get the original -128 back.</p>
<h3 id="signing-your-signals">Signing Your Signals</h3>
<p>Declaring a vector as signed is easy:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#66d9ef">reg</span>        [<span style="color:#ae81ff">7</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] u;  <span style="color:#75715e">// unsigned (0..255)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">reg</span> <span style="color:#66d9ef">signed</span> [<span style="color:#ae81ff">7</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] s;  <span style="color:#75715e">// signed   (-128..127)
</span></span></span></code></pre></div><p>For signed literals, as we discussed above, you add the <code>s</code> prefix to the base:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#66d9ef">reg</span> <span style="color:#66d9ef">signed</span> [<span style="color:#ae81ff">7</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] x <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">8</span>&#39;sd55;  <span style="color:#75715e">// x position: -55 (signed)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">reg</span> <span style="color:#66d9ef">signed</span> [<span style="color:#ae81ff">7</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] y <span style="color:#f92672">=</span>  <span style="color:#ae81ff">8</span>&#39;sd32;  <span style="color:#75715e">// y position: +32 (signed)
</span></span></span></code></pre></div><h3 id="test-negative">Test Negative</h3>
<p>It&rsquo;s straightforward to check the sign of a number with two&rsquo;s complement:</p>
<ul>
<li>For positive numbers (and zero), the most significant bit is <code>0</code></li>
<li>For negative numbers, the most significant bit is <code>1</code></li>
</ul>
<p>You can check the most significant bit directly:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#66d9ef">reg</span> <span style="color:#66d9ef">signed</span> [<span style="color:#ae81ff">7</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] s;  <span style="color:#75715e">// 8 bit signed vector
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">always_ff</span> @(<span style="color:#66d9ef">posedge</span> clk) <span style="color:#66d9ef">begin</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (s[<span style="color:#ae81ff">7</span>]) <span style="color:#66d9ef">begin</span>  <span style="color:#75715e">// ?! intent unclear
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// s is negative
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">end</span> <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">begin</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// s is positive or zero
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span></code></pre></div><p>However, comparison operators are usually clearer:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#66d9ef">reg</span> <span style="color:#66d9ef">signed</span> [<span style="color:#ae81ff">7</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] s;  <span style="color:#75715e">// 8 bit signed vector
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">always_ff</span> @(<span style="color:#66d9ef">posedge</span> clk) <span style="color:#66d9ef">begin</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (s <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">begin</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// s is negative
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">end</span> <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">begin</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// s is positive or zero
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span></code></pre></div><h2 id="signed-expressions">Signed Expressions</h2>
<p>Now we know how to handle signed vectors and literals, it&rsquo;s time to wrestle with expressions. I&rsquo;ve done my best to accurately distil a rather dry and complex subject into something palatable, so I hope I don&rsquo;t offend the language lawyers and bore everyone else.</p>
<p>An expression consists of <strong>operands</strong>, such as variables and literals, and <strong>operators</strong>, such as addition and assignment.</p>
<p><strong>Verilog uses the width of the widest operand when evaluating an expression.</strong></p>
<p>It doesn&rsquo;t matter what the operators are; all Verilog cares about is the width of the operands.</p>
<p>Narrower operands are widened until they&rsquo;re the same width as the widest. For unsigned operands, Verilog simply fills the new bits with zero, but with signed operands, it uses <strong>sign extension</strong>.</p>
<p>Sign extension copies the most significant bit (MSB) to fill the width. Remember, for a signed number, the MSB is <code>1</code> for negative numbers and <code>0</code> otherwise.</p>
<p>This doesn&rsquo;t sound too bad until you learn that in Verilog:</p>
<p><strong>If all the operands are signed, the result is signed. Otherwise, it&rsquo;s unsigned.</strong></p>
<p>Verilog doesn&rsquo;t consider it an error to mix signed and unsigned operands; it treats them all as unsigned. This leads to painful surprises that can be hard to debug.</p>
<p>Take a look at this example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#66d9ef">module</span> wider_tb ();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">logic</span> <span style="color:#66d9ef">signed</span> [<span style="color:#ae81ff">7</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] x, y;  <span style="color:#75715e">// signed 8 bits wide
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">logic</span> <span style="color:#66d9ef">signed</span> [<span style="color:#ae81ff">7</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] s;  <span style="color:#75715e">// signed 8 bits wide
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">logic</span>        [<span style="color:#ae81ff">7</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] u;  <span style="color:#75715e">// unsigned 8 bits wide
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">logic</span> <span style="color:#66d9ef">signed</span> [<span style="color:#ae81ff">3</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] m;  <span style="color:#75715e">// signed 4 bits wide
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">always_comb</span> <span style="color:#66d9ef">begin</span>
</span></span><span style="display:flex;"><span>        x <span style="color:#f92672">=</span> s <span style="color:#f92672">+</span> m;  <span style="color:#75715e">// signed + signed
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        y <span style="color:#f92672">=</span> u <span style="color:#f92672">+</span> m;  <span style="color:#75715e">// unsigned + signed
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">initial</span> <span style="color:#66d9ef">begin</span>
</span></span><span style="display:flex;"><span>        #<span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span>        s <span style="color:#f92672">=</span> <span style="color:#ae81ff">8</span>&#39;sb0000_0111;  <span style="color:#75715e">// decimal 7
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        u <span style="color:#f92672">=</span> <span style="color:#ae81ff">8</span><span style="color:#ae81ff">&#39;b0000</span>_0111;   <span style="color:#75715e">// decimal 7
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        #<span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span>        $display(<span style="color:#e6db74">&#34; s: %b  %d&#34;</span>, s, s);
</span></span><span style="display:flex;"><span>        $display(<span style="color:#e6db74">&#34; u: %b  %d&#34;</span>, u, u);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        #<span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span>        m <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>;  <span style="color:#75715e">// decimal 4
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        $display(<span style="color:#e6db74">&#34;When &#39;m&#39; is +4:&#34;</span>);
</span></span><span style="display:flex;"><span>        $display(<span style="color:#e6db74">&#34;m:     %b  %d&#34;</span>, m, m);
</span></span><span style="display:flex;"><span>        $display(<span style="color:#e6db74">&#34;x: %b  %d&#34;</span>, x, x);
</span></span><span style="display:flex;"><span>        $display(<span style="color:#e6db74">&#34;y: %b  %d&#34;</span>, y, y);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        #<span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span>        m <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">4</span>;  <span style="color:#75715e">// decimal -4
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        $display(<span style="color:#e6db74">&#34;When &#39;m&#39; is -4:&#34;</span>);
</span></span><span style="display:flex;"><span>        $display(<span style="color:#e6db74">&#34;m:     %b  %d&#34;</span>, m, m);
</span></span><span style="display:flex;"><span>        $display(<span style="color:#e6db74">&#34;x: %b  %d&#34;</span>, x, x);
</span></span><span style="display:flex;"><span>        $display(<span style="color:#e6db74">&#34;y: %b  %d  **SURPRISE**&#34;</span>, y, y);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">endmodule</span>
</span></span></code></pre></div><p>Running the wider test bench:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plaintext" data-lang="plaintext"><span style="display:flex;"><span>s: 00000111     7
</span></span><span style="display:flex;"><span>u: 00000111     7
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>When &#39;m&#39; is +4:
</span></span><span style="display:flex;"><span>m:     0100     4
</span></span><span style="display:flex;"><span>x: 00001011    11 
</span></span><span style="display:flex;"><span>y: 00001011    11
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>When &#39;m&#39; is -4:
</span></span><span style="display:flex;"><span>m:     1100    -4
</span></span><span style="display:flex;"><span>x: 00000011     3
</span></span><span style="display:flex;"><span>y: 00010011    19  **SURPRISE**
</span></span></code></pre></div><p>Looking at the binary, we can understand where 19 comes from.</p>
<p>When we set <code>m = -4</code> it has binary value <code>1100</code>.</p>
<p>When Verilog evaluates the expression <code>y = u + m</code>:</p>
<ol>
<li><code>m</code> is 4 bits wide, but <code>u</code> and <code>y</code> are 8 bits</li>
<li><code>m</code> must be widened to 8 bits to match the widest operands</li>
<li><code>u</code> is unsigned, so <code>m</code> is also considered unsigned</li>
<li>Being unsigned, <code>m</code> is widened to 8 bits with zeros: <code>00001100</code> (12 in decimal)</li>
<li><code>00001100 + 00000111 = 00010011</code> (12+7=19 in decimal)</li>
</ol>
<p>If you take one thing away from this post:</p>
<p><strong>Never mix signed and unsigned variables in one expression!</strong></p>
<h2 id="truncated">Truncated</h2>
<p>If the left-hand side of an assignment is smaller than the right-hand side, then the value is truncated. The following examples use literals, but this also applies to expressions and variables.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#66d9ef">wire</span> [<span style="color:#ae81ff">3</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] a <span style="color:#f92672">=</span> <span style="color:#ae81ff">15</span>;           <span style="color:#75715e">// a gets the value 1111
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">wire</span> [<span style="color:#ae81ff">3</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] b <span style="color:#f92672">=</span> <span style="color:#ae81ff">8</span><span style="color:#ae81ff">&#39;b10001010</span>;  <span style="color:#75715e">// b gets the value 1010
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">wire</span> [<span style="color:#ae81ff">3</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] c <span style="color:#f92672">=</span> <span style="color:#ae81ff">12&#39;hF0F</span>;      <span style="color:#75715e">// c gets the value 1111
</span></span></span></code></pre></div><p>Because <code>15</code> has no base, Verilog treats it as a signed 32-bit decimal:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plaintext" data-lang="plaintext"><span style="display:flex;"><span>0000_0000_0000_0000_0000_0000_0000_1111
</span></span></code></pre></div><p>For <code>a</code>, the truncated bits are all zero, so don&rsquo;t change the value.</p>
<p>If the right-hand side is signed, truncating it may change its value and sign:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#66d9ef">wire</span> <span style="color:#66d9ef">signed</span> [<span style="color:#ae81ff">3</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] d <span style="color:#f92672">=</span> <span style="color:#ae81ff">8</span><span style="color:#ae81ff">&#39;b11111100</span>;  <span style="color:#75715e">// d gets the value 1100 (-4)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">wire</span> <span style="color:#66d9ef">signed</span> [<span style="color:#ae81ff">3</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] e <span style="color:#f92672">=</span> <span style="color:#ae81ff">8</span><span style="color:#ae81ff">&#39;b11110011</span>;  <span style="color:#75715e">// e gets the value 0011 (-13 becomes +3)
</span></span></span></code></pre></div><p>We assigned -13 to <code>e</code>, but after truncation, we get +3.</p>
<p>Your synthesis tool or simulator should warn you about truncated values.</p>
<h2 id="reckoning-with-arithmetic">Reckoning with Arithmetic</h2>
<p>We&rsquo;ve talked a lot about the representation of numbers, but we&rsquo;ve yet to do much maths. Let&rsquo;s finish this post by having a quick look at the elementary arithmetic operations.</p>
<h3 id="addition">Addition</h3>
<p>Modern FPGAs include dedicated logic, such as <a href="https://www.fpga4fun.com/Counters4.html">carry chains</a>, to handle addition efficiently: there&rsquo;s no need to roll your own design. However, there are plenty of university slide decks online if you want to create an adder from scratch.</p>
<p>Before we skip over addition entirely, it&rsquo;s worth having a quick look at overflow.</p>
<p>Consider the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#66d9ef">wire</span> [<span style="color:#ae81ff">3</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] x, y, z;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">always_comb</span> z <span style="color:#f92672">=</span> x <span style="color:#f92672">+</span> y;
</span></span></code></pre></div><p>The signals <code>x</code> <code>y</code> <code>z</code> are unsigned and 4 bits wide.</p>
<p>If we set <code>x = 2</code> and <code>y = 9</code> then <code>(x + y) = 11</code> or <strong>1011<sub>2</sub></strong> in binary.</p>
<p><code>z</code> has the value <strong>1011<sub>2</sub></strong>: <code>z = 11</code> as expected.</p>
<p>If we set <code>x = 11</code> and <code>y = 7</code>, you might expect the result to be <code>(x + y) = 18</code> or <strong>10010<sub>2</sub></strong> in binary, which is then truncated to fit in <code>z</code>.</p>
<p>However, Verilog uses the width of the widest operand to evaluate expressions. The operands in our case are the three variables <code>x</code>, <code>y</code>, and <code>z</code>, all of which are 4 bits wide. Thus the result of the expression is <strong>0010<sub>2</sub></strong>, and it&rsquo;s assigned to <code>z</code>.</p>
<p><a href="https://en.wikipedia.org/wiki/Modular_arithmetic">Modular arithmatic</a>, where the result wraps around, is the norm in hardware and software.</p>
<h4 id="catching-the-overflow">Catching the Overflow</h4>
<p>However, there are times when you want to know if overflow has occurred:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#66d9ef">wire</span> [<span style="color:#ae81ff">3</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] x, y, z;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">wire</span> c;  <span style="color:#75715e">// carry bit
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">always_comb</span> {c, z} <span style="color:#f92672">=</span> x <span style="color:#f92672">+</span> y;
</span></span></code></pre></div><p>The widest operand in our new expression is <code>{c, z}</code>, which is 5 bits wide, so when we evaluate <code>x + y</code>, we get <strong>10010<sub>2</sub></strong>. The value of <strong>1</strong> gets assigned to <code>c</code> while <strong>0010<sub>2</sub></strong> is assigned to <code>z</code> as before.</p>
<p>You could use the carry bit to set an overflow flag when designing a CPU.</p>
<p>Another potential use is with <strong>saturation arithmetic</strong>: we keep <code>z</code> at its maximum value when overflow occurs:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#66d9ef">wire</span> [<span style="color:#ae81ff">3</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] x, y, z;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">wire</span> c;  <span style="color:#75715e">// carry bit
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">always_comb</span> <span style="color:#66d9ef">begin</span>
</span></span><span style="display:flex;"><span>    {c, z} <span style="color:#f92672">=</span> x <span style="color:#f92672">+</span> y;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (c) z <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span><span style="color:#ae81ff">&#39;b1111</span>;  <span style="color:#75715e">// 15: the maximum value z can hold
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">end</span>
</span></span></code></pre></div><p>With this saturation design, if <code>x = 11</code> and <code>y = 7</code>, then <code>z = 15</code>.</p>
<p>Learn more from <a href="https://en.wikipedia.org/wiki/Saturation_arithmetic">saturation arithmetic</a> on Wikipedia.</p>
<h3 id="subtraction">Subtraction</h3>
<p>Subtraction is almost the same as addition: subtracting <code>y</code> is equivalent to adding <code>-y</code>. It&rsquo;s easy to find <code>-y</code>, as we saw earlier when discussing <a href="#the-twos-complement">two&rsquo;s complement</a>.</p>
<p>Consider the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#66d9ef">wire</span> [<span style="color:#ae81ff">3</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] x, y, z;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">always_comb</span> z <span style="color:#f92672">=</span> x <span style="color:#f92672">-</span> y;
</span></span></code></pre></div><p>If we set <code>x = 11</code> and <code>y = 7</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plaintext" data-lang="plaintext"><span style="display:flex;"><span>Find -y:
</span></span><span style="display:flex;"><span>    Start:  0111    (decimal +7)
</span></span><span style="display:flex;"><span>    Invert: 1000
</span></span><span style="display:flex;"><span>    Add 1:  0001
</span></span><span style="display:flex;"><span>    Result: 1001    (decimal -7)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Add x and -y:
</span></span><span style="display:flex;"><span>      1011    +11  (x)
</span></span><span style="display:flex;"><span>    + 1001    - 7  (y)
</span></span><span style="display:flex;"><span>    = 0100    + 4  (z)
</span></span></code></pre></div><p>Your synthesis tool will handle this, but remember that subtraction is a little more complex than addition. Prefer incrementing over decrementing and register the results of subtractions before using them in subsequent calculations, especially on low-power FPGAs such as the iCE40UP.</p>
<h3 id="multiplication">Multiplication</h3>
<p>Multiplication is more complex than addition or subtraction, but modern FPGAs can handle it with dedicated DSP blocks.
Small vectors don&rsquo;t require too much thought, but the resulting output has potentially twice as many bits as the inputs:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span><span style="color:#66d9ef">wire</span> [<span style="color:#ae81ff">3</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] x;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">wire</span> [<span style="color:#ae81ff">3</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] y;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">wire</span> [<span style="color:#ae81ff">7</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>] z;  <span style="color:#75715e">// product (twice as wide)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">always_comb</span> z <span style="color:#f92672">=</span> x <span style="color:#f92672">*</span> y;
</span></span></code></pre></div><p>If we set <code>x = 11</code> and <code>y = 7</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plaintext" data-lang="plaintext"><span style="display:flex;"><span>Multiply x and y:
</span></span><span style="display:flex;"><span>          1011  +11  (x)
</span></span><span style="display:flex;"><span>    x     0111  + 7  (y)
</span></span><span style="display:flex;"><span>    = 01001101  +77  (z)
</span></span></code></pre></div><p>I&rsquo;ve written a dedicated post on <a href="/posts/multiplication-fpga-dsps">Multiplication with FPGA DSPs</a> that looks at the use of reg and pipelining to improve multiplication performance and minimise logic use.</p>
<h3 id="division">Division</h3>
<p>What about division? I&rsquo;ve bad news: Verilog won&rsquo;t synthesise this for you. The good news is that it&rsquo;s not hard to implement yourself: I have a dedicated post on <a href="/posts/division-in-verilog">Division in Verilog</a> that covers integers, fixed-point, and signed numbers.</p>
<h2 id="next-time">Next Time</h2>
<p>In the second part, we look at <a href="/posts/verilog-vectors-arrays">Vectors and Arrays</a> or jump ahead to <a href="/posts/fixed-point-numbers-in-verilog/">Fixed-Point Numbers</a>.</p>
<p><em>Get in touch with <a href="https://mastodon.social/@WillFlux">@WillFlux</a> or join me on <a href="https://github.com/projf/projf-explore/discussions">GitHub Discussions</a> and <a href="https://discord.gg/cf869yDbXf">1BitSquared Discord</a>.</em></p>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>Unpacked BCD uses a whole byte (8-bits) for each decimal digit.&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>

      
    </div>
    
  </div>
</section>

    <script src="/js/copycode.js"></script>



<section class="section">
  <div class="container has-text-centered">
    <p>©2023 Will Green, Project F</p>
    
  </div>
</section>


<script src="https://badgers.projectf.io/script.js" data-site="EVCGKVDN" defer></script>



</body>
</html>

